<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="C学习 - https://fire-phenix.github.io/posts/cc&#43;&#43;/c%E5%AD%A6%E4%B9%A0/">
    <meta name="author" content="fire-phenix - https://fire-phenix.github.io/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>C学习</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://fire-phenix.github.io/style.min.d252ad53a5e6b2ae6b8c6c1661107189be3668e36c8dd61697bbe008595a7e04.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": true,
		"svgColor": "",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            C学习
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

            <div id="toc">📜</div>
        
    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-page 
">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2023-09-22&nbsp;
        </span>
        <span>
            
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-09-22&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            98048 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            196 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		
		<div class="ctg">
			
			
		</div>
		<div class="tag">
			
			 - 
			
			<a href="/tags/c%E5%92%8Cc&#43;&#43;">c和c&#43;&#43;</a>
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        
        <div class="page-operation">
            <div><a href="#"><img src="/imgs/icons/arrow-up-circle.svg" alt=""></a></div>
            <div><a href="https://fire-phenix.github.io/posts/cc&#43;&#43;/c&#43;&#43;%E5%AD%A6%E4%B9%A0/"><img src="/imgs/icons/arrow-left-circle.svg" alt=""></a></div>
            <div><a href="https://fire-phenix.github.io/posts/golang/golang%E5%AD%A6%E4%B9%A0/"><img src="/imgs/icons/arrow-right-circle.svg" alt=""></a></div>
        </div>
        
        <nav id="TableOfContents">
  <ul>
    <li><a href="#数据类型">数据类型</a>
      <ul>
        <li><a href="#变量">变量</a></li>
        <li><a href="#字符类型">字符类型</a></li>
        <li><a href="#整数类型">整数类型</a></li>
        <li><a href="#浮点数类型">浮点数类型</a></li>
        <li><a href="#void类型"><code>void</code>类型</a></li>
        <li><a href="#字面量的类型">字面量的类型</a></li>
        <li><a href="#溢出">溢出</a></li>
        <li><a href="#类型转换">类型转换</a></li>
        <li><a href="#可移植类型">可移植类型</a></li>
      </ul>
    </li>
    <li><a href="#运算符">运算符</a>
      <ul>
        <li><a href="#自增自减运算符">自增、自减运算符</a></li>
        <li><a href="#位运算符">位运算符</a></li>
        <li><a href="#sizeof运算符"><code>sizeof</code>运算符</a></li>
      </ul>
    </li>
    <li><a href="#函数">函数</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#main"><code>main()</code></a></li>
        <li><a href="#参数的传值引用">参数的传值引用</a></li>
        <li><a href="#函数指针">函数指针</a></li>
        <li><a href="#函数原型">函数原型</a></li>
        <li><a href="#exit"><code>exit()</code></a></li>
        <li><a href="#函数说明符">函数说明符</a></li>
        <li><a href="#可变参数">可变参数</a></li>
      </ul>
    </li>
    <li><a href="#数组">数组</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#数组长度">数组长度</a></li>
        <li><a href="#多维数组">多维数组</a></li>
        <li><a href="#变长数组">变长数组</a></li>
        <li><a href="#数组的地址">数组的地址</a></li>
        <li><a href="#数组的复制">数组的复制</a></li>
        <li><a href="#作为函数的参数">作为函数的参数</a></li>
        <li><a href="#静态数组与动态数组">静态数组与动态数组</a></li>
      </ul>
    </li>
    <li><a href="#指针">指针</a>
      <ul>
        <li><a href="#简介-2">简介</a></li>
        <li><a href="#运算符-1"><code>*</code>运算符</a></li>
        <li><a href="#运算符-2"><code>&amp;</code>运算符</a></li>
        <li><a href="#指针变量的初始化">指针变量的初始化</a></li>
        <li><a href="#指针的运算">指针的运算</a></li>
        <li><a href="#指针数组">指针数组</a></li>
        <li><a href="#函数指针-1">函数指针</a></li>
        <li><a href="#回调函数">回调函数</a></li>
        <li><a href="#指向指针的指针">指向指针的指针</a></li>
        <li><a href="#复杂类型指针说明">复杂类型指针说明</a></li>
      </ul>
    </li>
    <li><a href="#字符串">字符串</a>
      <ul>
        <li><a href="#简介-3">简介</a></li>
        <li><a href="#字符串变量的声明">字符串变量的声明</a></li>
        <li><a href="#strlen">strlen()</a></li>
        <li><a href="#strcpy">strcpy()</a></li>
        <li><a href="#strncpy">strncpy()</a></li>
        <li><a href="#strcat">strcat()</a></li>
        <li><a href="#strncat">strncat()</a></li>
        <li><a href="#strcmp">strcmp()</a></li>
        <li><a href="#strncmp">strncmp()</a></li>
        <li><a href="#sprintfsnprintf">sprintf()，snprintf()</a></li>
        <li><a href="#字符串数组">字符串数组</a></li>
      </ul>
    </li>
    <li><a href="#内存管理">内存管理</a>
      <ul>
        <li><a href="#简介-4">简介</a></li>
        <li><a href="#void-指针">void 指针</a></li>
        <li><a href="#malloc">malloc()</a></li>
        <li><a href="#free">free()</a></li>
        <li><a href="#calloc">calloc()</a></li>
        <li><a href="#realloc">realloc()</a></li>
        <li><a href="#restrict-说明符">restrict 说明符</a></li>
        <li><a href="#memcpy">memcpy()</a></li>
        <li><a href="#memmove">memmove()</a></li>
        <li><a href="#memcmp">memcmp()</a></li>
      </ul>
    </li>
    <li><a href="#结构体">结构体</a>
      <ul>
        <li><a href="#简介-5">简介</a></li>
        <li><a href="#struct-的复制">struct 的复制</a></li>
        <li><a href="#struct-指针">struct 指针</a></li>
        <li><a href="#struct-的嵌套">struct 的嵌套</a></li>
        <li><a href="#位字段">位字段</a></li>
        <li><a href="#弹性数组成员">弹性数组成员</a></li>
        <li><a href="#双向循环链表">双向循环链表</a></li>
      </ul>
    </li>
    <li><a href="#typedef指令">typedef指令</a>
      <ul>
        <li><a href="#简介-6">简介</a></li>
        <li><a href="#主要好处">主要好处</a></li>
      </ul>
    </li>
    <li><a href="#union-结构">Union 结构</a>
      <ul>
        <li><a href="#共用体作用">共用体作用</a></li>
        <li><a href="#共用体应用场景">共用体应用场景</a></li>
      </ul>
    </li>
    <li><a href="#位域">位域</a>
      <ul>
        <li><a href="#位域声明">位域声明</a></li>
        <li><a href="#位域的定义和位域变量的说明">位域的定义和位域变量的说明</a></li>
        <li><a href="#位域的使用">位域的使用</a></li>
        <li><a href="#位域的内存分配">位域的内存分配</a></li>
      </ul>
    </li>
    <li><a href="#枚举">枚举</a></li>
    <li><a href="#预处理器">预处理器</a>
      <ul>
        <li><a href="#简介-7">简介</a></li>
        <li><a href="#define">#define</a></li>
        <li><a href="#带参数的宏">带参数的宏</a></li>
        <li><a href="#undef">#undef</a></li>
        <li><a href="#include">#include</a></li>
        <li><a href="#ifendif">#if&hellip;#endif</a></li>
        <li><a href="#ifdefendif">#ifdef&hellip;#endif</a></li>
        <li><a href="#defined-运算符">defined 运算符</a></li>
        <li><a href="#ifndefendif">#ifndef&hellip;#endif</a></li>
        <li><a href="#预定义宏">预定义宏</a></li>
        <li><a href="#line">#line</a></li>
        <li><a href="#error">#error</a></li>
        <li><a href="#pragma">#pragma</a></li>
      </ul>
    </li>
    <li><a href="#io函数">IO函数</a>
      <ul>
        <li><a href="#缓存和字节流">缓存和字节流</a></li>
        <li><a href="#printf">printf()</a></li>
        <li><a href="#scanf">scanf()</a></li>
        <li><a href="#sscanf">sscanf()</a></li>
        <li><a href="#getcharputchar">getchar()，putchar()</a></li>
        <li><a href="#puts">puts()</a></li>
        <li><a href="#gets">gets()</a></li>
      </ul>
    </li>
    <li><a href="#错误处理">错误处理</a></li>
    <li><a href="#多文件项目">多文件项目</a>
      <ul>
        <li><a href="#重复加载">重复加载</a></li>
        <li><a href="#extern-说明符">extern 说明符</a></li>
        <li><a href="#static-说明符">static 说明符</a></li>
        <li><a href="#编译策略">编译策略</a></li>
        <li><a href="#make-命令">make 命令</a></li>
      </ul>
    </li>
    <li><a href="#变量说明符">变量说明符</a>
      <ul>
        <li><a href="#const">const</a></li>
        <li><a href="#static">static</a></li>
        <li><a href="#auto">auto</a></li>
        <li><a href="#extern">extern</a></li>
        <li><a href="#register">register</a></li>
        <li><a href="#volatile">volatile</a></li>
        <li><a href="#restrict">restrict</a></li>
      </ul>
    </li>
    <li><a href="#多字节字符">多字节字符</a>
      <ul>
        <li><a href="#unicode-简介">Unicode 简介</a></li>
        <li><a href="#字符的表示方法">字符的表示方法</a></li>
        <li><a href="#多字节字符的表示">多字节字符的表示</a></li>
        <li><a href="#宽字符">宽字符</a></li>
        <li><a href="#多字节字符处理函数">多字节字符处理函数</a></li>
      </ul>
    </li>
    <li><a href="#命令行环境">命令行环境</a>
      <ul>
        <li><a href="#命令行参数">命令行参数</a></li>
        <li><a href="#退出状态">退出状态</a></li>
        <li><a href="#环境变量">环境变量</a></li>
      </ul>
    </li>
    <li><a href="#多线程">多线程</a>
      <ul>
        <li><a href="#创建多线程">创建多线程</a></li>
        <li><a href="#终止线程">终止线程</a></li>
        <li><a href="#连接和分离线程">连接和分离线程</a></li>
        <li><a href="#示例程序">示例程序</a></li>
        <li><a href="#并发程序引起的共享内存问题">并发程序引起的共享内存问题</a></li>
        <li><a href="#信号量机制">信号量机制</a></li>
      </ul>
    </li>
    <li><a href="#网络编程">网络编程</a>
      <ul>
        <li><a href="#socket编程">Socket编程</a></li>
      </ul>
    </li>
    <li><a href="#标准库">标准库</a>
      <ul>
        <li><a href="#asserth">assert.h</a></li>
        <li><a href="#ctypeh">ctype.h</a></li>
        <li><a href="#errnoh">errno.h</a></li>
        <li><a href="#floath">float.h</a></li>
        <li><a href="#inttypesh">inttypes.h</a></li>
        <li><a href="#iso646h">iso646.h</a></li>
        <li><a href="#limitsh">limits.h</a></li>
        <li><a href="#localeh">locale.h</a></li>
        <li><a href="#mathh">math.h</a></li>
        <li><a href="#signalh">signal.h</a></li>
        <li><a href="#stdinth">stdint.h</a></li>
        <li><a href="#stdlibh">stdlib.h</a></li>
        <li><a href="#stdioh">stdio.h</a></li>
        <li><a href="#stringh">string.h</a></li>
        <li><a href="#timeh">time.h</a></li>
        <li><a href="#wcharh">wchar.h</a></li>
        <li><a href="#wctypeh">wctype.h</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  content '>
        <h1 id="c学习">C学习</h1>
<p>C 语言是一种通用的、面向过程式的计算机程序设计语言。最初是由<code>丹尼斯·里奇</code>在贝尔实验室为开发<code>UNIX</code>操作系统而设计的。C 语言最开始是于 1972 年在<code>DEC PDP-11</code>计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">这一句话是必须要的格式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">stdio 表示系统文件库, 也可以声明其它的
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">.h  表示头文件,因为这些文件都是放在程序各文件的开头
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">#include 告诉预处理器将指定头文件的内容插入到预处理器命令的相应位  导入头文件的预编译指令
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">&lt;&gt; 表示从系统自带的库中读取
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">也可以使用双引号(&#34; &#34;)表示用户自定义的库
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">如果写成(&#34; &#34;)并且自定义的库里面没有这个文件系统会自动查找自带的库,如果还是没有报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;  </span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">int 表示数字格式,返回一个数字
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main()主函数 表示程序的入口  一个程序有且只能有一个main函数的存在
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() { <span style="color:#998;font-style:italic">// 程序的入口函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//程序从这里开始运行
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;hello C&#34;</span>); <span style="color:#998;font-style:italic">//打印一个hello C
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 在main()方法中不写return语句不报错,因为编译器会自动添加return语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 但是为了编程规范，尽量写上return语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>; <span style="color:#998;font-style:italic">// 返回一个整数0,因为它是int类型,所以只能返回整数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}  <span style="color:#998;font-style:italic">//程序从这里结束
</span></span></span></code></pre></div><p>运行 <strong>C</strong> 程序，<code>main(int argc, char *argv[])</code>函数传参，<code>argc</code>为参数个数，<code>argv</code>是字符串数组， 下标从<code>0</code>开始，第一个存放的是可执行程序的文件名字，然后依次存放传入的参数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt; </span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>argv[]) { 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">/* 我的第一个 C 程序 */</span> 
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;可执行程序 %s ,参数个数为[%d], 运行输出：[%s]</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,argv[<span style="color:#099">0</span>],argc,argv[<span style="color:#099">1</span>]); 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译<code>gcc HelloWorld.c</code>，得到可执行程序<code>a.out</code>，运行程序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./a.out Hello,World!
</span></span><span style="display:flex;"><span>可执行程序 ./a.out ,参数个数为<span style="color:#000;font-weight:bold">[</span>2<span style="color:#000;font-weight:bold">]</span>, 运行输出：<span style="color:#000;font-weight:bold">[</span>Hello,World!<span style="color:#000;font-weight:bold">]</span>
</span></span></code></pre></div><p>C 程序主要包括以下部分：预处理器指令、函数、变量、语句 &amp; 表达式、注释</p>
<p><code>gcc</code>命令如果不指定目标文件名时默认生成的可执行文件名为<code>a.out(linux)</code>或<code>a.exe(windows)</code>。</p>
<p>可用<code>gcc [源文件名] -o [目标文件名]</code>来指定目标文件路径及文件名。</p>
<p>例如，<code>windows</code>系统上，<code>gcc hello.c -o target/hello</code>会在<code>target</code>目录下生成<code>hello.exe</code>文件(Linux 系统生成 hello 可执行文件)，<code>target</code>目录必须已存在，<code>[源文件名] 和 -o [目标文件名]</code>的顺序可互换， <code>gcc -o target/hello hello.c</code>依然有效。</p>
<p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号</p>
<p><strong>C语言的程序构成方式</strong></p>
<ul>
<li>c语言程序由函数构成，每个函数可以实现一个或多个功能。(尽量使用一个函数实现一个功能)</li>
<li>一个正规程序可以有多个函数，但是有且只有一个主函数(<code>main()</code>函数)。</li>
<li>函数只有在被调用的时候才执行，主函数由操作系统调用执行。</li>
<li>函数的格式必须按照规范书写。</li>
<li>C 语言程序文件的后缀为<code>.c</code>（源码文件）或<code>.h</code>（头文件）</li>
</ul>
<p>**标识符：**在编程语言中，标识符是用户编程时使用的名字，变量、常量、函数、语句块都有名字。是用来标识某个实体的一个符号，是对变量名、函数名、标号和其他各种用户定义的对象命名。</p>
<p>C语言中标识符的命名规范：</p>
<ul>
<li>标识符由<strong>字母</strong>、<strong>数字</strong>、<strong>下划线(<code>_</code>)<strong>和</strong><code>$</code>符号</strong>组成，并且<strong>首字母不能是数字</strong>。</li>
<li>不能把C语言的关键字作为用户的标识符（注：标识符不能和C语言的关键字相同，也不能和用户自定义的函数或C语言库函数同名）</li>
<li>标识符长度是由机器上的编译系统决定的，一般的限制为8字符，(注：8字符长度限制是C89标准，C99标准已经扩充长度，其实大部分工业标准都更长)。</li>
<li>标识符对<strong>大小写敏感</strong>，即严格区分大小写。一般对变量名用小写，符号常量命名用大写。（注：C语言中字母是区分大小写的，因此score、Score、SCORE分别代表三个不同的标识符）</li>
<li>标识符命名应做到&quot;<strong>见名知意</strong>&quot;</li>
</ul>
<p><strong>C 语言有两种注释方式：</strong></p>
<ul>
<li>以<code>//</code>开始的单行注释，这种注释可以单独占一行，也可以出现在一行中其他内容的右侧，注意这种注释不能跨行。若注释内容一行内写不下可以在下一行重新用 <strong>//</strong> ，继续写注释。</li>
<li>以<code>/*</code>开始，以<code>*/</code>结束的块式注释。这种注释可以包含多行内容。编译系统在发现一个<code>/*</code>后，会开始找注释结束符 <code>*/</code>，把两者间的内容作为注释。</li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
<h3 id="变量">变量</h3>
<p><em>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</em></p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:center">通常是一个字节（八位）, 这是一个整数类型。</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:center">整型，4 个字节，取值范围<code>-2147483648</code>到<code>2147483647</code>。</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:center">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:center">双精度浮点值。双精度是1位符号，11位指数，52位小数。</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:center">表示类型的缺失。</td>
</tr>
</tbody>
</table>
<p>单精度浮点数：</p>
<p><img src="./images/202309231157841.png" alt="img"></p>
<p>双精度浮点数：</p>
<p><img src="./images/202309231157750.png" alt="img"></p>
<p>在C语言中，变量的寻址是指确定变量在计算机内存中的位置，以便在程序中访问和操作。变量的寻址涉及到内存管理和计算机体系结构的复杂性，但可以简单地概括如下：</p>
<ol>
<li>
<p><strong>变量声明</strong>：在C语言中，变量首先需要被声明，以便编译器知道它们的类型和名称。例如：<code>int x;</code></p>
</li>
<li>
<p><strong>分配内存</strong>：一旦变量被声明，编译器会根据其类型来为它们分配内存空间。这通常发生在栈内存（stack）或堆内存（heap）中，具体取决于变量的生存周期和作用域。</p>
<ul>
<li><strong>栈内存</strong>：栈是一种内存区域，用于存储函数调用期间的局部变量和函数调用信息。栈上的变量通常具有较短的生命周期，它们在函数执行时被分配，函数返回时被自动销毁。</li>
<li><strong>堆内存</strong>：堆是一种动态分配的内存区域，用于存储具有较长生命周期的变量，通常需要手动分配和释放。动态分配的变量通常使用<code>malloc()</code>、<code>calloc()</code>和<code>realloc()</code>等函数进行分配，使用<code>free()</code>函数进行释放。</li>
</ul>
</li>
<li>
<p><strong>变量访问</strong>：一旦变量被分配了内存，程序就可以使用变量名来访问和操作。例如：<code>x = 10;</code></p>
</li>
<li>
<p><strong>指针</strong>：C语言中的指针是一种特殊类型的变量，它存储了另一个变量的内存地址。通过指针，可以直接访问和修改其他变量的值，这使得动态内存分配和数据结构操作变得更加灵活。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr; <span style="color:#998;font-style:italic">// 声明一个整数指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x; <span style="color:#998;font-style:italic">// 将指针指向变量x的地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>ptr <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">20</span>; <span style="color:#998;font-style:italic">// 通过指针修改x的值
</span></span></span></code></pre></div></li>
<li>
<p><strong>寻址运算符</strong>：C语言提供了<code>&amp;</code>运算符，用于获取变量的地址。例如，<code>&amp;x</code>返回变量<code>x</code>的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x; <span style="color:#998;font-style:italic">// 将指针ptr指向变量x的地址
</span></span></span></code></pre></div></li>
</ol>
<p>需要注意的是，变量的寻址方式可以受到编译器和操作系统的影响。不同的编译器和平台可能会采用不同的内存管理策略，因此在涉及底层内存操作或跨平台开发时，需要格外小心确保变量的寻址是正确的。此外，使用指针时需要特别谨慎，以避免潜在的内存错误和安全问题。</p>
<p><strong>全局变量和局部变量在内存中的区别</strong></p>
<p><strong>全局变量保存在内存的全局存储区</strong>中，占用静态的存储单元；<strong>局部变量保存在栈</strong>中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<p>C语言经过编译之后将内存分为以下几个区域：</p>
<ul>
<li>栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</li>
<li>堆（heap）：用于程序动态申请分配和释放空间。C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。</li>
<li>全局（静态）存储区：分为<code>DATA</code>段和<code>BSS</code>段。<code>DATA</code>段（全局初始化区）存放初始化的全局变量和静态变量；<code>BSS</code>段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中<code>BBS</code>段在程序执行之前会被系统自动清<code>0</code>，所以未初始化的全局变量和静态变量在程序执行之前已经为<code>0</code>。</li>
<li>文字常量区：存放常量字符串。程序结束后由系统释放。</li>
<li>程序代码区：存放程序的二进制代码。</li>
</ul>
<p>显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。</p>
<blockquote>
<p>变量在使用前就要被定义或者声明；在一个程序中，变量只能定义一次，却可以声明多次；定义分配存储空间，而声明不会。</p>
</blockquote>
<h3 id="字符类型">字符类型</h3>
<p>字符类型指的是<strong>单个字符</strong>，类型声明使用<code>char</code>关键字。C 语言规定，字符常量必须放在单引号里面。</p>
<blockquote>
<p>在 C 语言中，单引号与双引号是有很大区别的：</p>
<p>C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，代表指向这个数组起始字符的指针；而单引号中的内容是一个<code>char</code>类型，是一个字符，对应的是 ASCII 表中的序列值</p>
</blockquote>
<p>在计算机内部，<strong>字符类型使用一个字节（8位）存储</strong>。C 语言将其当作整数处理，所以字符类型就是宽度为一个字节的整数。<u>每个字符对应一个整数（由 ASCII 码确定）</u>，比如<code>B</code>对应整数<code>66</code>。</p>
<p>字符类型在不同计算机的默认范围是不一样的。一些系统默认为<code>-128</code>到<code>127</code>，另一些系统默认为<code>0</code>到<code>255</code>。</p>
<p>只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">66</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;B&#39;</span>;
</span></span></code></pre></div><p>两个字符类型的变量可以进行数学运算。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;B&#39;</span>; <span style="color:#998;font-style:italic">// 等同于 char a = 66;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;C&#39;</span>; <span style="color:#998;font-style:italic">// 等同于 char b = 67;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, a <span style="color:#000;font-weight:bold">+</span> b); <span style="color:#998;font-style:italic">// 输出 133
</span></span></span></code></pre></div><p>转义写法还能使用八进制和十六进制表示一个字符。</p>
<ul>
<li><code>\nn</code>：字符的八进制写法，<code>nn</code>为八进制值。</li>
<li><code>\xnn</code>：字符的十六进制写法，<code>nn</code>为十六进制值。</li>
</ul>
<h3 id="整数类型">整数类型</h3>
<p>不同计算机的<code>int</code>类型的大小是不一样的。比较常见的是<strong>使用4个字节（32位）存储一个<code>int</code>类型的值</strong>，但是2个字节（16位）或8个字节（64位）也有可能使用。它们可以表示的整数范围如下。</p>
<ul>
<li>16位：-32,768 到 32,767。</li>
<li>32位：-2,147,483,648 到 2,147,483,647。</li>
<li>64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li>
</ul>
<p>C 语言使用<code>signed</code>关键字，表示一个类型带有正负号，包含负值；使用<code>unsigned</code>关键字，表示该类型不带有正负号，只能表示零和正整数。</p>
<p>整数变量声明为<code>unsigned</code>的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的<code>signed int</code>最大值为<code>32,767</code>，而<code>unsigned int</code>的最大值增大到了<code>65,535</code>。</p>
<blockquote>
<p>注意，C 语言规定<code>char</code>类型默认是否带有正负号，由当前系统决定。这就是说，<code>char</code>不等同于<code>signed char</code>，它有可能是<code>signed char</code>，也有可能是<code>unsigned char</code>。这一点与<code>int</code>不同，<code>int</code>就是等同于<code>signed int</code></p>
</blockquote>
<ul>
<li><code>short int</code>（简写为<code>short</code>）：占用空间不多于<code>int</code>，一般占用2个字节（整数范围为-32768～32767)。</li>
<li><code>long int</code>（简写为<code>long</code>）：占用空间不少于<code>int</code>，至少为4个字节。</li>
<li><code>long long int</code>（简写为<code>long long</code>）：占用空间多于<code>long</code>，至少为8个字节。</li>
</ul>
<p>默认情况下，<code>short</code>、<code>long</code>、<code>long long</code>都是带符号的（signed），即<code>signed</code>关键字省略了。它们也可以声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。</p>
<p>当前系统不同整数类型的最大值和最小值，C 语言的头文件<code>limits.h</code>提供了相应的常量，比如<code>SCHAR_MIN</code>代表 signed char 类型的最小值<code>-128</code>，<code>SCHAR_MAX</code>代表 signed char 类型的最大值<code>127</code>。</p>
<p>为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。</p>
<ul>
<li><code>SCHAR_MIN</code>，<code>SCHAR_MAX</code>：<code>signed char</code> 的最小值和最大值。</li>
<li><code>SHRT_MIN</code>，<code>SHRT_MAX</code>：<code>short</code> 的最小值和最大值。</li>
<li><code>INT_MIN</code>，<code>INT_MAX</code>：<code>int</code> 的最小值和最大值。</li>
<li><code>LONG_MIN</code>，<code>LONG_MAX</code>：<code>long</code> 的最小值和最大值。</li>
<li><code>LLONG_MIN</code>，<code>LLONG_MAX</code>：<code>long long</code> 的最小值和最大值。</li>
<li><code>UCHAR_MAX</code>：<code>unsigned char</code> 的最大值。</li>
<li><code>USHRT_MAX</code>：<code>unsigned short</code> 的最大值。</li>
<li><code>UINT_MAX</code>：<code>unsigned int</code> 的最大值。</li>
<li><code>ULONG_MAX</code>：<code>unsigned long</code> 的最大值。</li>
<li><code>ULLONG_MAX</code>：<code>unsigned long long</code> 的最大值。</li>
</ul>
<p>八进制使用<code>0</code>作为前缀，比如<code>017</code>、<code>0377</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">012</span>; <span style="color:#998;font-style:italic">// 八进制，相当于十进制的10
</span></span></span></code></pre></div><p>十六进制使用<code>0x</code>或<code>0X</code>作为前缀，比如<code>0xf</code>、<code>0X10</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0x1A2B</span>; <span style="color:#998;font-style:italic">// 十六进制，相当于十进制的6699
</span></span></span></code></pre></div><p>有些编译器使用<code>0b</code>前缀，表示二进制数，但不是标准。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>b101010;
</span></span></code></pre></div><p><code>printf()</code>的进制相关占位符如下。</p>
<ul>
<li><code>%d</code>：十进制整数。</li>
<li><code>%o</code>：八进制整数。</li>
<li><code>%x</code>：十六进制整数。</li>
<li><code>%#o</code>：显示前缀<code>0</code>的八进制整数。</li>
<li><code>%#x</code>：显示前缀<code>0x</code>的十六进制整数。</li>
<li><code>%#X</code>：显示前缀<code>0X</code>的十六进制整数。</li>
</ul>
<p>注意，不同的进制只是整数的书写方法，不会对整数的实际存储方式产生影响。<strong>所有整数都是二进制形式存储，跟书写方式无关</strong>。</p>
<h3 id="浮点数类型">浮点数类型</h3>
<p>任何有小数点的数值，都会被编译器解释为浮点数。所谓“浮点数”就是使用<code>m * be</code>的形式，存储一个数值，<code>m</code>是小数部分，<code>b</code>是基数（通常是<code>2</code>），<code>e</code>是指数部分。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> d <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">6.023e23</span>; <span style="color:#998;font-style:italic">// 6.023*10的23次方 
</span></span></span></code></pre></div><p>浮点数的指数形式：由数字0-9、字母e（或E）和+、-号组成，它的形式为aEn，意为<code>a✖️10^n</code>，其中<code>a</code>为十进制整数或小数，<code>n</code>为十进制整数。在表示浮点型常量时，需注意几点：</p>
<ul>
<li>以指数形式表示实数时，<code>a</code>和<code>n</code>都不能省略，<code>n</code>必须为整数；以十进制小数形式表示实数时，整数和小数部分可省略其中任一个</li>
<li>浮点型常量默认是<code>double</code>型，若在后面加上<code>F</code>或<code>f</code>，则其类型为<code>float</code>实数以指数形式存储的，以<code>float</code>类型为例，大多数C编译系统使用4个连续的字节（即32位）存储在<code>float</code>类型数据。这32位分为4个部分（在4个字节中，究竟小数部分和指数部分分别占多少位，ANSI C 本身并没有作规定，由具体的编译系统决定。不少C语言编译系统用24位表示数符号和指数部分）：
<ul>
<li>第一部分：为数的符号；</li>
<li>第二部分：使用若干位存储小数的部分；</li>
<li>第三部分：指数的符号位；</li>
<li>第四部分：指数。</li>
</ul>
</li>
</ul>
<p>由实数的存储形式可看出，小数部分占的位数越多，所能表示的精度越高，指数部分占的越多，所能表示的数值范围越大。</p>
<p><code>float（单精度浮点数）</code>：通常使用32位表示，其中1位表示符号（正负），8位表示指数，23位表示小数部分。它的范围大约是从<code>-3.4e38</code>到<code>3.4e38</code>，精度在小数点后大约有7位数字。</p>
<p><code>double（双精度浮点数）</code>：通常使用64位表示，其中1位表示符号，11位表示指数，52位表示小数部分。它的范围大约是从<code>-1.7e308</code>到<code>1.7e308</code>，精度在小数点后大约有15到16位数字。</p>
<p><code>long double（长双精度浮点数）</code>：这是一个更高精度的浮点数类型，通常使用80位或128位表示，具体取决于编译器和体系结构。它的范围和精度要比double更大。</p>
<p>浮点数表示在极端值附近可能存在精度损失问题，这是由于浮点数的有限表示。在需要高精度计算的情况下，可能需要使用更高精度的数值类型，或者使用专门设计的数值计算库。</p>
<p>浮点数的范围和精度也受到计算机硬件和编程语言的实现的影响，不同的计算机体系结构和编译器可能会有不同的精度和范围限制。因此，在进行关键数值计算时，应该仔细考虑浮点数的精度和范围限制，以避免意外的错误。</p>
<blockquote>
<p>注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面<code>0.1 + 0.2</code>并不等于<code>0.3</code>，而是有一个很小的误差。</p>
</blockquote>
<h3 id="void类型"><code>void</code>类型</h3>
<p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<p><strong>函数返回为空</strong>：函数可以不返回值，或者说返回空。不返回值的函数的返回类型为空。<code>void exit(int status);</code></p>
<p><strong>函数参数为空</strong>：函数可以不接受任何参数。不带参数的函数可以接受一个<code>void</code>。例如<code>int rand(void);</code></p>
<p><strong>指针指向<code>void</code></strong>：类型为<code>void *</code>的指针代表对象的地址，而不是类型。例如，内存分配函数<code>void *malloc( size_t size );</code>返回指向<code>void</code>的指针，可以转换为任何数据类型。</p>
<h3 id="字面量的类型">字面量的类型</h3>
<p>字面量（literal）指的是代码里面直接出现的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x是变量，123就是字面量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">123</span>;
</span></span></code></pre></div><p>编译时，字面量也会写入内存，因此编译器必须为字面量指定数据类型，就像必须为变量指定数据类型一样。</p>
<h3 id="溢出">溢出</h3>
<p>每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。</p>
<p>一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。</p>
<h3 id="类型转换">类型转换</h3>
<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>
<p>C 语言中有两种类型转换：</p>
<ul>
<li>**隐式类型转换：**隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将<code>int</code>类型转换为<code>long</code>类型或<code>float</code>类型转换为<code>double</code>类型。隐式类型转换也可能会导致数据精度丢失或数据截断。</li>
<li>**显式类型转换：**显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。</li>
</ul>
<h4 id="类型的自动转换">类型的自动转换</h4>
<p>赋值运算符会自动将右边的值，转成左边变量的类型。</p>
<ul>
<li>浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。</li>
<li>整数赋值给浮点数变量时，会自动转为浮点数。</li>
<li>字节宽度较小的整数类型，赋值给字节宽度较大的整数变量时，会发生类型提升，即窄类型自动转为宽类型。</li>
<li>字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。</li>
</ul>
<p>如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型后才能进行计算：</p>
<ul>
<li>整数与浮点数混合运算时，整数转为浮点数类型，数值不变，但是被存储到相应的浮点型变量中后，与另一个运算数类型相同。浮点数赋给整型，该浮点数小数部分被直接舍去</li>
<li>不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型，比如<code>float</code>转为<code>double</code>，<code>double</code>转为<code>long double</code></li>
<li>不同的整数类型混合运算时，宽度较小的类型会提升为宽度较大的类型。</li>
</ul>
<p>两个相同类型的整数运算时，或者单个整数的运算，一般来说，运算结果也属于同一类型。但是有一个例外，宽度小于<code>int</code>的类型，运算结果会自动提升为<code>int</code>。</p>
<p>函数的参数和返回值，会自动转成函数定义里指定的类型。</p>
<h4 id="显式转换">显式转换</h4>
<p>C 语言提供了类型的显式转换，允许手动转换类型。强制类型转换形式：<code>(类型说明符) (表达式)</code></p>
<p>只要在一个值或变量的前面，使用圆括号指定类型<code>(type)</code>，就可以将这个值或变量转为指定的类型</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> d <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.14159</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span>)d; <span style="color:#998;font-style:italic">// 显式将double类型转换为int类型
</span></span></span></code></pre></div><h3 id="可移植类型">可移植类型</h3>
<p>C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。程序员有时需要控制准确的字节宽度，代码可以有更好的可移植性，头文件<code>stdint.h</code>创造了一些新的类型别名。</p>
<p>精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</p>
<ul>
<li><code>int8_t</code>：8位有符号整数。范围：<code>[-128, 127]</code></li>
<li><code>int16_t</code>：16位有符号整数。范围：<code>[-32768, 32767]</code></li>
<li><code>int32_t</code>：32位有符号整数。范围：<code>[-2147483648, 2147483647]</code></li>
<li><code>int64_t</code>：64位有符号整数。范围：<code>[-9223372036854775808, 9223372036854775807]</code></li>
<li><code>uint8_t</code>：8位无符号整数。范围：<code>[0, 256]</code></li>
<li><code>uint16_t</code>：16位无符号整数。</li>
<li><code>uint32_t</code>：32位无符号整数。</li>
<li><code>uint64_t</code>：64位无符号整数。</li>
</ul>
<p>最小宽度类型（minimum width type），保证某个整数类型的最小长度。</p>
<ol>
<li><strong>int_least8_t</strong>：至少有8位的有符号整数。最小范围：-127 到 127 或更大</li>
<li><strong>uint_least8_t</strong>：至少有8位的无符号整数。最小范围：0 到 255 或更大</li>
<li><strong>int_least16_t</strong>：至少有16位的有符号整数。最小范围：-32,767 到 32,767 或更大</li>
<li><strong>uint_least16_t</strong>：至少有16位的无符号整数。最小范围：0 到 65,535 或更大</li>
<li><strong>int_least32_t</strong>：至少有32位的有符号整数。最小范围：-2,147,483,647 到 2,147,483,647 或更大</li>
<li><strong>uint_least32_t</strong>：至少有32位的无符号整数。最小范围：0 到 4,294,967,295 或更大</li>
<li><strong>int_least64_t</strong>：至少有64位的有符号整数。最小范围：<code>-9223372036854775807</code>到<code>9223372036854775807</code>或更大</li>
<li><strong>uint_least64_t</strong>：至少有64位的无符号整数。最小范围：0 到 18,446,744,073,709,551,615 或更大</li>
</ol>
<p>这些最小宽度整数类型的具体位数可以超过最小要求，但至少具有所指定的最小位数。使用这些类型可在需要某个特定最小范围的整数变量时提供灵活性，同时仍然提供了可移植性，因为最小宽度类型的大小会根据不同的平台和编译器进行适当的扩展。</p>
<blockquote>
<p>注意，最小宽度整数类型在不同平台和编译器之间可能具有不同的实际位数和范围，但它们保证至少满足所指定的最小要求。</p>
</blockquote>
<p>最快的最小宽度类型（fast minimum width type），可以使整数计算达到最快的类型。</p>
<ul>
<li>int_fast8_t</li>
<li>int_fast16_t</li>
<li>int_fast32_t</li>
<li>int_fast64_t</li>
<li>uint_fast8_t</li>
<li>uint_fast16_t</li>
<li>uint_fast32_t</li>
<li>uint_fast64_t</li>
</ul>
<p>可以保存指针的整数类型。</p>
<ul>
<li><code>intptr_t</code>：可以存储指针（内存地址）的有符号整数类型。</li>
<li><code>uintptr_t</code>：可以存储指针的无符号整数类型。</li>
</ul>
<p>最大宽度整数类型，用于存放最大的整数。</p>
<ul>
<li><code>intmax_t</code>：可以存储任何有效的有符号整数的类型。</li>
<li><code>uintmax_t</code>：可以存放任何有效的无符号整数的类型。</li>
</ul>
<h2 id="运算符">运算符</h2>
<h3 id="自增自减运算符">自增、自减运算符</h3>
<p><code>++</code>自增运算符，<code>--</code>自减运算符</p>
<p><code>++var</code>和<code>--var</code>是先执行自增或自减操作，再返回操作后<code>var</code>的值；</p>
<p><code>var++</code>和<code>var--</code>则是先返回操作前<code>var</code>的值，再执行自增或自减操作。</p>
<h3 id="位运算符">位运算符</h3>
<p>C 语言提供一些位运算符，用来操作<strong>二进制位（bit）</strong></p>
<p>取反运算符<code>～</code>：是一个一元运算符，用来将每一个二进制位变成相反值，即<code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code>。</p>
<blockquote>
<p>注意，<code>~</code>运算符不会改变变量的值，只是返回一个新的值</p>
</blockquote>
<p>与运算符<code>&amp;</code>将两个值的对应二进制位进行比较，返回一个新的值。当两个二进制位都为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code></p>
<p>或运算符<code>|</code>将两个值的对应二进制位进行比较，返回一个新的值。两个二进制位只要有一个为<code>1</code>（包含两个都为<code>1</code>的情况），就返回<code>1</code>，否则返回<code>0</code>。</p>
<p>异或运算符<code>^</code>将两个值的对应二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>。</p>
<p>左移运算符<code>&lt;&lt;</code>将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用<code>0</code>填充。</p>
<blockquote>
<p>左移运算符相当于将左侧运算数乘以2的指定次方，比如<code>&lt;&lt; 2</code>（左移2位相当于乘以4（2的2次方））</p>
</blockquote>
<p>右移运算符<code>&gt;&gt;</code>将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用<code>0</code>填充。</p>
<blockquote>
<p>注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。</p>
<p>右移运算符相当于将左侧运算数除以2的指定次方，比如<code>&gt;&gt; 2</code>(右移2位就相当于除以4（2的2次方）)</p>
</blockquote>
<h3 id="sizeof运算符"><code>sizeof</code>运算符</h3>
<p><code>sizeof</code>是 C 语言提供的一个<strong>运算符</strong>，<strong>计算某种数据类型或某个值占用的字节数量</strong>。</p>
<p><code>sizeof</code>运算符的返回值，C 语言规定是无符号整数，并没有规定具体的类型，而是留给系统自己去决定。<code>sizeof</code>到底返回什么类型，不同的系统中，返回值的类型也不同。不利于程序的移植性</p>
<p>C 语言提供了一个解决方法，创造了一个类型别名<code>size_t</code>，用来统一表示<code>sizeof</code>的返回值类型。该别名定义在<code>stddef.h</code>头文件（引入<code>stdio.h</code>时会自动引入）里面，对应当前系统的<code>sizeof</code>的返回值类型，可能是<code>unsigned int</code>，也可能是<code>unsigned long</code>。</p>
<p>C 语言还提供了一个常量<code>SIZE_MAX</code>，表示<code>size_t</code>可以表示的最大整数。所以，<code>size_t</code>能够表示的整数范围为<code>[0, SIZE_MAX]</code>。</p>
<p><code>printf()</code>有专门的占位符<code>%zd</code>或<code>%zu</code>，用来处理<code>size_t</code>类型的值。（如果当前系统不支持<code>%zd</code>或<code>%zu</code>，可使用<code>%u</code>（<code>unsigned int</code>）或<code>%lu</code>（<code>unsigned long int</code>）代替。）</p>
<p><code>size_t</code>是一种数据类型，近似于无符号整型，但容量范围一般大于<code>int</code>和<code>unsigned</code>。这里使用<code>size_t</code>是为了保证<code>arraysize</code>变量能够有足够大的容量来储存可能大的数组。</p>
<p><code>size_t</code>类型在C语言标准库函数原型使用的很多，数值范围一般是要大于<code>int</code>和<code>unsigned</code>。但凡不涉及负值范围的表示<code>size</code>取值的，都可以用<code>size_t</code>；比如<code>array[size_t]</code></p>
<p>size_t 在stddef.h头文件中定义。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Definitions of common types 根据系统位数来或是对应的 64 位 int 还是 32 位的 int
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#000;font-weight:bold">__int64</span> <span style="color:#458;font-weight:bold">size_t</span>; <span style="color:#998;font-style:italic">// 会判断机器是否为64位，如果是：
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">__int64</span>          <span style="color:#458;font-weight:bold">ptrdiff_t</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">__int64</span>          <span style="color:#458;font-weight:bold">intptr_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else </span><span style="color:#998;font-style:italic">// 不是64位的机器
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span>     <span style="color:#458;font-weight:bold">size_t</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span>              <span style="color:#458;font-weight:bold">ptrdiff_t</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span>              <span style="color:#458;font-weight:bold">intptr_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>在其他常见的宏定义以及函数中常用到有：</p>
<ul>
<li><code>sizeof</code>运算符返回的结果是<code>size_t</code>类型；</li>
<li><code>void *malloc(size_t size)</code></li>
</ul>
<h2 id="函数">函数</h2>
<h3 id="简介">简介</h3>
<p>函数是一段可以重复执行的代码。它可以接受不同的参数，完成对应的操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">plus_one</span>(<span style="color:#458;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> n <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数声明的语法有以下几点，需要注意。</p>
<ul>
<li>返回值类型。函数声明时，首先需要给出返回值的类型，上例是<code>int</code>，表示函数<code>plus_one()</code>返回一个整数。</li>
<li>参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，<code>plus_one(int n)</code>表示这个函数有一个整数参数<code>n</code>。</li>
<li>函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行的写法。</li>
<li><code>return</code>语句。<code>return</code>语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略<code>return</code>语句，或者写成<code>return;</code>。</li>
</ul>
<p>调用函数时，只要在函数名后面加上圆括号就可以了，实际的参数放在圆括号里面</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">plus_one</span>(<span style="color:#099">13</span>);
</span></span></code></pre></div><p>函数必须声明后使用，否则会报错。也就是说，一定要在使用<code>plus_one()</code>之前，声明这个函数。</p>
<p>C 语言标准规定，函数只能声明在源码文件的顶层，不能声明在其他函数内部。</p>
<p>不返回值的函数，使用<code>void</code>关键字表示返回值的类型。没有参数的函数，声明时要用<code>void</code>关键字表示参数类型。</p>
<h3 id="main"><code>main()</code></h3>
<p>C 语言规定，<code>main()</code>是程序的入口函数，即所有的程序一定要包含一个<code>main()</code>函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过<code>main()</code>函数直接或间接引入程序的。</p>
<p><code>main()</code>的写法与其他函数一样，要给出返回值的类型和参数的类型</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello World</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>C 语言约定，返回值<code>0</code>表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据<code>main()</code>的返回值，作为整个程序的返回值，确定程序是否运行成功。正常情况下，如果<code>main()</code>里面省略<code>return 0</code>这一行，编译器会自动加上，即<code>main()</code>的默认返回值为0。</p>
<h3 id="参数的传值引用">参数的传值引用</h3>
<p>如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身，则在方法体中修改了传入的变量的值，在函数外部也不起作用（即在函数外部传入的参数的值和传入函数前相同）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">increment</span>(<span style="color:#458;font-weight:bold">int</span> a) {
</span></span><span style="display:flex;"><span>  a<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">increment</span>(i); <span style="color:#998;font-style:italic">// 传入函数的是i的拷贝，而不是i本身，拷贝的变化，影响不到原始变量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, i); <span style="color:#998;font-style:italic">// 调用increment(i)以后，变量i本身不会发生变化，还是等于10
</span></span></span></code></pre></div><p>如果想要传入变量本身，只有一个办法，就是传入变量的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">Swap</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> x, <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> temp;
</span></span><span style="display:flex;"><span>  temp <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>x;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>x <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>y;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>y <span style="color:#000;font-weight:bold">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">Swap</span>(<span style="color:#000;font-weight:bold">&amp;</span>a, <span style="color:#000;font-weight:bold">&amp;</span>b);
</span></span></code></pre></div><p>函数返回内部变量<code>i</code>的指针，这种写法是错的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量<code>i</code>的内存地址就是无效的，再去使用这个地址是非常危险的（程序返回的是局部变量的默认值）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">&amp;</span>i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="函数指针">函数指针</h3>
<p>函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数print()的地址可以用&amp;print获得
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>(<span style="color:#458;font-weight:bold">int</span> a) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, a);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 变量print_ptr是一个函数指针，它指向函数print()的地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>print_ptr)(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>print;
</span></span></code></pre></div><blockquote>
<p>注意，<code>(*print_ptr)</code>一定要写在圆括号里面，否则函数参数<code>(int)</code>的优先级高于<code>*</code>，整个式子就会变成<code>void* print_ptr(int)</code>。</p>
</blockquote>
<p>有了函数指针，通过它也可以调用函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">*</span>print_ptr)(<span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">print</span>(<span style="color:#099">10</span>);
</span></span></code></pre></div><p>C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，<code>print</code>和<code>&amp;print</code>是一回事。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (print <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">&amp;</span>print) <span style="color:#998;font-style:italic">// true
</span></span></span></code></pre></div><p>对于任意函数，都有五种调用函数的写法</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">print</span>(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">*</span>print)(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法三
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">&amp;</span>print)(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法四
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#000;font-weight:bold">*</span>print_ptr)(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法五
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">print_ptr</span>(<span style="color:#099">10</span>)
</span></span></code></pre></div><p>这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数compute()的第一个参数也是一个函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">compute</span>(<span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>myfunc)(<span style="color:#458;font-weight:bold">int</span>), <span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span></code></pre></div><h3 id="函数原型">函数原型</h3>
<p>函数必须先声明后使用。由于程序总是先运行<code>main()</code>函数，导致所有其他函数都必须在<code>main()</code>函数之前声明。</p>
<p><code>main()</code>是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。</p>
<p>C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">twice</span>(<span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> num) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#900;font-weight:bold">twice</span>(num);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">twice</span>(<span style="color:#458;font-weight:bold">int</span> num) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">2</span> <span style="color:#000;font-weight:bold">*</span> num;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>函数<code>twice()</code>的实现是放在<code>main()</code>后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。</p>
<blockquote>
<p>注意，函数原型必须以分号结尾。</p>
</blockquote>
<h3 id="exit"><code>exit()</code></h3>
<p><code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<p><code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：(这两个常数也是定义在<code>stdlib.h</code>里面)</p>
<ul>
<li><code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功;</li>
<li><code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 程序运行成功
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于 exit(0);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">exit</span>(EXIT_SUCCESS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 程序异常中止
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于 exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">exit</span>(EXIT_FAILURE);
</span></span></code></pre></div><p>在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句。其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其他作用。</p>
<p>C 语言还提供了一个<code>atexit()</code>函数，用来登记<code>exit()</code>执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// atexit的函數原型
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">atexit</span>(<span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>func)(<span style="color:#458;font-weight:bold">void</span>));
</span></span></code></pre></div><p><code>atexit()</code>的参数是一个函数指针。注意，它的参数函数不能接受参数，也不能有返回值。</p>
<p><code>exit()</code>执行时会先自动调用<code>atexit()</code>注册的<code>print()</code>函数，然后再终止程序。</p>
<h3 id="函数说明符">函数说明符</h3>
<h4 id="extern说明符"><code>extern</code>说明符</h4>
<blockquote>
<p>通过使用<code>extern</code>关键字声明变量名或函数名，而不定义变量或函数</p>
</blockquote>
<p>对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用<code>extern</code>说明该函数的定义来自其他文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">foo</span>(<span style="color:#458;font-weight:bold">int</span> arg1, <span style="color:#458;font-weight:bold">char</span> arg2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">foo</span>(<span style="color:#099">2</span>, <span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于函数原型默认就是<code>extern</code>，所以不加<code>extern</code>，效果是一样的。</p>
<h4 id="static说明符"><code>static</code>说明符</h4>
<p>默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code>说明符可以改变这种行为。</p>
<p><strong><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次</strong>，不需要在每次调用时都进行初始化。也就是说，它的<strong>值在两次调用之间保持不变</strong>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">counter</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;  <span style="color:#998;font-style:italic">// 只初始化一次
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, count);
</span></span><span style="display:flex;"><span>  count<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">counter</span>();  <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">counter</span>();  <span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">counter</span>();  <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">counter</span>();  <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>注意，<code>static</code>修饰的变量初始化时，只能赋值为常量，不能赋值为变量。在块作用域中，<code>static</code>声明的变量有默认值<code>0</code>。（可以先声明，后赋值）</p>
<p><code>static</code>可以用来修饰函数本身。<strong><code>static</code>关键字表修饰的函数表示只能在当前文件里使用</strong>，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Twice</span>(<span style="color:#458;font-weight:bold">int</span> num) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> result <span style="color:#000;font-weight:bold">=</span> num <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span>(result);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>static</code>也可以用在参数里面，修饰参数数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> a[<span style="color:#000;font-weight:bold">static</span> <span style="color:#099">3</span>], <span style="color:#458;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>static</code>对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，<code>static</code>仅可用于第一维的说明。</p>
<h4 id="const说明符"><code>const</code>说明符</h4>
<p>使用<code>const</code>前缀声明指定类型的常量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#a61717;background-color:#e3d2d2">数据类型</span> <span style="color:#a61717;background-color:#e3d2d2">常量名</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#a61717;background-color:#e3d2d2">常量值</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 在程序中使用该常量时，其值将始终为100，并且不能被修改。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> MAX_VALUE <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100</span>;
</span></span></code></pre></div><p><img src="./images/202309231127442.png" alt="img"></p>
<p><img src="./images/202309231128483.png" alt="img"></p>
<p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。</li>
<li>使用 <strong>const</strong> 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。</li>
</ol>
<h5 id="define预处理器"><code>#define</code>预处理器</h5>
<p>使用 #define 预处理器定义常量的形式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define 常量名 常量值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 在程序中使用该常量时，编译器会将所有的 PI 替换为 3.14159。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#define PI 3.14159
</span></span></span></code></pre></div><p>所谓的预处理其实就是在编译前将源代码中相应的字符串单词替换成定义的另一个字符串单词。</p>
<h5 id="define与const区别"><code>#define</code>与<code>const</code>区别</h5>
<p><code>#define</code>与<code>const</code>这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用<code>const</code>关键字来定义常量，因为它具有类型检查和作用域的优势，而<code>#define</code>仅进行简单的文本替换，可能会导致一些意外的问题。</p>
<p><code>#define</code>预处理指令和<code>const</code>关键字在定义常量时有一些区别：</p>
<ul>
<li>替换机制：<code>#define</code>是进行简单的文本替换，而<code>const</code>是声明一个具有类型的常量。<code>#define</code>定义的常量在编译时会被直接替换为其对应的值，而<code>const</code>定义的常量在程序运行时会分配内存，并且具有类型信息。</li>
<li>类型检查：<code>#define</code>不进行类型检查，因为它只是进行简单的文本替换。而<code>const</code>定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。</li>
<li>作用域：<code>#define</code>定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 <code>const</code> 定义的常量具有块级作用域，只在其定义所在的作用域内有效。</li>
<li>调试和符号表：使用<code>#define</code>定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用<code>const</code>定义的常量会在符号表中有相应的条目，有助于调试和可读性。</li>
</ul>
<blockquote>
<p><code>#define</code>是宏定义，不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于<code>#define</code>不为宏名分配内存，而<code>const</code>也不为常量分配内存。其实<code>const</code>并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！</p>
</blockquote>
<p><code>#define</code>是预编译指令，<code>const</code>是普通变量的定义，<code>#define</code>定义的宏是在<strong>预处理阶段</strong>展开的，而<code>const</code>定义的只读变量是在<strong>编译运行阶段</strong>使用的。</p>
<p><code>const</code>定义的是变量，而<code>#define</code>定义的是常量。<code>#define</code>定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但<code>const</code>定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，用<code>const</code>定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用<code>const</code>和<code>#define</code>都可以的情况下尽量使用常变量来取代宏。</p>
<p><code>const</code>定义的是变量，而宏定义的是常量，所以<code>const</code>定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。</p>
<blockquote>
<p><code>#define</code>注意“边缘效应”：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define N 2+3
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> a;
</span></span><span style="display:flex;"><span>a <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">float</span>)N<span style="color:#000;font-weight:bold">/</span>(<span style="color:#458;font-weight:bold">float</span>)<span style="color:#099">2</span>;
</span></span></code></pre></div><p>在编译时预想<code>a=2.5</code>，实际打印结果是<code>3.5</code>。原因是在预处理阶段，编译器将<code>a=N/2</code>处理成<code>a=2+3/2</code>，这就是<code>#define</code>宏的边缘效应</p>
</blockquote>
<p><code>const</code>定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象<code>#define</code>一样给出的是立即数，所以，<code>const</code>定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而<code>#define</code>定义的常量在内存中有若干个拷贝。编译器通常不为普通<code>const</code>常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p>
<p>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，函数<code>f()</code>的参数是一个指针<code>p</code>，函数内部可能会改掉它所指向的值<code>*p</code>，从而影响到函数外部。</p>
<p>为了避免这种情况，可以在声明函数时，在指针参数前面加上<code>const</code>说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; <span style="color:#998;font-style:italic">// 该行报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，声明函数时，<code>const</code>指定不能修改指针<code>p</code>指向的值，所以<code>*p = 0</code>就会报错。但是这种写法，只限制修改<code>p</code>所指向的值，而<code>p</code>本身的地址是可以修改的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span><span style="display:flex;"><span>  p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x; <span style="color:#998;font-style:italic">// 允许修改
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，<code>p</code>本身是可以修改，<code>const</code>只限定<code>*p</code>不能修改。如果想限制修改<code>p</code>，可以把<code>const</code>放在<code>p</code>前面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">const</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span><span style="display:flex;"><span>  p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x; <span style="color:#998;font-style:italic">// 该行报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>如果想同时限制修改<code>p</code>和<code>*p</code>，需要使用两个<code>const</code>。变量<code>p</code>的地址和其指向的值都不能改变</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">const</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><h3 id="可变参数">可变参数</h3>
<p>有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号<code>...</code>表示可变数量的参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> format, ...);
</span></span></code></pre></div><p>示例是<code>printf()</code>函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这时，就可以用<code>...</code>表示可变数量的参数。</p>
<p>注意，<code>...</code>符号必须放在参数序列的结尾，否则会报错。</p>
<p>头文件<code>stdarg.h</code>定义了一些宏，可以操作可变参数：</p>
<ul>
<li><code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</li>
<li><code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</li>
<li><code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</li>
<li><code>va_end</code>：一个函数，用来清理可变参数对象。</li>
</ul>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">double</span> <span style="color:#900;font-weight:bold">average</span>(<span style="color:#458;font-weight:bold">int</span> i, ...) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span> total <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  va_list ap;
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">va_start</span>(ap, i);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> j <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; j <span style="color:#000;font-weight:bold">&lt;=</span> i; <span style="color:#000;font-weight:bold">++</span>j) {
</span></span><span style="display:flex;"><span>    total <span style="color:#000;font-weight:bold">+=</span> <span style="color:#900;font-weight:bold">va_arg</span>(ap, <span style="color:#458;font-weight:bold">double</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">va_end</span>(ap);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> total <span style="color:#000;font-weight:bold">/</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>va_list ap</code>定义<code>ap</code>为可变参数对象，<code>va_start(ap, i)</code>将参数<code>i</code>后面的参数统一放入<code>ap</code>，<code>va_arg(ap, double)</code>用来从<code>ap</code>依次取出一个参数，并且指定该参数为<code>double</code>类型，<code>va_end(ap)</code>用来清理可变参数对象。</p>
<h2 id="数组">数组</h2>
<h3 id="简介-1">简介</h3>
<p>数组是一组<strong>相同类型</strong>的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> scores[<span style="color:#099">100</span>]; <span style="color:#998;font-style:italic">// 声明了一个数组scores，里面包含100个成员，每个成员都是int类型
</span></span></span></code></pre></div><p>注意，声明数组时，必须给出数组的大小。</p>
<p>数组的成员从<code>0</code>开始编号，所以数组<code>scores[100]</code>就是从第<code>0</code>号成员一直到第<code>99</code>号成员，最后一个成员的编号会比数组长度小<code>1</code>。</p>
<p>数组名后面使用方括号指定编号，就可以引用该成员。也可以通过该方式，对该位置进行赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>scores[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span><span style="display:flex;"><span>scores[<span style="color:#099">99</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">42</span>;
</span></span></code></pre></div><p>注意，如果引用不存在的数组成员（即越界访问数组），并不会报错，所以必须非常小心。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> scores[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>scores[<span style="color:#099">100</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">51</span>;
</span></span></code></pre></div><p>上面示例中，数组<code>scores</code>只有100个成员，因此<code>scores[100]</code>这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在<code>scores</code>后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。这很容易引发错误，而且难以发现。</p>
<p>数组也可以在声明时，使用大括号，同时对每一个成员赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>, <span style="color:#099">18</span>, <span style="color:#099">95</span>};
</span></span></code></pre></div><p>注意，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span>a <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>, <span style="color:#099">18</span>, <span style="color:#099">95</span>}; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址。由于同样的原因，数组赋值之后，再用大括号修改值，也是不允许的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>a <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>, <span style="color:#099">18</span>, <span style="color:#099">95</span>}; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面代码中，数组<code>a</code>赋值后，再用大括号重新赋值也是不允许的。</p>
<p>使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。</p>
<p>如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为<code>0</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>};
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>};
</span></span></code></pre></div><p>如果要将整个数组的每一个成员都设置为零，最简单的写法就是下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">100</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>};
</span></span></code></pre></div><p>数组初始化时，可以指定为哪些位置的成员赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">15</span>] <span style="color:#000;font-weight:bold">=</span> {[<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">29</span>, [<span style="color:#099">9</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>, [<span style="color:#099">14</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">48</span>};
</span></span></code></pre></div><p>上面示例中，数组的2号、9号、14号位置被赋值，其他位置的值都自动设为0。</p>
<p>指定位置的赋值可以不按照顺序，下面的写法与上面的例子是等价的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">15</span>] <span style="color:#000;font-weight:bold">=</span> {[<span style="color:#099">9</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>, [<span style="color:#099">14</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">48</span>, [<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">29</span>};
</span></span></code></pre></div><p>指定位置的赋值与顺序赋值，可以结合使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">15</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, [<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>, <span style="color:#099">11</span>, [<span style="color:#099">10</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">20</span>, <span style="color:#099">21</span>}
</span></span></code></pre></div><p>上面示例中，0号、5号、6号、10号、11号被赋值。</p>
<p>C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>};
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">3</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>};
</span></span></code></pre></div><p>上面示例中，数组<code>a</code>的长度，将根据大括号里面的值的数量，确定为<code>3</code>。</p>
<p>省略成员数量时，如果同时采用指定位置的赋值，那么数组长度将是最大的指定位置再加1。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {[<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">6</span>, [<span style="color:#099">9</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">12</span>};
</span></span></code></pre></div><p>上面示例中，数组<code>a</code>的最大指定位置是<code>9</code>，所以数组的长度是10。</p>
<h3 id="数组长度">数组长度</h3>
<p><code>sizeof</code>运算符会返回整个数组的字节长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">22</span>, <span style="color:#099">37</span>, <span style="color:#099">3490</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arrLen <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">sizeof</span>(a); <span style="color:#998;font-style:italic">// 12
</span></span></span></code></pre></div><p>上面示例中，<code>sizeof</code>返回数组<code>a</code>的字节长度是<code>12</code>。</p>
<p>由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组成员的字节长度，就可以得到数组的成员数量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">sizeof</span>(a) <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">sizeof</span>(a[<span style="color:#099">0</span>])
</span></span></code></pre></div><p>上面示例中，<code>sizeof(a)</code>是整个数组的字节长度，<code>sizeof(a[0])</code>是数组成员的字节长度，相除就是数组的成员数量。</p>
<p>注意，<code>sizeof</code>返回值的数据类型是<code>size_t</code>，所以<code>sizeof(a) / sizeof(a[0])</code>的数据类型也是<code>size_t</code>。在<code>printf()</code>里面的占位符，要用<code>%zd</code>或<code>%zu</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x[<span style="color:#099">12</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%zu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(x));     <span style="color:#998;font-style:italic">// 48
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%zu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));  <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%zu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(x) <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>)); <span style="color:#998;font-style:italic">// 12
</span></span></span></code></pre></div><p>上面示例中，<code>sizeof(x) / sizeof(int)</code>就可以得到数组成员数量<code>12</code>。</p>
<h3 id="多维数组">多维数组</h3>
<p>C 语言允许声明多个维度的数组，有多少个维度，就用多少个方括号，比如二维数组就使用两个方括号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> board[<span style="color:#099">10</span>][<span style="color:#099">10</span>];
</span></span></code></pre></div><p>上面示例声明了一个二维数组，第一个维度有10个成员，第二个维度也有10个成员。</p>
<p>多维数组可以理解成，上层维度的每个成员本身就是一个数组。比如上例中，第一个维度的每个成员本身就是一个有10个成员的数组，因此整个二维数组共有100个成员（10 x 10 = 100）。</p>
<p>三维数组就使用三个方括号声明，以此类推。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> c[<span style="color:#099">4</span>][<span style="color:#099">5</span>][<span style="color:#099">6</span>];
</span></span></code></pre></div><p>引用二维数组的每个成员时，需要使用两个方括号，同时指定两个维度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>board[<span style="color:#099">0</span>][<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span><span style="display:flex;"><span>board[<span style="color:#099">9</span>][<span style="color:#099">9</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span></code></pre></div><p>注意，<code>board[0][0]</code>不能写成<code>board[0, 0]</code>，因为<code>0, 0</code>是一个逗号表达式，返回第二个值，所以<code>board[0, 0]</code>等同于<code>board[0]</code>。</p>
<p>跟一维数组一样，多维数组每个维度的第一个成员也是从<code>0</code>开始编号。</p>
<p>多维数组也可以使用大括号，一次性对所有成员赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  {<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>},
</span></span><span style="display:flex;"><span>  {<span style="color:#099">5</span>, <span style="color:#099">6</span>, <span style="color:#099">7</span>, <span style="color:#099">8</span>, <span style="color:#099">9</span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，<code>a</code>是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。这种写法不用为每个成员都赋值，缺少的成员会自动设置为<code>0</code>。</p>
<p>多维数组也可以指定位置，进行初始化赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> {[<span style="color:#099">0</span>][<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>, [<span style="color:#099">1</span>][<span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>};
</span></span></code></pre></div><p>上面示例中，指定了<code>[0][0]</code>和<code>[1][1]</code>位置的值，其他位置就自动设为<code>0</code>。</p>
<p>不管数组有多少维度，在内存里面都是线性存储，<code>a[0][0]</code>的后面是<code>a[0][1]</code>，<code>a[0][1]</code>的后面是<code>a[1][0]</code>，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句与上面的赋值语句是完全等同的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">2</span>};
</span></span></code></pre></div><h3 id="变长数组">变长数组</h3>
<p>数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> n <span style="color:#000;font-weight:bold">=</span> x <span style="color:#000;font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arr[n];
</span></span></code></pre></div><p>上面示例中，数组<code>arr</code>就是变长数组，因为它的长度取决于变量<code>n</code>的值，编译器没法事先确定，只有运行时才能知道<code>n</code>是多少。</p>
<p>变长数组的根本特征，就是数组长度只有运行时才能确定。它的好处是程序员不必在开发时，随意为数组指定一个估计的长度，程序可以在运行时为数组分配精确的长度。</p>
<p>任何长度需要运行时才能确定的数组，都是变长数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a1[i];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a2[i <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a3[i <span style="color:#000;font-weight:bold">+</span> k];
</span></span></code></pre></div><p>上面示例中，三个数组的长度都需要运行代码才能知道，编译器并不知道它们的长度，所以它们都是变长数组。</p>
<p>变长数组也可以用于多维数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> m <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> n <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> c[m][n];
</span></span></code></pre></div><h3 id="数组的地址">数组的地址</h3>
<p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>p);  <span style="color:#998;font-style:italic">// Prints &#34;11&#34;
</span></span></span></code></pre></div><p>上面示例中，<code>&amp;a[0]</code>就是数组<code>a</code>的首个成员<code>11</code>的内存地址，也是整个数组的起始地址。反过来，从这个地址（<code>*p</code>），可以获得首个成员的值<code>11</code>。</p>
<p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> a;
</span></span></code></pre></div><p>如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p>
<p>函数接受数组作为参数，函数原型可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#458;font-weight:bold">int</span> arr[], <span style="color:#458;font-weight:bold">int</span> len);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> arr, <span style="color:#458;font-weight:bold">int</span> len);
</span></span></code></pre></div><p>上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号<code>[]</code>与指针符号<code>*</code>是可以互换的。下一个例子是通过数组指针对成员求和。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> arr, <span style="color:#458;font-weight:bold">int</span> len) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> total <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 假定数组有 10 个成员
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> len; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    total <span style="color:#000;font-weight:bold">+=</span> arr[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，传入函数的是一个指针<code>arr</code>（也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。</p>
<p><code>*</code>和<code>&amp;</code>运算符也可以用于多维数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">4</span>][<span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 取出 a[0][0] 的值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>(a[<span style="color:#099">0</span>]);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">**</span>a
</span></span></code></pre></div><p>上面示例中，由于<code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员<code>a[0][0]</code>。所以，<code>*(a[0])</code>取出的是<code>a[0][0]</code>的值。至于<code>**a</code>，就是对<code>a</code>进行两次<code>*</code>运算，第一次取出的是<code>a[0]</code>，第二次取出的是<code>a[0][0]</code>。同理，二维数组的<code>&amp;a[0][0]</code>等同于<code>*a</code>。</p>
<p>注意，数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> ints[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>ints <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>示例中，重新为数组名赋值，改变原来的内存地址，就会报错。也导致不能将一个数组名赋值给另外一个数组名</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> b[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> a; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> b[<span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> a; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面两种写法都会更改数组<code>b</code>的地址，导致报错。</p>
<h4 id="数组指针的加减法">数组指针的加减法</h4>
<p>C 语言里面，数组名可以进行加法和减法运算，等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。比如，<code>a + 1</code>返回下一个成员的地址，<code>a - 1</code>返回上一个成员的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">5</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>(a <span style="color:#000;font-weight:bold">+</span> i));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，通过指针的移动遍历数组，<code>a + i</code>的每轮循环每次都会指向下一个成员的地址，<code>*(a + i)</code>取出该地址的值，等同于<code>a[i]</code>。对于数组的第一个成员，<code>*(a + 0)</code>（即<code>*a</code>）等同于<code>a[0]</code>。</p>
<p>由于数组名与指针是等价的，所以下面的等式总是成立。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>a[b] <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">*</span>(a <span style="color:#000;font-weight:bold">+</span> b)
</span></span></code></pre></div><p>上面代码给出了数组成员的两种访问方式，一种是使用方括号<code>a[b]</code>，另一种是使用指针<code>*(a + b)</code>。</p>
<p>如果指针变量<code>p</code>指向数组的一个成员，那么<code>p++</code>就相当于指向下一个成员，这种方法常用来遍历数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>, <span style="color:#099">999</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> (<span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">999</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>p);
</span></span><span style="display:flex;"><span>  p<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，通过<code>p++</code>让变量<code>p</code>指向下一个成员。</p>
<p>注意，数组名指向的地址是不能变的，所以上例中，不能直接对<code>a</code>进行自增，即<code>a++</code>的写法是错的，必须将<code>a</code>的地址赋值给指针变量<code>p</code>，然后对<code>p</code>进行自增。</p>
<p>遍历数组一般都是通过数组长度的比较来实现，但也可以通过数组起始地址和结束地址的比较来实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> start, <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> end) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> total <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">while</span> (start <span style="color:#000;font-weight:bold">&lt;</span> end) {
</span></span><span style="display:flex;"><span>    total <span style="color:#000;font-weight:bold">+=</span> <span style="color:#000;font-weight:bold">*</span>start;
</span></span><span style="display:flex;"><span>    start<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> total;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">20</span>, <span style="color:#099">10</span>, <span style="color:#099">5</span>, <span style="color:#099">39</span>, <span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%i</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">sum</span>(arr, arr <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">5</span>));
</span></span></code></pre></div><p>上面示例中，<code>arr</code>是数组的起始地址，<code>arr + 5</code>是结束地址。只要起始地址小于结束地址，就表示还没有到达数组尾部。反过来，通过数组的减法，可以知道两个地址之间有多少个数组成员，请看下面的例子，自己实现一个计算数组长度的函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">20</span>, <span style="color:#099">10</span>, <span style="color:#099">5</span>, <span style="color:#099">39</span>, <span style="color:#099">88</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> arr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> (<span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">88</span>)
</span></span><span style="display:flex;"><span>  p<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%i</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, p <span style="color:#000;font-weight:bold">-</span> arr); <span style="color:#998;font-style:italic">// 4
</span></span></span></code></pre></div><p>上面示例中，将某个数组成员的地址，减去数组起始地址，就可以知道，当前成员与起始地址之间有多少个成员。</p>
<p>对于多维数组，数组指针的加减法对于不同维度，含义是不一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">4</span>][<span style="color:#099">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 指针指向 arr[1]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>arr <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 指针指向 arr[0][1]
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>arr[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>
</span></span></code></pre></div><p>上面示例中，<code>arr</code>是一个二维数组，<code>arr + 1</code>是将指针移动到第一维数组的下一个成员，即<code>arr[1]</code>。由于每个第一维的成员，本身都包含另一个数组，即<code>arr[0]</code>是一个指向第二维数组的指针，所以<code>arr[0] + 1</code>的含义是将指针移动到第二维数组的下一个成员，即<code>arr[0][1]</code>。</p>
<p>同一个数组的两个成员的指针相减时，返回它们之间的距离。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> q <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, p <span style="color:#000;font-weight:bold">-</span> q); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, q <span style="color:#000;font-weight:bold">-</span> p); <span style="color:#998;font-style:italic">// -4
</span></span></span></code></pre></div><p>上面示例中，变量<code>p</code>和<code>q</code>分别是数组5号位置和1号位置的指针，它们相减等于4或-4。</p>
<h3 id="数组的复制">数组的复制</h3>
<p>由于数组名是指针，所以复制数组不能简单地复制数组名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> a;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> b[<span style="color:#099">3</span>] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#000;font-weight:bold">=</span> b; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面的写法，结果不是将数组<code>b</code>复制给数组<code>a</code>，而是让<code>a</code>和<code>b</code>指向同一个数组。</p>
<p>复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> N; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>  a[i] <span style="color:#000;font-weight:bold">=</span> b[i];
</span></span></code></pre></div><p>上面示例中，通过将数组<code>b</code>的成员逐个复制给数组<code>a</code>，从而实现数组的赋值。</p>
<p>另一种方法是使用<code>memcpy()</code>函数（定义在头文件<code>string.h</code>），直接把数组所在的那一段内存，再复制一份。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">memcpy</span>(a, b, <span style="color:#000;font-weight:bold">sizeof</span>(b));
</span></span></code></pre></div><p>上面示例中，将数组<code>b</code>所在的那段内存，复制给数组<code>a</code>。这种方法要比循环复制数组成员要快。</p>
<h3 id="作为函数的参数">作为函数的参数</h3>
<h4 id="声明参数数组">声明参数数组</h4>
<p>数组作为函数的参数，一般会同时传入数组名和数组长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> a[], <span style="color:#458;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sum_array</span>(a, <span style="color:#099">4</span>);
</span></span></code></pre></div><p>上面示例中，函数<code>sum_array()</code>的第一个参数是数组本身，也就是数组名，第二个参数是数组长度。</p>
<p>由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。</p>
<p>如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> a[][<span style="color:#099">4</span>], <span style="color:#458;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">2</span>][<span style="color:#099">4</span>] <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>},
</span></span><span style="display:flex;"><span>  {<span style="color:#099">8</span>, <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sum_array</span>(a, <span style="color:#099">2</span>);
</span></span></code></pre></div><p>上面示例中，函数<code>sum_array()</code>的参数是一个二维数组。第一个参数是数组本身（<code>a[][4]</code>），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度<code>4</code>。</p>
<p>这是因为函数内部拿到的，只是数组的起始地址<code>a</code>，以及第一维的成员数量<code>2</code>。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成<code>int a[][4]</code>，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是<code>4 * sizeof(int)</code>。</p>
<h4 id="变长数组作为参数">变长数组作为参数</h4>
<p>变长数组作为函数参数时，写法略有不同。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> n, <span style="color:#458;font-weight:bold">int</span> a[n]) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">3</span>, <span style="color:#099">5</span>, <span style="color:#099">7</span>, <span style="color:#099">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#099">4</span>, a);
</span></span></code></pre></div><p>上面示例中，数组<code>a[n]</code>是一个变长数组，它的长度取决于变量<code>n</code>的值，只有运行时才能知道。所以，变量<code>n</code>作为参数时，顺序一定要在变长数组前面，这样运行时才能确定数组<code>a[n]</code>的长度，否则就会报错。</p>
<p>因为函数原型可以省略参数名，所以变长数组的原型中，可以使用<code>*</code>代替变量名，也可以省略变量名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span> [<span style="color:#000;font-weight:bold">*</span>]);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span> []);
</span></span></code></pre></div><p>上面两种变长函数的原型写法，都是合法的。</p>
<p>变长数组作为函数参数有一个好处，就是多维数组的参数声明，可以把后面的维度省掉了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 原来的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> a[][<span style="color:#099">4</span>], <span style="color:#458;font-weight:bold">int</span> n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 变长数组的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum_array</span>(<span style="color:#458;font-weight:bold">int</span> n, <span style="color:#458;font-weight:bold">int</span> m, <span style="color:#458;font-weight:bold">int</span> a[n][m]);
</span></span></code></pre></div><p>上面示例中，函数<code>sum_array()</code>的参数是一个多维数组，按照原来的写法，一定要声明第二维的长度。但是使用变长数组的写法，就不用声明第二维长度了，因为它可以作为参数传入函数。</p>
<h4 id="数组字面量作为参数">数组字面量作为参数</h4>
<p>C 语言允许将数组字面量作为参数，传入函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 数组变量作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sum_array</span>(a, <span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 数组字面量作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sum_array</span>((<span style="color:#458;font-weight:bold">int</span> []){<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}, <span style="color:#099">4</span>);
</span></span></code></pre></div><p>上面示例中，两种写法是等价的。第二种写法省掉了数组变量的声明，直接将数组字面量传入函数。<code>{2, 3, 4, 5}</code>是数组值的字面量，<code>(int [])</code>类似于强制的类型转换，告诉编译器怎么理解这组值。</p>
<h3 id="静态数组与动态数组">静态数组与动态数组</h3>
<p>在 C 语言中，有两种类型的数组：</p>
<ul>
<li>静态数组：编译时分配内存，大小固定。</li>
<li>动态数组：运行时手动分配内存，大小可变。</li>
</ul>
<p>静态数组的生命周期与作用域相关，而动态数组的生命周期由程序员控制。</p>
<p>在使用动态数组时，需要注意合理地分配和释放内存，以避免内存泄漏和访问无效内存的问题。</p>
<h4 id="静态数组">静态数组</h4>
<p>静态数组是在编译时声明并分配内存空间的数组。</p>
<p>静态数组具有固定的大小，在声明数组时需要指定数组的长度。</p>
<p>静态数组的特点包括：</p>
<ul>
<li>内存分配：在程序编译时，静态数组的内存空间就被分配好了，存储在栈上或者全局数据区。</li>
<li>大小固定：静态数组的大小在声明时确定，并且无法在运行时改变。</li>
<li>生命周期：静态数组的生命周期与其作用域相关。如果在函数内部声明静态数组，其生命周期为整个函数执行期间；如果在函数外部声明静态数组，其生命周期为整个程序的执行期间。</li>
</ul>
<p>静态数组的声明和初始化示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> staticArray[<span style="color:#099">5</span>]; <span style="color:#998;font-style:italic">// 静态数组声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> staticArray[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}; <span style="color:#998;font-style:italic">// 静态数组声明并初始化
</span></span></span></code></pre></div><p>对于静态数组，可以使用<code>sizeof</code>运算符来获取数组长度，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> length <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">sizeof</span>(array) <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">sizeof</span>(array[<span style="color:#099">0</span>]);
</span></span></code></pre></div><p>以上代码中<code>sizeof(array)</code>返回整个数组所占用的字节数，而<code>sizeof(array[0])</code>返回数组中单个元素的字节数，将两者相除，就得到了数组的长度。</p>
<h5 id="实例">实例</h5>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> staticArray[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>}; <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">静态数组声明并初始化</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> length <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">sizeof</span>(staticArray) <span style="color:#000;font-weight:bold">/</span> <span style="color:#000;font-weight:bold">sizeof</span>(staticArray[<span style="color:#099">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;静态数组: &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> length; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>, staticArray[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;**</span><span style="color:#d14">\n</span><span style="color:#d14">**&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上实例中，声明并初始化了一个静态数组<code>staticArray</code>，它包含了 5 个整数元素，然后我们通过<code>sizeof</code>运算符，我们计算了静态数组的长度，并使用循环遍历并打印数组的元素。</p>
<p>输出结果：</p>
<pre tabindex="0"><code>静态数组: 1 2 3 4 5
</code></pre><h4 id="动态数组">动态数组</h4>
<p>动态数组是在运行时通过动态内存分配函数（如<code>malloc</code>和<code>calloc</code>）手动分配内存的数组。</p>
<p>动态数组特点如下：</p>
<ul>
<li>内存分配：动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 <code>malloc</code>、<code>calloc</code> 等函数来申请内存，并使用 <code>free</code> 函数来释放内存。</li>
<li>大小可变：动态数组的大小在运行时可以根据需要进行调整。可以使用 <code>realloc</code> 函数来重新分配内存，并改变数组的大小。</li>
<li>生命周期：动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。</li>
</ul>
<p>动态数组的声明、内存分配和释放实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> size <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>dynamicArray <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">malloc</span>(size <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>)); <span style="color:#998;font-style:italic">// 动态数组内存分配
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 使用动态数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">free</span>(dynamicArray); <span style="color:#998;font-style:italic">// 动态数组内存释放
</span></span></span></code></pre></div><p>动态分配的数组，可以在动态分配内存时保存数组长度，并在需要时使用该长度，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> size <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>; <span style="color:#998;font-style:italic">// 数组长度
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>array <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(size <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 使用数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">free</span>(array); <span style="color:#998;font-style:italic">// 释放内存
</span></span></span></code></pre></div><p>以上代码使用<code>malloc</code>函数动态分配了一个整型数组，并将长度保存在变量<code>size</code>中。然后可以根据需要使用这个长度进行操作，在使用完数组后，使用<code>free</code>函数释放内存。</p>
<blockquote>
<p>**注意：**动态数组的使用需要注意内存管理的问题，确保在不再需要使用数组时释放内存，避免内存泄漏和访问无效的内存位置。</p>
</blockquote>
<p>以上是一个简单的动态数组使用实例：</p>
<h5 id="实例-1">实例</h5>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> size <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>dynamicArray <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">malloc</span>(size <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>)); <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">动态数组内存分配</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (dynamicArray <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Memory allocation failed.**</span><span style="color:#d14">\n</span><span style="color:#d14">**&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Enter %d elements: &#34;</span>, size);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> size; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>dynamicArray[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Dynamic Array: &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> size; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>, dynamicArray[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;**</span><span style="color:#d14">\n</span><span style="color:#d14">**&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">free</span>(dynamicArray); <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> <span style="color:#a61717;background-color:#e3d2d2">动态数组内存释放</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实例中，首先声明了一个变量<code>size</code>来指定动态数组的大小；然后使用<code>malloc</code>函数为动态数组分配内存，并通过<code>sizeof</code>运算符计算所需的内存大小；接下来，通过循环和<code>scanf</code>函数，从用户输入中读取元素值并存储到动态数组中；最后，使用循环遍历并打印动态数组的元素。在程序结束时，使用<code>free</code>函数释放动态数组所占用的内存</p>
<p>请注意，在使用动态数组时，需要检查内存分配是否成功（即<code>dynamicArray</code>是否为<code>NULL</code>），以避免在内存分配失败时发生错误。</p>
<h2 id="指针">指针</h2>
<p>每个变量都有一个内存位置，每个内存位置都定义了可使用<code>&amp;</code>运算符访问的地址，它表示了在内存中的一个地址</p>
<h3 id="简介-2">简介</h3>
<p>指针是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。</p>
<p><img src="./images/202309221515818.png" alt="img"></p>
<p>字符<code>*</code>表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，<code>char*</code>表示一个指向字符的指针，<code>float*</code>表示一个指向<code>float</code>类型的值的指针</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 是一个指针，指向的内存地址存放的是一个整数。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> intPtr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 声明两个指针变量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span> foo, <span style="color:#000;font-weight:bold">*</span> bar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// foo是整数指针变量，而bar是整数变量，即*只对第一个变量生效。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> foo, bar;
</span></span></code></pre></div><h3 id="运算符-1"><code>*</code>运算符</h3>
<p><code>*</code>符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数increment()的参数是一个整数指针p。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数体里面，*p就表示指针p所指向的那个值。对*p赋值，就表示改变指针所指向的那个地址里面的值。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 函数没有返回值,传入的是地址,函数体内部对该地址指向的值的操作,会影响到函数外部
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">increment</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>变量地址而不是变量值传入函数，还有一个好处：对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针来得高效。</p>
</blockquote>
<h3 id="运算符-2"><code>&amp;</code>运算符</h3>
<p><code>&amp;</code>运算符用来取出一个变量所在的内存地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// x是一个整数变量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// &amp;x就是x的值所在的内存地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// %p是内存地址的占位符
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;x&#39;s address is %p</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>x);
</span></span></code></pre></div><p><code>&amp;</code>运算符与<code>*</code>运算符互为逆运算</p>
<h3 id="指针变量的初始化">指针变量的初始化</h3>
<p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p>
<p>正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// p是指针变量，声明这个变量后，p会指向一个随机的内存地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 声明一个整数变量i，编译器会为i分配内存地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>i;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">13</span>;
</span></span></code></pre></div><p>为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为<code>NULL</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span></code></pre></div><p><code>NULL</code>在 C 语言中是一个常量，表示地址为<code>0</code>的内存空间，这个地址是无法使用的，读写该地址会报错。</p>
<h3 id="指针的运算">指针的运算</h3>
<p>指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的规则。</p>
<ul>
<li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li>
<li>指针的每一次递减，它都会指向前一个元素的存储单元。</li>
<li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li>
</ul>
<p><strong>（1）指针与整数值的加减运算</strong></p>
<p>指针与整数值的运算，表示指针的移动。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span> j;
</span></span><span style="display:flex;"><span>j <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#099">0x1234</span>; <span style="color:#998;font-style:italic">// j是一个指针，指向内存地址0x1234
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>j <span style="color:#000;font-weight:bold">=</span> j <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// 0x1236
</span></span></span></code></pre></div><p>由于<code>0x1234</code>本身是整数类型（<code>int</code>），跟<code>j</code>的类型（<code>short*</code>）并不兼容，所以强制使用类型投射，将<code>0x1234</code>转成<code>short*</code>。你可能以为<code>j + 1</code>等于<code>0x1235</code>，但正确答案是<code>0x1236</code>。原因是<code>j + 1</code>表示指针向内存地址的高位移动一个单位，而一个单位的<code>short</code>类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，<code>j - 1</code>得到的结果是<code>0x1232</code>。</p>
<blockquote>
<p>指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节</p>
</blockquote>
<p><strong>（2）指针与指针的加法运算</strong></p>
<p>指针只能与整数值进行加减运算，两个指针进行加法是非法的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span> j;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span> k;
</span></span><span style="display:flex;"><span>x <span style="color:#000;font-weight:bold">=</span> j <span style="color:#000;font-weight:bold">+</span> k; <span style="color:#998;font-style:italic">// 非法
</span></span></span></code></pre></div><p><strong>（3）指针与指针的减法</strong></p>
<p>相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。</p>
<p>高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。</p>
<p>这时，减法返回的值属于<code>ptrdiff_t</code>类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件<code>stddef.h</code>里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span> j1; <span style="color:#998;font-style:italic">// j1和j2是两个指向 short 类型的指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span> j2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>j1 <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#099">0x1234</span>;
</span></span><span style="display:flex;"><span>j2 <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">short</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#099">0x1236</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">ptrdiff_t</span> dist <span style="color:#000;font-weight:bold">=</span> j2 <span style="color:#000;font-weight:bold">-</span> j1; <span style="color:#998;font-style:italic">// 变量dist是它们之间的距离，类型为ptrdiff_t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%td</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, dist); <span style="color:#998;font-style:italic">// 值为1，因为相差2个字节正好存放一个 short 类型的值
</span></span></span></code></pre></div><p><strong>（4）指针与指针的比较运算</strong></p>
<p>指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数<code>1</code>（true）或<code>0</code>（false）。</p>
<h3 id="指针数组">指针数组</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> MAX <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span> (){
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span>  var[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">10</span>, <span style="color:#099">100</span>, <span style="color:#099">200</span>};
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> MAX; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Value of var[%d] = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, i, var[i] );
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>想要让数组存储指向<code>int</code>、<code>char</code>或其他数据类型的指针</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 把ptr声明为一个数组，由MAX个整数指针组成。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 因此，ptr中的每个元素，都是一个指向int值的指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr[MAX];
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> MAX <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span> () {
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span>  var[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">10</span>, <span style="color:#099">100</span>, <span style="color:#099">200</span>};
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> i, <span style="color:#000;font-weight:bold">*</span>ptr[MAX];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">for</span> ( i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> MAX; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>      ptr[i] <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>var[i]; <span style="color:#998;font-style:italic">/* 赋值为整数的地址 */</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">for</span> ( i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> MAX; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Value of var[%d] = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, i, <span style="color:#000;font-weight:bold">*</span>ptr[i] );
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>指针数组和数组指针的区别</strong></p>
<ul>
<li>
<p><strong>指针数组</strong>：可以说成是”指针的数组”，首先这个变量是一个数组。其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。在 32 位系统中，指针占四个字节。表示的是一个由指针变量组成的数组，也就是说其中的元素都是指针变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 为什么这里是指针数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// []的优先级高于*，所以这是一个数组，而*修饰数组，所以是指针数组，数组的元素是整型的指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>a[<span style="color:#099">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">10</span> ] ; <span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">1</span> ],<span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">2</span> ],<span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">3</span> ]
</span></span></code></pre></div></li>
<li>
<p><strong>数组指针</strong>：可以说成是”数组的指针”，首先这个变量是一个指针。其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。表示的是这是个指向数组的指针，那么该指针变量存储的地址就必须是数组的首地址，得是个指向行的地址</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 首先括号的优先级最高，所以*a是指针，而[]修饰 *a ，所以是数组指针，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 一个指向3个元素的一维数组指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>a)[<span style="color:#099">3</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span>  a[<span style="color:#099">5</span>]<span style="color:#000;font-weight:bold">=</span>{ <span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span> };    <span style="color:#998;font-style:italic">// 定义一个一维数组 a
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span>  (<span style="color:#000;font-weight:bold">*</span>prt)[<span style="color:#099">5</span>];      <span style="color:#998;font-style:italic">// 步长为 5 的数组指针，即 prt 指向的数组里有 5 个元素
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>prt<span style="color:#000;font-weight:bold">=&amp;</span>a;    <span style="color:#998;font-style:italic">// 把数组 a 的地址付给 prt，则 prt 为数组 a 的地址，*prt 表示数组 a 本身
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>prt[ <span style="color:#099">0</span> ];    <span style="color:#998;font-style:italic">// 表示数组首元素的地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">0</span> ]<span style="color:#a61717;background-color:#e3d2d2">；</span>  <span style="color:#998;font-style:italic">// 表示数组的首元素的值，即为数组 a 的 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">**</span>prt;  <span style="color:#998;font-style:italic">// 表示数组的首元素的值，即为数组 a 的 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 表示指向数组的下一行元素的首元素的值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>prt[ <span style="color:#099">1</span> ]; <span style="color:#998;font-style:italic">// a是一维数组，只有一行，所以指向的地址中的值不确定
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 数组指针加 1，步长为所指向数组的列数，即为下一行的首地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 只在二维及以上维度的数组中有意义，一维数组只有一行，无意义
</span></span></span></code></pre></div></li>
</ul>
<p>根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是种类型的变量。</p>
<h3 id="函数指针-1">函数指针</h3>
<p>函数指针是指向函数的指针变量。通常说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#900;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>fun_ptr)(<span style="color:#458;font-weight:bold">int</span>,<span style="color:#458;font-weight:bold">int</span>); <span style="color:#998;font-style:italic">// 声明一个指向同样参数、返回值的函数指针类型
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">max</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">&gt;</span> y <span style="color:#000;font-weight:bold">?</span> <span style="color:#900;font-weight:bold">x</span> : y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">/* p 是函数指针 声明了函数指针变量 p，指向函数 max */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span> p)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span> max; <span style="color:#998;font-style:italic">// &amp;可以省略
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> a, b, c, d;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;请输入三个数字:&#34;</span>);
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#d14">&#34;%d %d %d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span> a, <span style="color:#000;font-weight:bold">&amp;</span> b, <span style="color:#000;font-weight:bold">&amp;</span> c);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">/* 与直接调用函数等价，d = max(max(a, b), c) */</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#000;font-weight:bold">=</span> p(p(a, b), c); 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;最大的数字是: %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, d);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>&ldquo;指针函数&rdquo; 和 &ldquo;函数指针&rdquo; 是两个相关但截然不同的概念。它们分别涉及到函数和指针的使用。</p>
<p><strong>指针函数（Function Pointer）</strong>：是一个<strong>返回指针的函数</strong>。它<u>是一个函数，其返回类型是一个指针</u>。这意味着该函数返回一个指向某种数据类型的指针。通常，指针函数用于动态分配内存或返回指向某种数据结构的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">getIntegerPointer</span>() { <span style="color:#998;font-style:italic">// 返回一个指向整数的指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>函数指针（Pointer to Function）</strong>：是<strong>一个指向函数的指针变量</strong>。它<u>是一个变量，可以存储函数的地址，然后通过该指针变量来调用函数</u>。函数指针通常用于在运行时选择要调用的函数，或者将函数作为参数传递给其他函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> a, <span style="color:#458;font-weight:bold">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> a <span style="color:#000;font-weight:bold">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>functionPtr)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>); <span style="color:#998;font-style:italic">// 声明一个函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// functionPtr 是一个函数指针，它指向 add 函数，并通过该指针来调用 add 函数。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>functionPtr <span style="color:#000;font-weight:bold">=</span> add; <span style="color:#998;font-style:italic">// 将函数的地址赋给函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> result <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">functionPtr</span>(<span style="color:#099">2</span>, <span style="color:#099">3</span>); <span style="color:#998;font-style:italic">// 使用函数指针调用函数
</span></span></span></code></pre></div><p>指针函数是一个函数，返回一个指针，而函数指针是一个变量，可以存储函数的地址，并通过该指针来调用函数。这两个概念在C语言中都非常有用，尤其是在函数回调、动态加载函数库等情况下。</p>
<h3 id="回调函数">回调函数</h3>
<p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<h4 id="什么是回调函数">什么是回调函数</h4>
<p>回调函数，光听名字就比普通函数要高大上一些，那到底什么是回调函数呢？在百度上搜了一下，发现众说纷纭，有很大一部分都是使用类似这么一个场景来说明：A君去B君店里买东西，恰好缺货，A君留下号码给B君，有货时通知A君。感觉这个让人更容易想到的是异步操作，而不是回调。另外还有两句印象深刻的英文描述：1)*If you call me, I will call you back;*2)<em>Don&rsquo;t call me, I will call you.</em> 看起来好像很有道理，但是仔细一想，普通函数不也可以做到这两点吗？所以，这样的说法都不是很妥当，因为这些说法都没有把回调函数的特点表达出来，也就是都看不到和普通函数到底有什么差别。百度百科的解析：<strong>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数</strong>。</p>
<p>可以先在字面上先做个分解，对于&quot;回调函数&quot;，中文其实可以理解为这么两种意思：1) 被回调的函数；2) 回头执行调用动作的函数。</p>
<blockquote>
<p><strong>维基百科的对回调（Callback）的解析</strong>：把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。</p>
</blockquote>
<blockquote>
<p>**Stack Overflow的表述：**函数<code>F1</code>调用函数<code>F2</code>的时候，函数<code>F1</code>通过参数给函数<code>F2</code>传递了另外一个函数<code>F3</code>的指针，在函数<code>F2</code>执行的过程中，函数<code>F2</code>调用了函数<code>F3</code>，这个动作就叫做回调，而先被当做指针传入、后面又被回调的函数<code>F3</code>就是回调函数。</p>
</blockquote>
<h4 id="为什么要使用回调函数">为什么要使用回调函数</h4>
<p><strong>函数的好处和作用：解耦</strong></p>
<img decoding="async" src="https://gitee.com/oil-lamp/picture-bed/raw/master/typora/202309221510700.jpeg" alt="Smiley face">
<p>下面以一段不完整的 C 语言代码来呈现上图的意思：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;softwareLib.h&gt; // 包含Library Function所在读得Software library库的头文件</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback</span>() { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function<span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> TODO<span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {<span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Main program<span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> TODO<span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Library</span>(Callback);
</span></span><span style="display:flex;"><span>  <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> TODO<span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>乍一看，回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现两者之间的一个关键的不同：<strong>在回调中，主程序把回调函数像参数一样传入库函数</strong>。<u>只要改变传进库函数的参数，就可以实现不同的功能，并且丝毫不需要修改库函数的实现，这就是解耦</u>。仔细看看，主函数和回调函数是在同一层的，而库函数在另外一层，如果库函数不可见，修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那就只能通过传入不同的回调函数了。再把<code>main()</code>、<code>Library()</code>和<code>Callback()</code>函数套回<code>F1</code>、<code>F2</code>和<code>F3</code>函数</p>
<p>明白了回调函数的特点，是不是也可以大概知道它应该在什么情况下使用了？没错，可以在很多地方使用回调函数来代替普通的函数调用，但是，如果需要降低耦合度的时候，更应该使用回调函数。</p>
<h4 id="怎么使用回调函数">怎么使用回调函数？</h4>
<p>知道了什么是回调函数，了解了回调函数的特点，那么应该怎么使用回调函数？下面来看一段简单的可以执行的同步回调函数代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_1</span>() { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">1</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_1 &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_2</span>() { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_2 &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_3</span>() { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">3</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_3 &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Handle</span>(<span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>Callback)()) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Entering Handle Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Callback</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Leaving Handle Function. &#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Entering Main Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(Callback_1);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(Callback_2);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(Callback_3);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Leaving Main Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="./images/202309231508468.png" alt="image-20230923150829367"></p>
<p>可以看到，<code>Handle()</code>函数里面的参数是一个指针，在<code>main()</code>函数里调用<code>Handle()</code>函数的时候，给它传入了函数<code>Callback_1()/Callback_2()/Callback_3()</code>的函数名，这时候的函数名就是对应函数的指针，也就是说，<strong>回调函数其实就是函数指针的一种用法</strong>。</p>
<h4 id="怎么使用带参数的回调函数">怎么使用带参数的回调函数？</h4>
<p>眼尖的朋友可能发现了，前面的例子里面回调函数是没有参数的，那么能不能回调那些带参数的函数呢？答案是肯定的。那么怎么调用呢？稍微修改一下上面的例子就可以了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_1</span>(<span style="color:#458;font-weight:bold">int</span> x) { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">1</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_1: x = %d &#34;</span>, x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_2</span>(<span style="color:#458;font-weight:bold">int</span> x) { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">2</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_2: x = %d &#34;</span>, x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Callback_3</span>(<span style="color:#458;font-weight:bold">int</span> x) { <span style="color:#a61717;background-color:#e3d2d2">*/</span><span style="color:#000;font-weight:bold">/</span> Callback Function <span style="color:#099">3</span><span style="color:#000;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello, this is Callback_3: x = %d &#34;</span>, x);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Handle</span>(<span style="color:#458;font-weight:bold">int</span> y, <span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>Callback)(<span style="color:#458;font-weight:bold">int</span>)) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Entering Handle Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Callback</span>(y);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Leaving Handle Function. &#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> b <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Entering Main Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(a, Callback_1);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(b, Callback_2);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">Handle</span>(c, Callback_3);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Leaving Main Function. &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="./images/202309231509176.png" alt="image-20230923150902077"></p>
<p>并不是直接把<code>int Handle(int (*Callback)())</code>改成<code>int Handle(int (*Callback)(int))</code>就可以的，而是通过另外增加一个参数来保存回调函数的参数值，像这里<code>int Handle(int y, int (*Callback)(int))</code>的参数<code>y</code>。同理，可以使用多个参数的回调函数。</p>
<h4 id="实例-2">实例</h4>
<p>实例中<code>populate_array()</code>函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。定义了回调函数<code>getNextRandomValue()</code>，返回一个随机值，作为一个函数指针传递给<code>populate_array()</code> 函数。</p>
<p><code>populate_array()</code>将调用<code>10</code>次回调函数，并将回调函数的返回值赋值给数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;  </span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">populate_array</span>(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>array, <span style="color:#458;font-weight:bold">size_t</span> arraySize, <span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>getNextValue)(<span style="color:#458;font-weight:bold">void</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">size_t</span> i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>arraySize; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>        array[i] <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">getNextValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 获取随机值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">getNextRandomValue</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#900;font-weight:bold">rand</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> myarray[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     * getNextRandomValue不能加括号，否则无法编译
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     * 因为加上括号之后相当于传入此参数时传入了int, 而不是函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">populate_array</span>(myarray, <span style="color:#099">10</span>, getNextRandomValue);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span>(<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>, myarray[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>关于回调函数的一点思考</strong></p>
<p>在 A 函数中将参数与 C 函数传递给 B 函数，B函数调用 C 函数；B 函数调用的动作称为回调，C 函数称为回调函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 回调函数a
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">callback_a</span>(<span style="color:#458;font-weight:bold">int</span> var_a){    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Call callback_a, var: %d</span><span style="color:#d14">\n\n</span><span style="color:#d14">&#34;</span>, var_a);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 回调函数b
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">callback_b</span>(<span style="color:#458;font-weight:bold">int</span> var_b){    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Call callback_b, var: %d</span><span style="color:#d14">\n\n</span><span style="color:#d14">&#34;</span>, var_b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 回调动作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">callback_act</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>callback) (<span style="color:#458;font-weight:bold">int</span> var)){    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Call callback_act, var_x: %d</span><span style="color:#d14">\n\n</span><span style="color:#d14">&#34;</span>, x);    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">callback</span>(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">main</span>(){    
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>, b <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">callback_act</span>(a, callback_a);    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">callback_act</span>(b, callback_b);    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Main program has done.&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>回调函数的作用完全可以通过普通函数来达到，其实回调函数最大的意义在于解耦，降低了代码之间的耦合度。在内存中除了存放各种各样的变量之外，函数在编译时也会被存放至内存中，因此函数指针就是指向一个函数的指针</p>
<p>函数指针可以实现回调函数的操作，下面列举一些常用的函数指针操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数指针示例 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#998;font-style:italic">// 几个示例函数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print</span>() { <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;哈哈哈</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>); } 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">print1</span>() { <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;哈哈哈哈哈哈</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>); } 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#458;font-weight:bold">int</span> a, <span style="color:#458;font-weight:bold">int</span> b) { <span style="color:#000;font-weight:bold">return</span> a <span style="color:#000;font-weight:bold">+</span> b; } 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">printInt</span>(<span style="color:#458;font-weight:bold">int</span> a) { <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>, a); } 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">pointer</span>() { 
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>a <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>)); 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">*</span>a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">11</span>; <span style="color:#000;font-weight:bold">return</span> a; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 把函数指针作为函数参数传递（回调函数） 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数声明（注意类型的表示） 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">traverse</span>(<span style="color:#458;font-weight:bold">int</span>[], <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>)(<span style="color:#458;font-weight:bold">int</span>)); 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/// @brief 遍历数组元素（回调函数例子） 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/// @param array 数组 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/// @param callback 回调函数，无返回值，一个int参数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">traverse</span>(<span style="color:#458;font-weight:bold">int</span> array[], <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>callback)(<span style="color:#458;font-weight:bold">int</span>)) { 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 遍历前面3个用回调函数访问 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> i; 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">3</span>; i<span style="color:#000;font-weight:bold">++</span>) { 
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">callback</span>(array[i]); 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>); 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数返回函数指针 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 返回一个返回值为int，带两个int参数的函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数本身名为fun，本身无参数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">fun</span>())(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>) { <span style="color:#000;font-weight:bold">return</span> sum; } 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数返回函数指针，带参数型 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 返回一个返回值为void，不带参数的函数指针 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数本身名为fun1，带一个int参数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">fun1</span>(<span style="color:#458;font-weight:bold">int</span> a))() { <span style="color:#000;font-weight:bold">if</span> (a <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">1</span>) { <span style="color:#000;font-weight:bold">return</span> print1; } <span style="color:#000;font-weight:bold">return</span> print; } 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() { 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 函数指针p：无参，返回类型void 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 让函数指针p指向print函数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>p)() <span style="color:#000;font-weight:bold">=</span> print; 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//执行p 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">p</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 函数指针sp：两个int参数，返回类型int 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 让函数指针sp指向sum函数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>sp)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 执行sp 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">sum</span>(<span style="color:#099">1</span>, <span style="color:#099">2</span>)); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 一个返回类型为指针的函数指针 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 把pointer赋值给函数指针ip 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>(<span style="color:#000;font-weight:bold">*</span>ip)() <span style="color:#000;font-weight:bold">=</span> pointer; <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">ip</span>()); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 一个长度为2的函数指针数组fp[2]，其中函数指针是void无参函数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>fp[<span style="color:#099">2</span>])(); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 给函数指针数组中元素赋值 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    fp[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> print; fp[<span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">=</span> print1; 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 执行它们 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    fp[<span style="color:#099">0</span>](); fp[<span style="color:#099">1</span>](); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 使用回调函数 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> arr[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>}; <span style="color:#900;font-weight:bold">traverse</span>(arr, printInt); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 执行返回函数指针的函数得到函数指针，将函数返回值赋值给函数指针getSum 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>getSum)(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">fun</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">getSum</span>(<span style="color:#099">3</span>, <span style="color:#099">4</span>)); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 传参的返回函数指针的函数，下面两个分别赋值给函数指针pp1，pp2 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>pp1)() <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">fun1</span>(<span style="color:#099">1</span>); <span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>pp2)() <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">fun1</span>(<span style="color:#099">0</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 执行 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pp1</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pp2</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 输出函数指针类型变量的大小,使用&#34;返回值 (*)(参数)&#34;可以表示一个函数指针类型的指针变量 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d %d %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>)()), <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">void</span> (<span style="color:#000;font-weight:bold">*</span>)(<span style="color:#458;font-weight:bold">int</span>)), <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>)())); <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="指向指针的指针">指向指针的指针</h3>
<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p><img src="./images/202309231441674.jpeg" alt="C 中指向指针的指针"></p>
<p>一个指向指针的指针变量声明方式：<code>int **var;</code>，即在变量名前放置两个星号。</p>
<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符</p>
<p><img src="./images/202309231443178.png" alt="image-20230923144319073"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span> () {
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span>  V;
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span>  <span style="color:#000;font-weight:bold">*</span>Pt1;
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span>  <span style="color:#000;font-weight:bold">**</span>Pt2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   V <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#998;font-style:italic">/* 获取 V 的地址 */</span>
</span></span><span style="display:flex;"><span>   Pt1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>V;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#998;font-style:italic">/* 使用运算符 &amp; 获取 Pt1 的地址 */</span>
</span></span><span style="display:flex;"><span>   Pt2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>Pt1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#998;font-style:italic">/* 使用 pptr 获取值 */</span>
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;var = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, V );
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Pt1 = %p</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, Pt1 );
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;*Pt1 = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>Pt1 );
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Pt2 = %p</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, Pt2 );
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;**Pt2 = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">**</span>Pt2);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>指针更像是一个找地址开门取物品的操作。其中<code>*</code>就是这个动作重复的次数，`ptr是取东西的门牌号也就是地址值：</p>
<ul>
<li><code>*ptr</code>是完成一次开门取东西操作最终取出来的东西。</li>
<li><code>**ptr</code>是完成两次开门取物。需要注意的是第一次取得的是第二次要开的门的门牌号或者说地址，然后根据门牌号继续开门取物。 <code>*ptr</code>或者 <code>**ptr</code>一定是取出来的东西，即为数值。而<code>ptr</code>一定是门牌号，即为地址值</li>
</ul>
<h3 id="复杂类型指针说明">复杂类型指针说明</h3>
<p>要了解指针，多多少少会出现一些比较复杂的类型，所以先介绍一下如何完全理解一个复杂类型。要理解复杂类型其实很简单，一个类型里会出现很多运算符，也像普通的表达式一样，有优先级，其优先级和运算优先级一样，所以总结了一下其原则：从变量名处起，根据运算符优先级结合，一步一步分析。</p>
<p>先从简单的类型开始慢慢分析：</p>
<ul>
<li><code>int p;</code>：一个普通的整型变量</li>
<li><code>int *p;</code>：首先从<code>p</code>处开始，先与<code>*</code>结合，所以说明<code>p</code>是一个指针, 然后再与<code>int</code>结合, 说明指针所指向的内容的类型为<code>int</code>型。所以<code>p</code>是一个返回整型数据的指针。</li>
<li><code>int p[3]</code>：首先从<code>p</code>处开始，先与<code>[]</code>结合，说明<code>p</code>是一个数组, 然后与<code>int</code>结合, 说明数组里的元素是整型的, 所以<code>p</code>是一个由整型数据组成的数组。</li>
<li><code>int *p[3];</code>：首先从<code>p</code>处开始，先与<code>[]</code>结合，因为其优先级比<code>*</code>高，所以<code>p</code>是一个数组, 然后再与<code>*</code>结合，说明数组里的元素是指针类型，然后再与<code>int</code>结合，说明指针所指向的内容的类型是整型的，所以<code>p</code>是一个由返回整型数据的指针所组成的数组。</li>
<li><code>int (*p)[3];</code>：首先从<code>p</code>处开始，先与<code>*</code>结合，说明<code>p</code>是一个指针然后再与<code>[]</code>结合(与<code>()</code>这步可以忽略，只是为了改变优先级)，说明指针所指向的内容是一个数组，然后再与<code>int</code>结合，说明数组里的元素是整型的。所以<code>p</code>是一个指向由整型数据组成的数组的指针。</li>
<li><code>int **p;</code>：首先从<code>p</code>开始，先与<code>*</code>结合，说是<code>p</code>是一个指针，然后再与<code>*</code>结合，说明指针所指向的元素是指针，然后再与<code>int</code>结合，说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中，所以后面更复杂的类型我们就不考虑多级指针了，最多只考虑一级指针。</li>
<li><code>int p(int);</code>：从<code>p</code>处起，先与<code>()</code>结合，说明<code>p</code>是一个函数，然后进入<code>()</code>里分析，说明该函数有一个整型变量的参数，然后再与外面的<code>int</code>结合，说明函数的返回值是一个整型数据。</li>
<li><code>int (*p)(int);</code>：从<code>p</code>处开始，先与指针结合，说明<code>p</code>是一个指针，然后与<code>()</code>结合，说明指针指向的是一个函数，然后再与<code>()</code>里的<code>int</code>结合，说明函数有一个<code>int</code>型的参数，再与最外层的<code>int</code> 结合，说明函数的返回类型是整型，所以<code>p</code>是一个指向有一个整型参数且返回类型为整型的函数的指针。</li>
<li><code>int *(*p(int))[3];</code>：可以先跳过，不看这个类型，过于复杂从<code>p</code>开始，先与<code>()</code>结合，说明<code>p</code>是一个函数，然后进入<code>()</code>里面，与<code>int</code>结合，说明函数有一个整型变量参数，然后再与外面的<code>*</code>结合，说明函数返回的是一个指针，然后到最外面一层，先与<code>[]</code>结合，说明返回的指针指向的是一个数组，然后再与<code>*</code>结合，说明数组里的元素是指针，然后再与<code>int</code>结合，说明指针指向的内容是整型数据。所以<code>p</code>是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。</li>
</ul>
<h4 id="细说指针">细说指针</h4>
<p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。</p>
<p>先声明几个指针放着做例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>ptr; 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">**</span>ptr;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>ptr)[<span style="color:#099">3</span>]; 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>(<span style="color:#000;font-weight:bold">*</span>ptr)[<span style="color:#099">4</span>];
</span></span></code></pre></div><h5 id="指针的类型">指针的类型</h5>
<p>从语法的角度看，只要把指针声明语句里的指针名字去掉，剩下的部分就是指针类型。这是指针本身所具有的类型</p>
<ul>
<li><code>int *ptr;</code>指针的类型是<code>int*</code></li>
<li><code>char *ptr;</code>指针的类型是<code>char*</code></li>
<li><code>int **ptr;</code>指针的类型是<code>int**</code></li>
<li><code>int (*ptr)[3];</code>指针的类型是<code>int(*)[3]</code></li>
<li><code>int *(*ptr)[4];</code>指针的类型是<code>int*(*)[4]</code></li>
</ul>
<h5 id="指针所指向的类型">指针所指向的类型</h5>
<p>当通过指针来访问指针所指向的内存区时，指针所指向的类型决定编译器将把那片内存区里的内容当做什么来看待</p>
<p>从语法上看，只须把指针声明语句中的指针名字和名字左边的指针声明符<code>*</code>去掉，剩下的就是指针所指向的类型</p>
<ul>
<li><code>int *ptr;</code>指针所指向的类型是<code>int</code></li>
<li><code>char *ptr;</code>指针所指向的的类型是<code>char</code></li>
<li><code>int **ptr;</code>指针所指向的的类型是<code>int*</code></li>
<li><code>int (*ptr)[3];</code>指针所指向的的类型是<code>int()[3]</code></li>
<li><code>int *(*ptr)[4];</code>指针所指向的的类型是<code>int*()[4]</code></li>
</ul>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当对C 越来越熟悉时，会发现，把指针搅和在一起的&quot;类型&quot;这个概念分成&quot;指针的类型&quot;和&quot;指针所指向的类型&quot;两个概念，是精通指针的关键点之一</p>
<h5 id="指针的值----或者叫指针所指向的内存区或地址">指针的值&mdash;-或者叫指针所指向的内存区或地址</h5>
<p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为<code>sizeof(指针所指向的类型)</code>的一片内存区。说一个指针的值是<code>XX</code>，就相当于说该指针指向了以<code>XX</code>为首地址的一片内存区域；说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在示例中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
<h5 id="指针本身所占据的内存区">指针本身所占据的内存区</h5>
<p>指针本身占了多大的内存？只要用运算符<code>sizeof(指针的类型)</code>测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
<h4 id="指针的算术运算">指针的算术运算</h4>
<p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，<strong>以单元为单位</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> a[<span style="color:#099">20</span>]; <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)a; <span style="color:#998;font-style:italic">//强制类型转换并不会改变 a 的类型 ptr++;
</span></span></span></code></pre></div><p>在上例中，指针 ptr 的类型是 int*,它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了 1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">20</span>]<span style="color:#000;font-weight:bold">=</span>{<span style="color:#099">0</span>}; 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=</span>array;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span>(i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;i<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#099">20</span>;i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    (<span style="color:#000;font-weight:bold">*</span>ptr)<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    ptr<span style="color:#000;font-weight:bold">++</span><span style="color:#a61717;background-color:#e3d2d2">；</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加 1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> a[<span style="color:#099">20</span>]<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;You_are_a_girl&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)a;
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">+=</span><span style="color:#099">5</span>;
</span></span></code></pre></div><p>在这个例子中，ptr 被加上了 5，编译器是这样处理的：将指针 ptr 的值加上 5 乘 sizeof(int)，在 32 位程序中就是加上了 5 乘 4=20。由于地址的单位是字节，故现在的 ptr 所指向的地址比起加 5 后的 ptr 所指向的地址来说，向高地址方向移动了 20 个字节。</p>
<p>在这个例子中，没加 5 前的 ptr 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，ptr 已经指向了数组 a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去 5，那么处理过程大同小异，只不过 ptr 的值是被减去 5 乘 sizeof(int)，新的 ptr 指向的地址将比原来的 ptr 所指向的地址向低地址方向移动了 20 个字节。</p>
<p>下面请允许我再举一个例子:(一个误区)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span><span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> a[<span style="color:#099">20</span>]<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34; You_are_a_girl&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>p<span style="color:#000;font-weight:bold">=</span>a;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">**</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//printf(&#34;p=%d\n&#34;,p);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//printf(&#34;ptr=%d\n&#34;,ptr);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//printf(&#34;*ptr=%d\n&#34;,*ptr);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;**ptr=%c</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,<span style="color:#000;font-weight:bold">**</span>ptr);
</span></span><span style="display:flex;"><span>    ptr<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//printf(&#34;ptr=%d\n&#34;,ptr);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//printf(&#34;*ptr=%d\n&#34;,*ptr);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;**ptr=%c</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,<span style="color:#000;font-weight:bold">**</span>ptr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>误区一、输出答案为 Y 和 o</strong></p>
<p>误解: ptr 是一个 char 的二级指针, 当执行 ptr++; 时,会使指针加一个 sizeof(char), 所以输出如上结果,这个可能只是少部分人的结果。</p>
<p>**误区二、**输出答案为 Y 和 a 误解: ptr 指向的是一个 char * 类型, 当执行 ptr++; 时,会使指针加一个 sizeof(char *) (有可能会有人认为这个值为 1, 那就会得到误区一的答案, 这个值应该是 4, 参考前面内容), 即 &amp;p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗? 那输出的结果不就是数组中第五个元素了吗?答案是否定的。</p>
<p><strong>正解:</strong> ptr 的类型是 char *<em>, 指向的类型是一个 char * 类型, 该指向的地址就是 p 的地址 (&amp;p), 当执行 ptr++; 时, 会使指针加一个 sizeof(char</em>), 即 &amp;p+4; 那 *(&amp;p+4) 指向哪呢, 这个你去问上帝吧, 或者他会告诉你在哪? 所以最后的输出会是一个随机的值, 或许是一个非法操作。</p>
<p><strong>总结一下:</strong></p>
<p>一个指针 ptrold 加(减)一个整数 n 后，结果是一个新的指针 ptrnew，ptrnew 的类型和 ptrold 的类型相同，ptrnew 所指向的类型和 ptrold 所指向的类型也相同。ptrnew 的值将比 ptrold 的值增加(减少)了 n 乘 sizeof(ptrold 所指向的类型)个字节。就是说，ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了 n 乘 sizeof(ptrold 所指向的类型)个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。</p>
<h4 id="运算符和">运算符&amp;和*</h4>
<p>这里 <strong>&amp;</strong> 是取地址运算符，***** 是间接运算符。</p>
<p><strong>&amp;a</strong> 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。</p>
<p>*<strong>p</strong> 的运算结果就五花八门了。总之 *p 的结果是p 所指向的东西，这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">12</span>; <span style="color:#458;font-weight:bold">int</span> b; <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>p; <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">**</span>ptr;
</span></span><span style="display:flex;"><span>p<span style="color:#000;font-weight:bold">=&amp;</span>a; <span style="color:#998;font-style:italic">//&amp;a 的结果是一个指针，类型是int*，指向的类型是
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//int，指向的地址是a 的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>p<span style="color:#000;font-weight:bold">=</span><span style="color:#099">24</span>; <span style="color:#998;font-style:italic">//*p 的结果，在这里它的类型是int，它所占用的地址是
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//p 所指向的地址，显然，*p 就是变量a。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>p; <span style="color:#998;font-style:italic">//&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//在这里是int **。该指针所指向的类型是p 的类型，这
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//里是int*。该指针所指向的地址就是指针p 自己的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>b; <span style="color:#998;font-style:italic">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//值就是毫无问题的了。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">**</span>ptr<span style="color:#000;font-weight:bold">=</span><span style="color:#099">34</span>; <span style="color:#998;font-style:italic">//*ptr 的结果是ptr 所指向的东西，在这里是一个指针，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//对这个指针再做一次*运算，结果是一个int 类型的变量。
</span></span></span></code></pre></div><h4 id="指针表达式">指针表达式</h4>
<p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p>
<p>下面是一些指针表达式的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a,b;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>pa;
</span></span><span style="display:flex;"><span>pa<span style="color:#000;font-weight:bold">=&amp;</span>a; <span style="color:#998;font-style:italic">//&amp;a 是一个指针表达式。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Int <span style="color:#000;font-weight:bold">**</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>pa; <span style="color:#998;font-style:italic">//&amp;pa 也是一个指针表达式。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>b; <span style="color:#998;font-style:italic">//*ptr 和&amp;b 都是指针表达式。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>pa<span style="color:#000;font-weight:bold">=</span>array;
</span></span><span style="display:flex;"><span>pa<span style="color:#000;font-weight:bold">++</span>; <span style="color:#998;font-style:italic">//这也是指针表达式。
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>arr[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">**</span>parr<span style="color:#000;font-weight:bold">=</span>arr; <span style="color:#998;font-style:italic">//如果把arr 看作指针的话，arr 也是指针表达式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>str;
</span></span><span style="display:flex;"><span>str<span style="color:#000;font-weight:bold">=*</span>parr; <span style="color:#998;font-style:italic">//*parr 是指针表达式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>str<span style="color:#000;font-weight:bold">=*</span>(parr<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>); <span style="color:#998;font-style:italic">//*(parr+1)是指针表达式
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>str<span style="color:#000;font-weight:bold">=*</span>(parr<span style="color:#000;font-weight:bold">+</span><span style="color:#099">2</span>); <span style="color:#998;font-style:italic">//*(parr+2)是指针表达式
</span></span></span></code></pre></div><p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。*ptr 是一个左值，因为 *ptr 这个指针已经占据了内存，其实 *ptr 就是指针 pa，既然 pa 已经在内存中有了自己的位置，那么 *ptr 当然也有了自己的位置。</p>
<h4 id="数组和指针的关系">数组和指针的关系</h4>
<p>数组的数组名其实可以看作一个指针。看下例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">10</span>]<span style="color:#000;font-weight:bold">=</span>{<span style="color:#099">0</span>,<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>,<span style="color:#099">4</span>,<span style="color:#099">5</span>,<span style="color:#099">6</span>,<span style="color:#099">7</span>,<span style="color:#099">8</span>,<span style="color:#099">9</span>},value;
</span></span><span style="display:flex;"><span>value<span style="color:#000;font-weight:bold">=</span>array[<span style="color:#099">0</span>]; <span style="color:#998;font-style:italic">//也可写成：value=*array;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>value<span style="color:#000;font-weight:bold">=</span>array[<span style="color:#099">3</span>]; <span style="color:#998;font-style:italic">//也可写成：value=*(array+3);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>value<span style="color:#000;font-weight:bold">=</span>array[<span style="color:#099">4</span>]; <span style="color:#998;font-style:italic">//也可写成：value=*(array+4);
</span></span></span></code></pre></div><p>上例中，一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 int* 所指向的类型是数组单元的类型即 int。因此 *array 等于 0 就一点也不奇怪了。同理，array+3 是一个指向数组第 3 个单元的指针，所以 *<strong>(array+3)</strong> 等于 3。其它依此类推。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>str[<span style="color:#099">3</span>]<span style="color:#000;font-weight:bold">=</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;Hello,thisisasample!&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;Hi,goodmorning.&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;Helloworld&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">80</span>]<span style="color:#a61717;background-color:#e3d2d2">；</span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(s,str[<span style="color:#099">0</span>]); <span style="color:#998;font-style:italic">//也可写成strcpy(s,*str);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">strcpy</span>(s,str[<span style="color:#099">1</span>]); <span style="color:#998;font-style:italic">//也可写成strcpy(s,*(str+1));
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">strcpy</span>(s,str[<span style="color:#099">2</span>]); <span style="color:#998;font-style:italic">//也可写成strcpy(s,*(str+2));
</span></span></span></code></pre></div><p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。</p>
<p>*str 也是一个指针，它的类型是 char *，它所指向的类型是 char，它指向的地址是字符串 &ldquo;Hello,thisisasample!&rdquo; 的第一个字符的地址，即 &lsquo;H&rsquo; 的地址。注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值.如果看成指针的话, 他即是常量指针, 也是指针常量。</p>
<p>str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char**，它指向的类型是 char*。</p>
<p><em>(str+1) 也是一个指针，它的类型是 char</em>，它所指向的类型是 char，它指向 &ldquo;Hi,goodmorning.&rdquo; 的第一个字符 &lsquo;H&rsquo;。</p>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<p>声明了一个数组 <strong>TYPE array[n]</strong>，则数组名称 array 就有了两重含义：</p>
<ul>
<li>第一，它代表整个数组，它的类型是 <strong>TYPE[n]</strong>；</li>
<li>第二，它是一个常量指针，该指针的类型是 <strong>TYPE*</strong>，该指针指向的类型是 <strong>TYPE</strong>，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。</li>
</ul>
<p>在表达式 *array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。<strong>sizeof(*array)</strong> 测出的是数组单元的大小。</p>
<p>表达式 array+n（其中n=0，1，2，&hellip;..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是 <strong>TYPE *</strong>，它指向的类型是 TYPE，它指向数组第 n 号单元。故sizeof(array+n)测出的是指针类型的大小。在 32 位程序中结果是 4。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>ptr)[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>array;<span style="color:#a61717;background-color:#e3d2d2">：</span>
</span></span></code></pre></div><p>上例中 ptr 是一个指针，它的类型是 <strong>int(*)[10]</strong>，他指向的类型是 int[10] ，我们用整个数组的首地址来初始化它。在语句 ptr=&amp;array中，array 代表数组本身。</p>
<p>本节中提到了函数 sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？</p>
<p>答案是前者。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#000;font-weight:bold">*</span>ptr)[<span style="color:#099">10</span>];
</span></span></code></pre></div><p>则在 32 位程序中，有：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>(<span style="color:#000;font-weight:bold">*</span>)[<span style="color:#099">10</span>])<span style="color:#000;font-weight:bold">==</span><span style="color:#099">4</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>[<span style="color:#099">10</span>])<span style="color:#000;font-weight:bold">==</span><span style="color:#099">40</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">sizeof</span>(ptr)<span style="color:#000;font-weight:bold">==</span><span style="color:#099">4</span>
</span></span></code></pre></div><p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h4 id="指针和结构类型的关系">指针和结构类型的关系</h4>
<p>可以声明一个指向结构类型对象的指针。实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> MyStruct
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> c;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> MyStruct ss<span style="color:#000;font-weight:bold">=</span>{<span style="color:#099">20</span>,<span style="color:#099">30</span>,<span style="color:#099">40</span>};
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> MyStruct <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>ss;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//声明了一个指向结构对象ss 的指针。它的类型是
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//MyStruct *,它指向的类型是MyStruct。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>pstr<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>ss;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//声明了一个指向结构对象ss 的指针。但是pstr 和
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//它被指向的类型ptr 是不同的。
</span></span></span></code></pre></div><p>请问怎样通过指针 ptr 来访问 ss 的三个成员变量？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">-&gt;</span>a; <span style="color:#998;font-style:italic">//指向运算符，或者可以这们(*ptr).a,建议使用前者
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr<span style="color:#000;font-weight:bold">-&gt;</span>b;
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">-&gt;</span>c;
</span></span></code></pre></div><p>又请问怎样通过指针 pstr 来访问 ss 的三个成员变量？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>pstr<span style="color:#a61717;background-color:#e3d2d2">；</span> <span style="color:#998;font-style:italic">//访问了ss 的成员a。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>(pstr<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>); <span style="color:#998;font-style:italic">//访问了ss 的成员b。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>(pstr<span style="color:#000;font-weight:bold">+</span><span style="color:#099">2</span>) <span style="color:#998;font-style:italic">//访问了ss 的成员c。
</span></span></span></code></pre></div><p>虽然我在我的 MSVC++6.0 上调式过上述代码，但是要知道，这样使用 pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> array[<span style="color:#099">3</span>]<span style="color:#000;font-weight:bold">=</span>{<span style="color:#099">35</span>,<span style="color:#099">56</span>,<span style="color:#099">37</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>pa<span style="color:#000;font-weight:bold">=</span>array;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//通过指针pa 访问数组array 的三个单元的方法是：
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>pa; <span style="color:#998;font-style:italic">//访问了第0 号单元
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>(pa<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>); <span style="color:#998;font-style:italic">//访问了第1 号单元
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>(pa<span style="color:#000;font-weight:bold">+</span><span style="color:#099">2</span>); <span style="color:#998;font-style:italic">//访问了第2 号单元
</span></span></span></code></pre></div><p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。</p>
<p>所有的 C/C++ 编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个&quot;填充字节&quot;，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<p>所以，在例十二中，即使 *pstr 访问到了结构对象 ss 的第一个成员变量 a，也不能保证 *(pstr+1) 就一定能访问到结构成员 b。因为成员 a 和成员 b 之间可能会有若干填充字节，说不定 *(pstr+1) 就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。</p>
<p>不过指针访问结构成员的正确方法应该是象例十二中使用指针 ptr 的方法。</p>
<h4 id="指针和函数的关系">指针和函数的关系</h4>
<p>可以把一个指针声明成为一个指向函数的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">fun1</span>(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>,<span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>pfun1)(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>,<span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span>pfun1<span style="color:#000;font-weight:bold">=</span>fun1;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a<span style="color:#000;font-weight:bold">=</span>(<span style="color:#000;font-weight:bold">*</span>pfun1)(<span style="color:#d14">&#34;abcdefg&#34;</span>,<span style="color:#099">7</span>); <span style="color:#998;font-style:italic">//通过函数指针调用函数。
</span></span></span></code></pre></div><p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>);
</span></span><span style="display:flex;"><span>inta;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str[]<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;abcdefghijklmn&#34;</span>;
</span></span><span style="display:flex;"><span>a<span style="color:#000;font-weight:bold">=</span><span style="color:#900;font-weight:bold">fun</span>(str);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> num<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span>(<span style="color:#458;font-weight:bold">int</span> i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;;)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        num<span style="color:#000;font-weight:bold">+=*</span>s;s<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> num;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个例子中的函数 fun 统计一个字符串中各个字符的 ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把 str 作为实参传递给形参 s 后，实际是把 str 的值传递给了 s，s 所指向的地址就和 str 所指向的地址一致，但是 str 和 s 各自占用各自的存储空间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 str 进行了自加 1 运算。</p>
<h4 id="指针类型转换">指针类型转换</h4>
<p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> f<span style="color:#000;font-weight:bold">=</span><span style="color:#099">12.3</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> <span style="color:#000;font-weight:bold">*</span>fptr<span style="color:#000;font-weight:bold">=&amp;</span>f;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>p;
</span></span></code></pre></div><p>在上面的例子中，假如我们想让指针 p 指向实数 f，应该怎么办？</p>
<p>是用下面的语句吗？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>p<span style="color:#000;font-weight:bold">=&amp;</span>f;
</span></span></code></pre></div><p>不对。因为指针 p 的类型是 int *，它指向的类型是 int。表达式 &amp;f 的结果是一个指针，指针的类型是 float *,它指向的类型是 float。</p>
<p>两者不一致，直接赋值的方法是不行的。至少在我的 MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行&quot;强制类型转换&quot;：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>p<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>f;
</span></span></code></pre></div><p>如果有一个指针 p，我们需要把它的类型和所指向的类型改为 <strong>TYEP *TYPE</strong>， 那么语法格式是：<strong>(TYPE *)p</strong></p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是 <strong>TYPE *</strong>，它指向的类型是 <strong>TYPE</strong>，它指向的地址就是原指针指向的地址。 而原来的指针p 的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">125</span>,b;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">fun</span>((<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>a);
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">fun</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> c;
</span></span><span style="display:flex;"><span>    c<span style="color:#000;font-weight:bold">=*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">3</span>);<span style="color:#000;font-weight:bold">*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">3</span>)<span style="color:#000;font-weight:bold">=*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">0</span>);<span style="color:#000;font-weight:bold">*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">0</span>)<span style="color:#000;font-weight:bold">=</span>c;
</span></span><span style="display:flex;"><span>    c<span style="color:#000;font-weight:bold">=*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">2</span>);<span style="color:#000;font-weight:bold">*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">2</span>)<span style="color:#000;font-weight:bold">=*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>);<span style="color:#000;font-weight:bold">*</span>(s<span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)<span style="color:#000;font-weight:bold">=</span>c;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参 &amp;a 的结果是一个指针，它的类型是 int *，它指向的类型是 int。形参这个指针的类型是 char *，它指向的类型是 char。这样，在实参和形参的结合过程中，我们必须进行一次从 int * 类型到 char * 类型的转换。</p>
<p><strong>结合这个例子，我们可以这样来：</strong></p>
<p>想象编译器进行转换的过程：编译器先构造一个临时指针 char *temp，然后执行 temp=(char *)&amp;a，最后再把 temp 的值传递给 s。所以最后的结果是：s 的类型是 char *,它指向的类型是 char，它指向的地址就是 a 的首地址。</p>
<p>我们已经知道，指针的值就是指针指向的地址，在 32 位程序中，指针的值其实是一个 32 位整数。</p>
<p>那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>TYPE <span style="color:#000;font-weight:bold">*</span>ptr; <span style="color:#998;font-style:italic">//TYPE 是int，char 或结构类型等等类型。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">20345686</span>;
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">=</span><span style="color:#099">20345686</span>; <span style="color:#998;font-style:italic">//我们的目的是要使指针ptr 指向地址20345686
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">=</span>a; <span style="color:#998;font-style:italic">//我们的目的是要使指针ptr 指向地址20345686
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">//编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>TYPE <span style="color:#000;font-weight:bold">*</span>ptr; <span style="color:#998;font-style:italic">//TYPE 是int，char 或结构类型等等类型。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>a<span style="color:#000;font-weight:bold">=</span>N <span style="color:#998;font-style:italic">//N 必须代表一个合法的地址；
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>ptr<span style="color:#000;font-weight:bold">=</span>(TYPE<span style="color:#000;font-weight:bold">*</span>)a
</span></span></code></pre></div><p>严格说来这里的 (TYPE *) 和指针类型转换中的 (TYPE <em>) 还不一样。这里的 (TYPE</em>) 的意思是把无符号整数 a 的值当作一个地址来看待。上面强调了 a 的值必须代表一个合法的地址，否则的话，在你使用 ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">123</span>,b;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>a;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>str;
</span></span><span style="display:flex;"><span>b<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span>)ptr; <span style="color:#998;font-style:italic">//把指针ptr 的值当作一个整数取出来。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>str<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>)b; <span style="color:#998;font-style:italic">//把这个整数的值当作一个地址赋给指针str。
</span></span></span></code></pre></div><p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<h4 id="指针的安全问题">指针的安全问题</h4>
<p>看下面的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr;
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">=</span>(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>s;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1298</span><span style="color:#a61717;background-color:#e3d2d2">；</span>
</span></span></code></pre></div><p>指针 ptr 是一个 int * 类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。</p>
<p>让我们再来看一例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> a; 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=&amp;</span>a;
</span></span><span style="display:flex;"><span>ptr<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>ptr<span style="color:#000;font-weight:bold">=</span><span style="color:#099">115</span>;
</span></span></code></pre></div><p>该例子完全可以通过编译，并能执行。但是看到没有？第 3 句对指针 ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。</p>
<p>而第 4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。</p>
<p>在指针的强制类型转换：<strong>ptr1=(TYPE *)ptr2</strong> 中，如果 sizeof(ptr2的类型)大于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。</p>
<p>为什么叫指针，指针其实是一种很形象的比喻，下面说说我的个人理解。</p>
<p>int 变量存的是 int 型的值，char 变量存的是 char 型的值，而指针，它是一种特殊的变量，存的是内存地址，按照这个模板可以把它理解为：<strong>“内存地址变量” 存的是 “内存地址”，等价于：“指针变量” 存的是 “内存地址”</strong></p>
<p>操作系统进行资源调度时，会根据这些变量存的地址去请求和使用那个地址代表的内存区域，这就仿佛像是这个变量存的地址指向了某片内存，人们用 “指针” 来统称所谓的 “内存地址变量”</p>
<p>因此，<strong>任何跟指针有关的概念，都可以联系内存地址加以理解</strong>，二者必然有联系，数组与指针，函数与指针，都是如此。</p>
<ul>
<li><strong>内存是线性的</strong>，内存以地址空间的形式呈现给我们看的，所以可以说所谓的地址空间也是线性的，指针存放的是内存地址，所以你可以对地址做 ++，或者 &ndash; 这样的运算。</li>
<li><strong>两个指针不赋 NULL，是坏习惯</strong></li>
<li><strong>初始化指针不赋 NULL</strong>，因为这样的指针会指向一片未知的区域，这样的指针不是空指针，但指向一片访问受限制的内存区域，你无法使用它，这样的情况下的指针，业界给了它一个形象的名字：“野指针”，而且难以调试，在许多编译器单步 debug 会出现奇怪的错误，但经常看见的 &ldquo;Segmentation Fault&rdquo; 这样的错误，实测当代码多的时候，这是一个非常蛋疼的错误，野指针就是成因之一，所以看到这样的错误，首先是想想，是否有某些指针没有初始化引起的</li>
<li><strong>free() 后指针不赋 NULL</strong>，为指针分配内存后，指针便可以指向一片合法可使用的内存，但使用 free() 释放那片内存时，指针依旧存放着那片内存的地址，也就是依旧指向那片内存，但这片内存已经释放，不可访问，这时若不小心使用了这个指针，便会内存错误，又是会有奇怪的 bug ，代码几百行多点就会难以调试，业界给这样的指针也有个统称：“悬空指针”，为了避免这种蛋疼的情况出现，一定要释放内存后，给指向这片内存的指针，都赋值为 NULL，从中也可以看出，free() 这个函数释放内存时跟指向这片内存的指针并没有什么卵关系，不会连着把指针一起搞定掉的！ <strong>珍爱生命，远离 &ldquo;野指针&rdquo; 与 &ldquo;悬空指针&rdquo; ！</strong></li>
<li><strong>多级指针</strong>，指向指针的指针，有时人们也管它叫多维指针。既然指针变量是一个变量，指针变量能存变量的内存的地址。</li>
</ul>
<p>像<code>int *</code>存<code>int</code>型变量的地址，<code>char *</code>存<code>char</code>型的地址，那指针理所当然可以存指针变量的地址啊。</p>
<p>例如，<code>int **</code>存<code>int *</code>的地址，<code>int ***</code>存<code>int **</code>的地址。</p>
<p>这就是一个二级指针存一级指针的地址，三级指针存二级指针的地址，人们把这样的过程叫指向指针的指针，但其实也就是一个上一级的指针存了下一级的指针的地址而已。</p>
<p>因此，像上面说的，你存了它的地址，你就是指向它，所以：</p>
<ul>
<li>二级指针存一级指针的地址，那么可以说二级指针指向一级指针</li>
<li>三级指针存二级指针的地址，那么可以说二级指针指向一级指针</li>
<li>多级指针用处多多， 这里暂不举例详细说明。</li>
</ul>
<p>个人认为指针可以说是 C 的最伟大的特性，通过这样的一个模型可以形象地管理部分内存！</p>
<h2 id="字符串">字符串</h2>
<p>在 C 语言中，字符串实际上是使用空字符<code>\0</code>结尾的一维字符数组。因此，<code>\0</code>是用于标记字符串的结束。</p>
<p><strong>空字符（Null character</strong>）又称结束符，缩写<code>NULL</code>，是一个数值为<code>0</code>的控制字符，<code>\0</code>是转义字符，意思是告诉编译器，这不是字符<code>0</code>，而是空字符。</p>
<h3 id="简介-3">简介</h3>
<p>C 语言没有单独的字符串类型，字符串被当作字符数组，即<code>char</code>类型的数组。比如，字符串<code>&quot;Hello&quot;</code>是当作数组<code>{'H', 'e', 'l', 'l', 'o'}</code>处理的。</p>
<p>编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C 语言会自动添加一个全是二进制<code>0</code>的字节，写作<code>\0</code>字符，表示字符串结束。字符<code>\0</code>不同于字符<code>0</code>，前者的 ASCII 码是0（二进制形式<code>00000000</code>），后者的 ASCII 码是48（二进制形式<code>00110000</code>）。所以，字符串<code>&quot;Hello&quot;</code>实际储存的数组是<code>{'H', 'e', 'l', 'l', 'o', '\0'}</code></p>
<p><img src="/images/202309231620287.png" alt="字符串"></p>
<p>所有字符串的最后一个字符，都是<code>\0</code>。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是<code>\0</code>，那么就知道字符串结束了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 声明了一个10个成员的字符数组，可以当作字符串
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 由于必须留一个位置给`\0`，所以最多只能容纳9个字符的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> localString[<span style="color:#099">10</span>];
</span></span></code></pre></div><p>字符串写成数组的形式，是非常麻烦的。C 语言提供了一种简写法，双引号之中的字符，会被自动视为字符数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>{<span style="color:#d14">&#39;H&#39;</span>, <span style="color:#d14">&#39;e&#39;</span>, <span style="color:#d14">&#39;l&#39;</span>, <span style="color:#d14">&#39;l&#39;</span>, <span style="color:#d14">&#39;o&#39;</span>, <span style="color:#d14">&#39;\0&#39;</span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等价于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#d14">&#34;Hello&#34;</span>
</span></span></code></pre></div><p>上面两种字符串的写法是等价的，内部存储方式都是一样的。双引号里面的字符串，不用自己添加结尾字符<code>\0</code>，C 语言会自动添加。</p>
<p>注意，双引号里面是字符串，单引号里面是字符，两者不能互换。如果把<code>Hello</code>放在单引号里面，编译器会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2">&#39;</span>Hello<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>
</span></span></code></pre></div><p>另一方面，即使双引号里面只有一个字符（比如<code>&quot;a&quot;</code>），也依然被处理成字符串（存储为2个字节），而不是字符<code>'a'</code>（存储为1个字节）。</p>
<p>如果字符串内部包含双引号，则该双引号需要使用反斜杠转义。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#d14">&#34;She replied, </span><span style="color:#d14">\&#34;</span><span style="color:#d14">It does.</span><span style="color:#d14">\&#34;</span><span style="color:#d14">&#34;</span>
</span></span></code></pre></div><p>反斜杠还可以表示其他特殊字符，比如换行符（<code>\n</code>）、制表符（<code>\t</code>）等。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#d14">&#34;Hello, world!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>
</span></span></code></pre></div><p>如果字符串过长，可以在需要折行的地方，使用反斜杠（<code>\</code>）结尾，将一行拆成多行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#d14">&#34;hello \
</span></span></span><span style="display:flex;"><span><span style="color:#d14">world&#34;</span>
</span></span></code></pre></div><p>上面示例中，第一行尾部的反斜杠，将字符串拆成两行。</p>
<p>上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串。为了解决这个问题，C 语言允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> greeting[<span style="color:#099">50</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, &#34;&#34;how are you &#34;&#34;today!&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> greeting[<span style="color:#099">50</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, how are you today!&#34;</span>;
</span></span></code></pre></div><p>这种新写法支持多行字符串的合并。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> greeting[<span style="color:#099">50</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, &#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;how are you &#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;today!&#34;</span>;
</span></span></code></pre></div><p><code>printf()</code>使用占位符<code>%s</code>输出字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#d14">&#34;hello world&#34;</span>)
</span></span></code></pre></div><h3 id="字符串变量的声明">字符串变量的声明</h3>
<p>字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">14</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span></code></pre></div><p>上面两种写法都声明了一个字符串变量<code>s</code>。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span></code></pre></div><p>上面示例中，编译器会将数组<code>s</code>的长度指定为14，正好容纳后面的字符串。</p>
<p>字符数组的长度，可以大于字符串的实际长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">50</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span></code></pre></div><p>上面示例中，字符数组<code>s</code>的长度是<code>50</code>，但是字符串<code>&quot;hello&quot;</code>的实际长度只有6（包含结尾符号<code>\0</code>），所以后面空出来的44个位置，都会被初始化为<code>\0</code>。</p>
<p>字符数组的长度，不能小于字符串的实际长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span></code></pre></div><p>上面示例中，字符串数组<code>s</code>的长度是<code>5</code>，小于字符串<code>&quot;hello&quot;</code>的实际长度6，这时编译器会报错。因为如果只将前5个字符写入，而省略最后的结尾符号<code>\0</code>，这很可能导致后面的字符串相关代码出错。</p>
<p>字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异。</p>
<p>第一个差异是，指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span><span style="display:flex;"><span>s[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;z&#39;</span>; <span style="color:#998;font-style:italic">// 错误
</span></span></span></code></pre></div><p>上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错的，会导致难以预测的后果，执行时很可能会报错。</p>
<p>如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span><span style="display:flex;"><span>s[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;z&#39;</span>;
</span></span></code></pre></div><p>**为什么字符串声明为指针时不能修改，声明为数组时就可以修改？**原因是<u>系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改</u>的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</p>
<p>为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用<code>const</code>说明符，保证该字符串是只读的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span></code></pre></div><p>上面字符串声明为指针时，使用了<code>const</code>说明符，就保证了该字符串无法修改。一旦修改，编译器肯定会报错。</p>
<p>第二个差异是，指针变量可以指向其它字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;world&#34;</span>;
</span></span></code></pre></div><p>上面示例中，字符指针可以指向另一个字符串。</p>
<p>但是，字符数组变量不能指向另一个字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;world&#34;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</p>
<p>同样的原因，声明字符数组后，不能直接用字符串赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span>s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;abc&#34;</span>; <span style="color:#998;font-style:italic">// 错误
</span></span></span></code></pre></div><p>上面示例中，不能直接把字符串赋值给字符数组变量，会报错。原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。</p>
<p>**为什么数组变量不能赋值为另一个数组？**原因是<u>数组变量所在的地址无法改变</u>，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。</p>
<p>想要重新赋值，必须使用 C 语言原生提供的<code>strcpy()</code>函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即<code>strcpy()</code>只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(s, <span style="color:#d14">&#34;abc&#34;</span>);
</span></span></code></pre></div><p>上面示例中，<code>strcpy()</code>函数把字符串<code>abc</code>拷贝给变量<code>s</code>，这个函数的详细用法会在后面介绍。</p>
<h3 id="strlen">strlen()</h3>
<p><code>strlen()</code>函数返回字符串的字节长度，不包括末尾的空字符<code>\0</code>。该函数的原型如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// string.h
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">size_t</span> <span style="color:#900;font-weight:bold">strlen</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s);
</span></span></code></pre></div><p>它的参数是字符串变量，返回的是<code>size_t</code>类型的无符号整数，除非是极长的字符串，一般情况下当作<code>int</code>类型处理即可。下面是一个用法实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> str <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> len <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">strlen</span>(str); <span style="color:#998;font-style:italic">// 5
</span></span></span></code></pre></div><p><code>strlen()</code>的原型在标准库的<code>string.h</code>文件中定义，使用时需要加载头文件<code>string.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;The string is %zd characters long.</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">strlen</span>(s));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">50</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">strlen</span>(s));  <span style="color:#998;font-style:italic">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(s));  <span style="color:#998;font-style:italic">// 50
</span></span></span></code></pre></div><p>上面示例中，字符串长度是5，字符串变量长度是50。</p>
<p>如果不使用这个函数，可以通过判断字符串末尾的<code>\0</code>，自己计算字符串长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">my_strlen</span>(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>s) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">while</span> (s[count] <span style="color:#000;font-weight:bold">!=</span> <span style="color:#d14">&#39;\0&#39;</span>)
</span></span><span style="display:flex;"><span>    count<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="strcpy">strcpy()</h3>
<p>字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str1[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str2[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>str1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;abc&#34;</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>str2 <span style="color:#000;font-weight:bold">=</span> str1;  <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面两种字符串的复制写法，都是错的。因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</p>
<p>如果是字符指针，赋值运算符（<code>=</code>）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span>s2 <span style="color:#000;font-weight:bold">=</span> s1;
</span></span></code></pre></div><p>上面代码可以运行，结果是两个指针变量<code>s1</code>和<code>s2</code>指向同一字符串，而不是将字符串<code>s1</code>的内容复制给<code>s2</code>。</p>
<p>C 语言提供了<code>strcpy()</code>函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型定义在<code>string.h</code>头文件里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(<span style="color:#458;font-weight:bold">char</span> dest[], <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span> source[])
</span></span></code></pre></div><p><code>strcpy()</code>接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的<code>const</code>说明符，表示这个函数不会修改第二个字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> s[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello, world!&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> t[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">strcpy</span>(t, s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  t[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;z&#39;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);  <span style="color:#998;font-style:italic">// &#34;Hello, world!&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, t);  <span style="color:#998;font-style:italic">// &#34;zello, world!&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例将变量<code>s</code>的值，拷贝一份放到变量<code>t</code>，变成两个不同的字符串，修改一个不会影响到另一个。另外，变量<code>t</code>的长度大于<code>s</code>，复制后多余的位置（结束标志<code>\0</code>后面的位置）都为随机值。</p>
<p><code>strcpy()</code>也可以用于字符数组的赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(str, <span style="color:#d14">&#34;abcd&#34;</span>);
</span></span></code></pre></div><p>上面示例将字符数组变量，赋值为字符串“abcd”。</p>
<p><code>strcpy()</code>的返回值是一个字符串指针（即<code>char*</code>），指向第一个参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;beast&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[<span style="color:#099">40</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Be the best that you can be.&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> ps;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ps <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">strcpy</span>(s2 <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>, s1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(s2); <span style="color:#998;font-style:italic">// Be the beast
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">puts</span>(ps); <span style="color:#998;font-style:italic">// beast
</span></span></span></code></pre></div><p>上面示例中，从<code>s2</code>的第7个位置开始拷贝字符串<code>beast</code>，前面的位置不变。这导致<code>s2</code>后面的内容都被截去了，因为会连<code>beast</code>结尾的空字符一起拷贝。<code>strcpy()</code>返回的是一个指针，指向拷贝开始的位置。</p>
<p><code>strcpy()</code>返回值的另一个用途，是连续为多个字符数组赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(str1, <span style="color:#900;font-weight:bold">strcpy</span>(str2, <span style="color:#d14">&#34;abcd&#34;</span>));
</span></span></code></pre></div><p>上面示例调用两次<code>strcpy()</code>，完成两个字符串变量的赋值。</p>
<p>另外，<code>strcpy()</code>的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> str;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(str, <span style="color:#d14">&#34;hello world&#34;</span>); <span style="color:#998;font-style:italic">// 错误
</span></span></span></code></pre></div><p>上面的代码是有问题的。<code>strcpy()</code>将字符串分配给指针变量<code>str</code>，但是<code>str</code>并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。</p>
<p>如果不用<code>strcpy()</code>，自己实现字符串的拷贝，可以用下面的代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">strcpy</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> dest, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> source) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> ptr <span style="color:#000;font-weight:bold">=</span> dest;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">while</span> (<span style="color:#000;font-weight:bold">*</span>dest<span style="color:#000;font-weight:bold">++</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>source<span style="color:#000;font-weight:bold">++</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> str[<span style="color:#099">25</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">strcpy</span>(str, <span style="color:#d14">&#34;hello world&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, str);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面代码中，关键的一行是<code>while (*dest++ = *source++)</code>，这是一个循环，依次将<code>source</code>的每个字符赋值给<code>dest</code>，然后移向下一个位置，直到遇到<code>\0</code>，循环判断条件不再为真，从而跳出循环。其中，<code>*dest++</code>这个表达式等同于<code>*(dest++)</code>，即先返回<code>dest</code>这个地址，再进行自增运算移向下一个位置，而<code>*dest</code>可以对当前位置赋值。</p>
<p><code>strcpy()</code>函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用<code>strncpy()</code>函数代替。</p>
<h3 id="strncpy">strncpy()</h3>
<p><code>strncpy()</code>跟<code>strcpy()</code>的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">strncpy</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> dest, 
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> src, 
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">size_t</span> n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>上面原型中，第三个参数<code>n</code>定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符<code>\0</code>，这一点务必注意。如果源字符串的字符数小于<code>n</code>，则<code>strncpy()</code>的行为与<code>strcpy()</code>完全一致。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strncpy</span>(str1, str2, <span style="color:#000;font-weight:bold">sizeof</span>(str1) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>str1[<span style="color:#000;font-weight:bold">sizeof</span>(str1) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;\0&#39;</span>;
</span></span></code></pre></div><p>上面示例中，字符串<code>str2</code>复制给<code>str1</code>，但是复制长度最多为<code>str1</code>的长度减去1，<code>str1</code>剩下的最后一位用于写入字符串的结尾标志<code>\0</code>。这是因为<code>strncpy()</code>不会自己添加<code>\0</code>，如果复制的字符串片段不包含结尾标志，就需要手动添加。</p>
<p><code>strncpy()</code>也可以用来拷贝部分字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s1[<span style="color:#099">40</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[<span style="color:#099">12</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strncpy</span>(s1, s2, <span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span>s1[<span style="color:#099">5</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s1); <span style="color:#998;font-style:italic">// hello
</span></span></span></code></pre></div><p>上面示例中，指定只拷贝前5个字符。</p>
<h3 id="strcat">strcat()</h3>
<p><code>strcat()</code>函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。</p>
<p>该函数的原型定义在<code>string.h</code>头文件里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">strcat</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s2);
</span></span></code></pre></div><p><code>strcat()</code>的返回值是一个字符串指针，指向第一个参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s1[<span style="color:#099">12</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[<span style="color:#099">6</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcat</span>(s1, s2);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(s1); <span style="color:#998;font-style:italic">// &#34;helloworld&#34;
</span></span></span></code></pre></div><p>上面示例中，调用<code>strcat()</code>以后，可以看到字符串<code>s1</code>的值变了。</p>
<p>注意，<code>strcat()</code>的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的<code>strncat()</code>代替。</p>
<h3 id="strncat">strncat()</h3>
<p><code>strncat()</code>用于连接两个字符串，用法与<code>strcat()</code>完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符<code>\0</code>，就不再添加了。它的原型定义在<code>string.h</code>头文件里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">strncat</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> dest,
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> src,
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">size_t</span> n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p><code>strncat()</code>返回第一个参数，即目标字符串指针。</p>
<p>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strncat</span>(
</span></span><span style="display:flex;"><span>  str1, 
</span></span><span style="display:flex;"><span>  str2, 
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">sizeof</span>(str1) <span style="color:#000;font-weight:bold">-</span> <span style="color:#900;font-weight:bold">strlen</span>(str1) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p><code>strncat()</code>总是会在拼接结果的结尾，自动添加空字符<code>\0</code>，所以第三个参数的最大值，应该是<code>str1</code>的变量长度减去<code>str1</code>的字符串长度，再减去<code>1</code>。下面是一个用法实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s1[<span style="color:#099">10</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Monday&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[<span style="color:#099">8</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Tuesday&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strncat</span>(s1, s2, <span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(s1); <span style="color:#998;font-style:italic">// &#34;MondayTue&#34;
</span></span></span></code></pre></div><p>上面示例中，<code>s1</code>的变量长度是10，字符长度是6，两者相减后再减去1，得到<code>3</code>，表明<code>s1</code>最多可以再添加三个字符，所以得到的结果是<code>MondayTue</code>。</p>
<h3 id="strcmp">strcmp()</h3>
<p>如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了<code>strcmp()</code>函数。</p>
<p><code>strcmp()</code>函数用于比较两个字符串的内容。该函数的原型如下，定义在<code>string.h</code>头文件里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">strcmp</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s2);
</span></span></code></pre></div><p>按照字典顺序，如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<p>下面是一个用法示例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// s1 = Happy New Year
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// s2 = Happy New Year
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// s3 = Happy Holidays
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcmp</span>(s1, s2) <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">strcmp</span>(s1, s3) <span style="color:#998;font-style:italic">// 大于 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">strcmp</span>(s3, s1) <span style="color:#998;font-style:italic">// 小于 0
</span></span></span></code></pre></div><p>注意，<code>strcmp()</code>只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（<code>==</code>）就能比较。所以，不要把字符类型（<code>char</code>）的值，放入<code>strcmp()</code>当作参数。</p>
<h3 id="strncmp">strncmp()</h3>
<p>由于<code>strcmp()</code>比较的是整个字符串，C 语言又提供了<code>strncmp()</code>函数，只比较到指定的位置。</p>
<p>该函数增加了第三个参数，指定了比较的字符数。它的原型定义在<code>string.h</code>头文件里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">strncmp</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1,
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s2, 
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">size_t</span> n
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>它的返回值与<code>strcmp()</code>一样。如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s1[<span style="color:#099">12</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[<span style="color:#099">12</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello C&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">strncmp</span>(s1, s2, <span style="color:#099">5</span>) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;They all have hello.</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例只比较两个字符串的前5个字符。</p>
<h3 id="sprintfsnprintf">sprintf()，snprintf()</h3>
<p><code>sprintf()</code>函数跟<code>printf()</code>类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在<code>stdio.h</code>头文件里面。</p>
<pre tabindex="0"><code>int sprintf(char* s, const char* format, ...);
</code></pre><p><code>sprintf()</code>的第一个参数是字符串指针变量，其余参数和<code>printf()</code>相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> first[<span style="color:#099">6</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> last[<span style="color:#099">6</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s[<span style="color:#099">40</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sprintf</span>(s, <span style="color:#d14">&#34;%s %s&#34;</span>, first, last);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s); <span style="color:#998;font-style:italic">// hello world
</span></span></span></code></pre></div><p>上面示例中，<code>sprintf()</code>将输出内容组合成“hello world”，然后放入了变量<code>s</code>。</p>
<p><code>sprintf()</code>的返回值是写入变量的字符数量（不计入尾部的空字符<code>\0</code>）。如果遇到错误，返回负值。</p>
<p><code>sprintf()</code>有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，<code>sprintf()</code>依然会将其写入，导致发生溢出。为了控制写入的字符串的长度，C 语言又提供了另一个函数<code>snprintf()</code>。</p>
<p><code>snprintf()</code>只比<code>sprintf()</code>多了一个参数<code>n</code>，用来控制写入变量的字符串不超过<code>n - 1</code>个字符，剩下一个位置写入空字符<code>\0</code>。下面是它的原型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">snprintf</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>s, <span style="color:#458;font-weight:bold">size_t</span> n, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> format, ...);
</span></span></code></pre></div><p><code>snprintf()</code>总是会自动写入字符串结尾的空字符。如果你尝试写入的字符数超过指定的最大字符数，<code>snprintf()</code>会写入 n - 1 个字符，留出最后一个位置写入空字符。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">snprintf</span>(s, <span style="color:#099">12</span>, <span style="color:#d14">&#34;%s %s&#34;</span>, <span style="color:#d14">&#34;hello&#34;</span>, <span style="color:#d14">&#34;world&#34;</span>);
</span></span></code></pre></div><p>上面的例子中，<code>snprintf()</code>的第二个参数是12，表示写入字符串的最大长度不超过12（包括尾部的空字符）。</p>
<p><code>snprintf()</code>的返回值是写入格式字符串的字符数量（不计入尾部的空字符<code>\0</code>）。如果<code>n</code>足够大，返回值应该小于<code>n</code>，但是有时候格式字符串的长度可能大于<code>n</code>，那么这时返回值会大于<code>n</code>，但实际上真正写入变量的还是<code>n-1</code>个字符。如果遇到错误，返回一个负值。因此，返回值只有在非负并且小于<code>n</code>时，才能确认完整的格式字符串写入了变量。</p>
<h3 id="字符串数组">字符串数组</h3>
<p>如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> weekdays[<span style="color:#099">7</span>][<span style="color:#099">10</span>] <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Monday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Tuesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Wednesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Thursday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Friday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Saturday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Sunday&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符<code>\0</code>），所以第二维的长度统一设为10。</p>
<p>因为第一维的长度，编译器可以自动计算，所以可以省略。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> weekdays[][<span style="color:#099">10</span>] <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Monday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Tuesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Wednesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Thursday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Friday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Saturday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Sunday&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。</p>
<p>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是把数组的第二维，从字符数组改成字符指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> weekdays[] <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Monday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Tuesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Wednesday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Thursday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Friday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Saturday&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#d14">&#34;Sunday&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</p>
<p>遍历字符串数组的写法如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">7</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, weekdays[i]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="内存管理">内存管理</h2>
<h3 id="简介-4">简介</h3>
<p>C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。</p>
<p>系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），<strong>”栈“所在的内存是系统自动管理</strong>的。</p>
<p>用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），<strong>”堆“所在的内存是用户手动管理</strong>的。</p>
<h3 id="void-指针">void 指针</h3>
<p>每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。</p>
<p>为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。</p>
<p>另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>x; <span style="color:#998;font-style:italic">// 整数指针转为 void 指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> q <span style="color:#000;font-weight:bold">=</span> p; <span style="color:#998;font-style:italic">// void 指针转为整数指针
</span></span></span></code></pre></div><p>上面示例演示了，整数指针和 void 指针如何互相转换。<code>&amp;x</code>是一个整数指针，<code>p</code>是 void 指针，赋值时<code>&amp;x</code>的地址会自动解释为 void 类型。同样的，<code>p</code>再赋值给整数指针<code>q</code>时，<code>p</code>的地址会自动解释为整数指针。</p>
<p>注意，由于不知道 void 指针指向什么类型的值，所以不能用<code>*</code>运算符取出它指向的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;X&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%c</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>p); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>p</code>是一个 void 指针，所以这时无法用<code>*p</code>取出指针指向的值。</p>
<p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息，所以放在最前面进行介绍。</p>
<h3 id="malloc">malloc()</h3>
<p><code>malloc()</code>函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 接受一个非负整数作为参数，表示所要分配的内存字节数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 返回一个 void 指针，指向分配好的内存块
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// malloc()函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#458;font-weight:bold">size_t</span> size)
</span></span></code></pre></div><p>可以使用<code>malloc()</code>为任意类型的数据分配内存，常见的做法是先使用<code>sizeof()</code>函数，算出某种数据类型所需的字节长度，然后再将这个长度传给<code>malloc()</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">12</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>p); <span style="color:#998;font-style:italic">// 12
</span></span></span></code></pre></div><p>上面示例中，先为整数类型分配一段内存，然后将整数<code>12</code>放入这段内存里面。这个例子其实不需要使用<code>malloc()</code>，因为 C 语言会自动为整数（本例是<code>12</code>）提供内存。</p>
<p>有时候为了增加代码的可读性，可以对<code>malloc()</code>返回的指针进行一次强制类型转换。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span></code></pre></div><p>上面代码将<code>malloc()</code>返回的 void 指针，强制转换成了整数指针。</p>
<p>由于<code>sizeof()</code>的参数可以是变量，所以上面的例子也可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">*</span>p));
</span></span></code></pre></div><p><code>malloc()</code>分配内存有可能分配失败，这时返回常量<code>NULL</code>。<code>Null</code>的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括<code>stdlib.h</code>等多个头文件里面都有定义，所以只要可以使用<code>malloc()</code>，就可以使用<code>NULL</code>。由于存在分配失败的可能，所以最好在使用<code>malloc()</code>之后检查一下，是否分配成功。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (p <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// 内存分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// or
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>p) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">//...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，通过判断返回的指针<code>p</code>是否为<code>NULL</code>，确定<code>malloc()</code>是否分配成功。</p>
<p><code>malloc()</code>最常用的场合，就是为数组和自定义数据结构分配内存。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10</span>; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>  p[i] <span style="color:#000;font-weight:bold">=</span> i <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">5</span>;
</span></span></code></pre></div><p>上面示例中，<code>p</code>是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。</p>
<p><code>malloc()</code>用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(n <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span></code></pre></div><p>上面示例中，<code>malloc()</code>可以根据变量<code>n</code>的不同，动态为数组分配不同的大小。</p>
<p>注意，<code>malloc()</code>不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用<code>strcpy()</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#099">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(p, <span style="color:#d14">&#34;abc&#34;</span>);
</span></span></code></pre></div><p>上面示例中，字符指针<code>p</code>指向一段4个字节的内存，<code>strcpy()</code>将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。</p>
<h3 id="free">free()</h3>
<p><code>free()</code>用于释放<code>malloc()</code>函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">free</span>(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> block)
</span></span></code></pre></div><p>上面代码中，<code>free()</code>的参数是<code>malloc()</code>返回的内存地址。下面就是用法实例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">12</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">free</span>(p);
</span></span></code></pre></div><p>注意，分配的内存块一旦释放，不应该再次操作已经释放的地址，也不应该再次使用<code>free()</code>对该地址释放第二次</p>
<p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用<code>free()</code>释放内存。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">gobble</span>(<span style="color:#458;font-weight:bold">double</span> arr[], <span style="color:#458;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">double</span><span style="color:#000;font-weight:bold">*</span> temp <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">double</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(n <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">double</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面示例中，函数<code>gobble()</code>内部分配了内存，但是没有写<code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用<code>gobble()</code>，就会留下多个内存块。并且，由于指针<code>temp</code>已经消失了，也无法访问这些内存块，再次使用。</p>
<h3 id="calloc">calloc()</h3>
<p><code>calloc()</code>函数的作用与<code>malloc()</code>相似，也是分配内存块。该函数的原型定义在头文件<code>stdlib.h</code>。</p>
<p>两者的区别主要有两点：</p>
<p>（1）<code>calloc()</code>接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">calloc</span>(<span style="color:#458;font-weight:bold">size_t</span> n, <span style="color:#458;font-weight:bold">size_t</span> size);
</span></span></code></pre></div><p><code>calloc()</code>的返回值也是一个 void 指针。分配失败时，返回NULL</p>
<p>（2）<code>calloc()</code>会将所分配的内存全部初始化为<code>0</code>。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为<code>0</code>，还要额外调用<code>memset()</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">calloc</span>(<span style="color:#099">10</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">memset</span>(p, <span style="color:#099">0</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">10</span>);
</span></span></code></pre></div><p>上面示例中，<code>calloc()</code>相当于<code>malloc() + memset()</code>。</p>
<p><code>calloc()</code>分配的内存块，也要使用<code>free()</code>释放。</p>
<h3 id="realloc">realloc()</h3>
<p><code>realloc()</code>函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。该函数的原型定义在头文件<code>stdlib.h</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">realloc</span>(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> block, <span style="color:#458;font-weight:bold">size_t</span> size)
</span></span></code></pre></div><p>它接受两个参数。</p>
<ul>
<li><code>block</code>：已经分配好的内存块指针（由<code>malloc()</code>或<code>calloc()</code>或<code>realloc()</code>产生）。</li>
<li><code>size</code>：该内存块的新大小，单位为字节。</li>
</ul>
<p><code>realloc()</code>可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code>优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用<code>memset()</code>）。</p>
<p>下面是一个例子，<code>b</code>是数组指针，<code>realloc()</code>动态调整它的大小。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">10</span>);
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">realloc</span>(b, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">2000</span>);
</span></span></code></pre></div><p>上面示例中，指针<code>b</code>原来指向10个成员的整数数组，使用<code>realloc()</code>调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。</p>
<p><code>realloc()</code>的第一个参数可以是 NULL，这时就相当于新建一个指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">realloc</span>(<span style="color:#0086b3">NULL</span>, <span style="color:#099">3490</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#099">3490</span>);
</span></span></code></pre></div><p>如果<code>realloc()</code>的第二个参数是<code>0</code>，就会释放掉内存块。</p>
<p>由于有分配失败的可能，所以调用<code>realloc()</code>以后，最好检查一下它的返回值是否为 NULL。分配失败时，原有内存块中的数据不会发生改变。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span><span style="color:#000;font-weight:bold">*</span> new_p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">realloc</span>(p, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">40</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (new_p <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Error reallocing</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，<code>realloc()</code>不会对内存块进行初始化。</p>
<h3 id="restrict-说明符">restrict 说明符</h3>
<p>声明指针变量时，可以使用<code>restrict</code>说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> p;
</span></span><span style="display:flex;"><span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span></code></pre></div><p>上面示例中，声明指针变量<code>p</code>时，加入了<code>restrict</code>说明符，使得<code>p</code>变成了受限指针。后面，当<code>p</code>指向<code>malloc()</code>函数返回的一块内存区域，就意味着，该区域只有通过<code>p</code>来访问，不存在其他访问方式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> p;
</span></span><span style="display:flex;"><span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> q <span style="color:#000;font-weight:bold">=</span> p;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>q <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; <span style="color:#998;font-style:italic">// 未定义行为
</span></span></span></code></pre></div><p>上面示例中，另一个指针<code>q</code>与受限指针<code>p</code>指向同一块内存，现在该内存有<code>p</code>和<code>q</code>两种访问方式。这就违反了对编译器的承诺，后面通过<code>*q</code>对该内存区域赋值，会导致未定义行为。</p>
<h3 id="memcpy">memcpy()</h3>
<p><code>memcpy()</code>用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件<code>string.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">memcpy</span>(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> dest, <span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> source, <span style="color:#458;font-weight:bold">size_t</span> n);
</span></span></code></pre></div><p>上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，第三个参数<code>n</code>是要拷贝的字节数<code>n</code>。如果要拷贝10个 double 类型的数组成员，<code>n</code>就等于<code>10 * sizeof(double)</code>，而不是<code>10</code>。该函数会将从<code>source</code>开始的<code>n</code>个字节，拷贝到<code>dest</code></p>
<p><code>dest</code>和<code>source</code>都是 void 指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</p>
<p><code>memcpy()</code>的返回值是第一个参数，即目标地址的指针。</p>
<p>因为<code>memcpy()</code>只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。下面是复制字符串的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> s[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Goats!&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> t[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">memcpy</span>(t, s, <span style="color:#000;font-weight:bold">sizeof</span>(s));  <span style="color:#998;font-style:italic">// 拷贝7个字节，包括终止符
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, t);  <span style="color:#998;font-style:italic">// &#34;Goats!&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，字符串<code>s</code>所在的内存，被拷贝到字符数组<code>t</code>所在的内存。</p>
<p><code>memcpy()</code>可以取代<code>strcpy()</code>进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，它不检查字符串尾部的<code>\0</code>字符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">size_t</span> len <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">strlen</span>(s) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>c <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (c) {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// strcpy() 的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">strcpy</span>(c, s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// memcpy() 的写法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#900;font-weight:bold">memcpy</span>(c, s, len);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，两种写法的效果完全一样，但是<code>memcpy()</code>的写法要好于<code>strcpy()</code>。</p>
<p>使用 void 指针，也可以自定义一个复制内存的函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">my_memcpy</span>(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> dest, <span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> src, <span style="color:#458;font-weight:bold">int</span> byte_count) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> src;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> d <span style="color:#000;font-weight:bold">=</span> dest;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">while</span> (byte_count<span style="color:#000;font-weight:bold">--</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">*</span>d<span style="color:#000;font-weight:bold">++</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>s<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> dest;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，不管传入的<code>dest</code>和<code>src</code>是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制。<code>*d++ = *s++</code>语句相当于先执行<code>*d = *s</code>（源字节的值复制给目标字节），然后各自移动到下一个字节。最后，返回复制后的<code>dest</code>指针，便于后续使用。</p>
<h3 id="memmove">memmove()</h3>
<p><code>memmove()</code>函数用于将一段内存数据复制到另一段内存。它跟<code>memcpy()</code>的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与<code>memcpy()</code>行为相同。</p>
<p>该函数的原型定义在头文件<code>string.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">memmove</span>(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> dest, <span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> source, <span style="color:#458;font-weight:bold">size_t</span> n);
</span></span></code></pre></div><p>上面代码中，<code>dest</code>是目标地址，<code>source</code>是源地址，<code>n</code>是要移动的字节数。<code>dest</code>和<code>source</code>都是 void 指针，表示可以移动任何类型的内存数据，两个内存区域可以有重叠。</p>
<p><code>memmove()</code>返回值是第一个参数，即目标地址的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">memmove</span>(<span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">0</span>], <span style="color:#000;font-weight:bold">&amp;</span>a[<span style="color:#099">1</span>], <span style="color:#099">99</span> <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span></code></pre></div><p>上面示例中，从数组成员<code>a[1]</code>开始的99个成员，都向前移动一个位置。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> x[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Home Sweet Home&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 输出 Sweet Home Home
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, (<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">memmove</span>(x, <span style="color:#000;font-weight:bold">&amp;</span>x[<span style="color:#099">5</span>], <span style="color:#099">10</span>));
</span></span></code></pre></div><p>上面示例中，从字符串<code>x</code>的5号位置开始的10个字节，就是“Sweet Home”，<code>memmove()</code>将其前移到0号位置，所以<code>x</code>就变成了“Sweet Home Home”。</p>
<h3 id="memcmp">memcmp()</h3>
<p><code>memcmp()</code>函数用来比较两个内存区域。它的原型定义在<code>string.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">memcmp</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> s1, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span> s2, <span style="color:#458;font-weight:bold">size_t</span> n);
</span></span></code></pre></div><p>它接受三个参数，前两个参数是用来比较的指针，第三个参数指定比较的字节数。</p>
<p>它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回<code>0</code>；如果<code>s1</code>大于<code>s2</code>，返回大于0的整数；如果<code>s1</code>小于<code>s2</code>，返回小于0的整数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;acd&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> r <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">memcmp</span>(s1, s2, <span style="color:#099">3</span>); <span style="color:#998;font-style:italic">// 小于 0
</span></span></span></code></pre></div><p>上面示例比较<code>s1</code>和<code>s2</code>的前三个字节，由于<code>s1</code>小于<code>s2</code>，所以<code>r</code>是一个小于0的整数，一般为-1。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s1[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#39;b&#39;</span>, <span style="color:#d14">&#39;i&#39;</span>, <span style="color:#d14">&#39;g&#39;</span>, <span style="color:#d14">&#39;\0&#39;</span>, <span style="color:#d14">&#39;c&#39;</span>, <span style="color:#d14">&#39;a&#39;</span>, <span style="color:#d14">&#39;r&#39;</span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> s2[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#39;b&#39;</span>, <span style="color:#d14">&#39;i&#39;</span>, <span style="color:#d14">&#39;g&#39;</span>, <span style="color:#d14">&#39;\0&#39;</span>, <span style="color:#d14">&#39;c&#39;</span>, <span style="color:#d14">&#39;a&#39;</span>, <span style="color:#d14">&#39;t&#39;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">memcmp</span>(s1, s2, <span style="color:#099">3</span>) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">memcmp</span>(s1, s2, <span style="color:#099">4</span>) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">memcmp</span>(s1, s2, <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) <span style="color:#998;font-style:italic">// false
</span></span></span></code></pre></div><p>上面示例展示了，<code>memcmp()</code>可以比较内部带有字符串终止符<code>\0</code>的内存区域。</p>
<h2 id="结构体">结构体</h2>
<h3 id="简介-5">简介</h3>
<p>C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p>
<p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p>
<ul>
<li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来</li>
<li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入</li>
</ul>
<p>为了解决这些问题，C 语言提供了<code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，<code>struct</code>结构很大程度上提供了对象和类的功能。</p>
<p>下面是<code>struct</code>自定义数据类型的一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> fraction {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> numerator;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> denominator;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例定义了一个分数的数据类型<code>struct fraction</code>，包含两个属性<code>numerator</code>和<code>denominator</code>。</p>
<p>注意，作为一个自定义的数据类型，它的类型名要包括<code>struct</code>关键字，比如上例是<code>struct fraction</code>，单独的<code>fraction</code>没有任何意义，甚至脚本还可以另外定义名为<code>fraction</code>的变量，虽然这样很容易造成混淆。另外，<code>struct</code>语句结尾的分号不能省略，否则很容易产生错误。</p>
<p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> fraction f1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>f1.numerator <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">22</span>;
</span></span><span style="display:flex;"><span>f1.denominator <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>;
</span></span></code></pre></div><p>上面示例中，先声明了一个<code>struct fraction</code>类型的变量<code>f1</code>，这时编译器就会为<code>f1</code>分配内存，接着就可以为<code>f1</code>的不同属性赋值。可以看到，<code>struct</code> 结构的属性通过点（<code>.</code>）来表示，比如<code>numerator</code>属性要写成<code>f1.numerator</code>。</p>
<p>再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上<code>struct</code>关键字。也就是说，必须使用<code>struct fraction f1</code>声明变量，不能写成<code>fraction f1</code>。</p>
<p>除了逐一对属性赋值，也可以使用大括号，一次性对<code>struct</code>结构的所有属性赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> car {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> price;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> speed;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> car saturn <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;Saturn SL/2&#34;</span>, <span style="color:#099">16000.99</span>, <span style="color:#099">175</span>};
</span></span></code></pre></div><p>上面示例中，变量<code>saturn</code>是<code>struct car</code>类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为<code>0</code>。</p>
<p>注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> car saturn <span style="color:#000;font-weight:bold">=</span> {.speed<span style="color:#000;font-weight:bold">=</span><span style="color:#099">172</span>, .name<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;Saturn SL/2&#34;</span>};
</span></span></code></pre></div><p>上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为<code>0</code>。</p>
<p>声明变量以后，可以修改某个属性的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> car saturn <span style="color:#000;font-weight:bold">=</span> {.speed<span style="color:#000;font-weight:bold">=</span><span style="color:#099">172</span>, .name<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;Saturn SL/2&#34;</span>};
</span></span><span style="display:flex;"><span>saturn.speed <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">168</span>;
</span></span></code></pre></div><p>上面示例将<code>speed</code>属性的值改成<code>168</code>。</p>
<p><code>struct</code>的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> book {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> title[<span style="color:#099">500</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> author[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> value;
</span></span><span style="display:flex;"><span>} b1;
</span></span></code></pre></div><p>上面的语句同时声明了数据类型<code>book</code>和该类型的变量<code>b1</code>。如果类型标识符<code>book</code>只用在这一个地方，后面不再用到，这里可以将类型名省略。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> title[<span style="color:#099">500</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> author[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> value;
</span></span><span style="display:flex;"><span>} b1;
</span></span></code></pre></div><p>上面示例中，<code>struct</code>声明了一个匿名数据类型，然后又声明了这个类型的变量<code>b1</code>。</p>
<p>与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> title[<span style="color:#099">500</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> author[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> value;
</span></span><span style="display:flex;"><span>} b1 <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;Harry Potter&#34;</span>, <span style="color:#d14">&#34;J. K. Rowling&#34;</span>, <span style="color:#099">10.0</span>},
</span></span><span style="display:flex;"><span>  b2 <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;Cancer Ward&#34;</span>, <span style="color:#d14">&#34;Aleksandr Solzhenitsyn&#34;</span>, <span style="color:#099">7.85</span>};
</span></span></code></pre></div><p>上面示例中，在声明变量<code>b1</code>和<code>b2</code>的同时，为它们赋值。</p>
<p><code>typedef</code>命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> cell_phone {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> cell_no;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> minutes_of_charge;
</span></span><span style="display:flex;"><span>} phone;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>phone p <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">5551234</span>, <span style="color:#099">5</span>};
</span></span></code></pre></div><p>上面示例中，<code>phone</code>就是<code>struct cell_phone</code>的别名。</p>
<p>指针变量也可以指向<code>struct</code>结构。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> book {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> title[<span style="color:#099">500</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> author[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> value;
</span></span><span style="display:flex;"><span>}<span style="color:#000;font-weight:bold">*</span> b1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 或者写成两个语句
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> book {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> title[<span style="color:#099">500</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> author[<span style="color:#099">100</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> book<span style="color:#000;font-weight:bold">*</span> b1;
</span></span></code></pre></div><p>上面示例中，变量<code>b1</code>是一个指针，指向的数据是<code>struct book</code>类型的实例。</p>
<p>struct 结构也可以作为数组成员。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> fraction numbers[<span style="color:#099">1000</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>numbers[<span style="color:#099">0</span>].numerator <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">22</span>;
</span></span><span style="display:flex;"><span>numbers[<span style="color:#099">0</span>].denominator <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>;
</span></span></code></pre></div><p>上面示例声明了一个有1000个成员的数组<code>numbers</code>，每个成员都是自定义类型<code>fraction</code>的实例。</p>
<p><code>struct</code>结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> foo {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> c;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> foo)); <span style="color:#998;font-style:italic">// 24
</span></span></span></code></pre></div><p>上面示例中，<code>struct foo</code>有三个属性，在64位计算机上占用的存储空间分别是：<code>int a</code>占4个字节，指针<code>char* b</code>占8个字节，<code>char c</code>占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，<code>struct foo</code>会占用24个字节，原因是它最大的内存占用属性是<code>char* b</code>的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个<code>struct foo</code>就是24个字节（8 * 3）。</p>
<p>多出来的存储空间，都采用空位填充，所以上面的<code>struct foo</code>真实的结构其实是下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> foo {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a;        <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#458;font-weight:bold">char</span> pad1[<span style="color:#099">4</span>]; <span style="color:#998;font-style:italic">// 填充4字节
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>b;      <span style="color:#998;font-style:italic">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#458;font-weight:bold">char</span> c;       <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#458;font-weight:bold">char</span> pad2[<span style="color:#099">7</span>]; <span style="color:#998;font-style:italic">// 填充7字节
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> foo)); <span style="color:#998;font-style:italic">// 24
</span></span></span></code></pre></div><p>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在结构体中定位到每个属性的起始地址。</p>
<p>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> foo {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> c;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> b;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> foo)); <span style="color:#998;font-style:italic">// 16
</span></span></span></code></pre></div><p>上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p>
<p>C 语言中，可以使用<code>sizeof</code>运算符来计算结构体的大小，<code>sizeof</code>返回的是给定类型或变量的字节大小。对于结构体，<code>sizeof</code>将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。</p>
<p><strong>注意</strong>，结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用<code>offsetof</code>宏和<code>__attribute__((packed))</code>属性等进一步控制和查询结构体的大小和对齐方式。</p>
<p><strong>结构体内存大小对齐原则</strong></p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除。</li>
<li>结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)。即结构体成员的末地址减去结构体首地址(第一个结构体成员的首地址)得到的偏移量都要是对应成员大小的整数倍。</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在成员末尾加上填充字节。</li>
</ol>
<p>结构体内存对齐的规则很简单：</p>
<p>​    一、成员变量内存相对起始位置为数据类型所占内存的整数倍（例如：int 类型数据相对起始位置必须是结构体中4字节的整数倍），若不足则需要对齐不足部分的内存(内存补充给前一个变量)。</p>
<p>​    二、结构体所占总内存为其成员变量中所占空间最大数据类型的整数倍。</p>
<p>​    三、结构体中每个成员相对于结构体起始地址的偏移量必须是该成员大小的倍数。</p>
<p>其中，最宽基本类型指的是 long double、double 和 long long 中占用空间最大的类型。如果结构体中没有这些类型的成员，则以 int 或者 char 作为最宽基本类型。</p>
<p>结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样成员变量的存储空间也是不能跨分配单位的,如果当前的空间不足,则会存储到下一个分配单位中。</p>
<p><strong>结构体内存分配原则</strong></p>
<p><strong>原则一</strong>：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。</p>
<p><strong>原则二</strong>： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> t1{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> z;
</span></span><span style="display:flex;"><span>}T1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> t2{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">double</span> z;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> y;
</span></span><span style="display:flex;"><span>}T2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof(T1) = %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(T1));
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof(T2) = %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(T2));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>解析</strong></p>
<pre tabindex="0"><code>sizeof(T1.x) = sizeof(T2.x) = 1; 
sizeof(T1.y) = sizeof(T2.y) = 4; 
sizeof(T1.z) = sizeof(T2.z) = 8;
</code></pre><p><strong>T1</strong>: 若从第 0 个字节开始分配内存，则 T1.x 存入第 0 字节，T1.y 占 4 个字节，由于第一的 4 字节已有数据，所以 T1.y 存入第 4-7 个字节，T1.z 占 8 个字节，由于第一个 8 字节已有数据，所以 T1.z 存入 8-15 个字节。共占有 16 个字节。</p>
<p><strong>T2</strong>: 若从第 0 个字节开始分配内存，则 T1.x 存入第 0 字节，T1.z 占 8 个字节，由于第一的 8 字节已有数据，所以 T1.z 存入第 8-15 个字节，T1.y 占 4 个字节，由于前四个 4 字节已有数据，所以 T1.z 存入 16-19 个字节。共占有 20 个字节。此时所占字节不是最宽元素（double 长度为 8）的整数倍，因此将其补齐到 8 的整数倍，最终结果为 24。</p>
<h3 id="struct-的复制">struct 的复制</h3>
<p><code>struct</code>变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> cat { <span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">30</span>]; <span style="color:#458;font-weight:bold">short</span> age; } a, b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(a.name, <span style="color:#d14">&#34;Hula&#34;</span>);
</span></span><span style="display:flex;"><span>a.age <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> a;
</span></span><span style="display:flex;"><span>b.name[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, a.name); <span style="color:#998;font-style:italic">// Hula
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, b.name); <span style="color:#998;font-style:italic">// Mula
</span></span></span></code></pre></div><p>上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p>
<p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> cat { <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name; <span style="color:#458;font-weight:bold">short</span> age; } a, b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a.name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hula&#34;</span>;
</span></span><span style="display:flex;"><span>a.age <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b <span style="color:#000;font-weight:bold">=</span> a;
</span></span></code></pre></div><p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，<code>struct</code>结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p>
<p>总结一下，赋值运算符（<code>=</code>）可以将<code>struct</code>结构每个属性的值，一模一样复制一份，拷贝给另一个<code>struct</code>变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</p>
<p>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</p>
<p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p>
<h3 id="struct-指针">struct 指针</h3>
<p>如果将<code>struct</code>变量传入函数，函数内部得到的是一个原始值的副本。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> turtle {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> species;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> age;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">happy</span>(<span style="color:#000;font-weight:bold">struct</span> turtle t) {
</span></span><span style="display:flex;"><span>  t.age <span style="color:#000;font-weight:bold">=</span> t.age <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">struct</span> turtle myTurtle <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;MyTurtle&#34;</span>, <span style="color:#d14">&#34;sea turtle&#34;</span>, <span style="color:#099">99</span>};
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">happy</span>(myTurtle);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Age is %i</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, myTurtle.age); <span style="color:#998;font-style:italic">// 输出 99
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数<code>happy()</code>传入的是一个<code>struct</code>变量<code>myTurtle</code>，函数内部有一个自增操作。但是，执行完<code>happy()</code>以后，函数外部的<code>age</code>属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。</p>
<p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p>
<p>struct 指针传入函数的写法如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">happy</span>(<span style="color:#000;font-weight:bold">struct</span> turtle<span style="color:#000;font-weight:bold">*</span> t) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">happy</span>(<span style="color:#000;font-weight:bold">&amp;</span>myTurtle);
</span></span></code></pre></div><p>上面代码中，<code>t</code>是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成<code>&amp;myTurtle</code>。</p>
<p>函数内部也必须使用<code>(*t).age</code>的写法，从指针拿到 struct 结构本身。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">happy</span>(<span style="color:#000;font-weight:bold">struct</span> turtle<span style="color:#000;font-weight:bold">*</span> t) {
</span></span><span style="display:flex;"><span>  (<span style="color:#000;font-weight:bold">*</span>t).age <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">*</span>t).age <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符<code>.</code>的优先级高于<code>*</code>。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p>
<p>现在，重新编译执行上面的整个示例，<code>happy()</code>内部对 struct 结构的操作，就会反映到函数外部。</p>
<p><code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（<code>-&gt;</code>），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">happy</span>(<span style="color:#000;font-weight:bold">struct</span> turtle<span style="color:#000;font-weight:bold">*</span> t) {
</span></span><span style="display:flex;"><span>  t<span style="color:#000;font-weight:bold">-&gt;</span>age <span style="color:#000;font-weight:bold">=</span> t<span style="color:#000;font-weight:bold">-&gt;</span>age <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结一下，对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。以变量<code>myStruct</code>为例，假设<code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// ptr == &amp;myStruct
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>myStruct.prop <span style="color:#000;font-weight:bold">==</span> (<span style="color:#000;font-weight:bold">*</span>ptr).prop <span style="color:#000;font-weight:bold">==</span> ptr<span style="color:#000;font-weight:bold">-&gt;</span>prop
</span></span></code></pre></div><h3 id="struct-的嵌套">struct 的嵌套</h3>
<p>struct 结构的成员可以是另一个 struct 结构。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> species {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> kinds;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> fish {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> age;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">struct</span> species breed;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，<code>fish</code>的属性<code>breed</code>是另一个 struct 结构<code>species</code>。</p>
<p>赋值的时候有多种写法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> fish shark <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;shark&#34;</span>, <span style="color:#099">9</span>, {<span style="color:#d14">&#34;Selachimorpha&#34;</span>, <span style="color:#099">500</span>}};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> species myBreed <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;Selachimorpha&#34;</span>, <span style="color:#099">500</span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> fish shark <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;shark&#34;</span>, <span style="color:#099">9</span>, myBreed};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法三
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> fish shark <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  .name<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;shark&#34;</span>,
</span></span><span style="display:flex;"><span>  .age<span style="color:#000;font-weight:bold">=</span><span style="color:#099">9</span>,
</span></span><span style="display:flex;"><span>  .breed<span style="color:#000;font-weight:bold">=</span>{<span style="color:#d14">&#34;Selachimorpha&#34;</span>, <span style="color:#099">500</span>}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法四
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> fish shark <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>  .name<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;shark&#34;</span>,
</span></span><span style="display:flex;"><span>  .age<span style="color:#000;font-weight:bold">=</span><span style="color:#099">9</span>,
</span></span><span style="display:flex;"><span>  .breed.name<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;Selachimorpha&#34;</span>,
</span></span><span style="display:flex;"><span>  .breed.kinds<span style="color:#000;font-weight:bold">=</span><span style="color:#099">500</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Shark&#39;s species is %s&#34;</span>, shark.breed.name);
</span></span></code></pre></div><p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p>
<p>下面是另一个嵌套 struct 的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> name {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> first[<span style="color:#099">50</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> last[<span style="color:#099">50</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> student {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">struct</span> name name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">short</span> age;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> sex;
</span></span><span style="display:flex;"><span>} student1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(student1.name.first, <span style="color:#d14">&#34;Harry&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">strcpy</span>(student1.name.last, <span style="color:#d14">&#34;Potter&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// or
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> name myname <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;Harry&#34;</span>, <span style="color:#d14">&#34;Potter&#34;</span>};
</span></span><span style="display:flex;"><span>student1.name <span style="color:#000;font-weight:bold">=</span> myname;
</span></span></code></pre></div><p>上面示例中，自定义类型<code>student</code>的<code>name</code>属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个<code>.</code>运算符，比如<code>student1.name.first</code>。另外，对字符数组属性赋值，要使用<code>strcpy()</code>函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</p>
<p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> node {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">struct</span> node<span style="color:#000;font-weight:bold">*</span> next;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>示例中，<code>node</code>结构的<code>next</code>属性，就是指向另一个<code>node</code>实例的指针。下面，使用这个结构自定义一个数据链表</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> node {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">struct</span> node<span style="color:#000;font-weight:bold">*</span> next;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> node<span style="color:#000;font-weight:bold">*</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 生成一个三个节点的列表 (11) -&gt; (22) -&gt; (33)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>head <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> node));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">11</span>;
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>next <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> node));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">22</span>;
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>next <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> node));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">33</span>;
</span></span><span style="display:flex;"><span>head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>next <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 遍历这个列表
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">for</span> (<span style="color:#000;font-weight:bold">struct</span> node <span style="color:#000;font-weight:bold">*</span>cur <span style="color:#000;font-weight:bold">=</span> head; cur <span style="color:#000;font-weight:bold">!=</span> <span style="color:#0086b3">NULL</span>; cur <span style="color:#000;font-weight:bold">=</span> cur<span style="color:#000;font-weight:bold">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, cur<span style="color:#000;font-weight:bold">-&gt;</span>data);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例是链表结构的最简单实现，通过<code>for</code>循环可以对其进行遍历。</p>
<h3 id="位字段">位字段</h3>
<p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ab</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">cd</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ef</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">gh</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>} synth;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>synth.ab <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>synth.cd <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span></code></pre></div><p>示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p>
<p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p>
<p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">field1</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span>        <span style="color:#000;font-weight:bold">:</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">field2</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span>        <span style="color:#000;font-weight:bold">:</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">field3</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>} stuff;
</span></span></code></pre></div><p>示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p>
<h3 id="弹性数组成员">弹性数组成员</h3>
<p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p>
<p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> vstring {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> len;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> chars[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</p>
<p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> vstring<span style="color:#000;font-weight:bold">*</span> str <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> vstring) <span style="color:#000;font-weight:bold">+</span> n <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">char</span>));
</span></span><span style="display:flex;"><span>str<span style="color:#000;font-weight:bold">-&gt;</span>len <span style="color:#000;font-weight:bold">=</span> n;
</span></span></code></pre></div><p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p>
<p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p>
<p>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</p>
<p>利用结构体的特性，实现柔性数组。</p>
<p>先看特性：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> text1 {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> num;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> arr[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> text2 {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> num;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> text1 t1;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> text2 t2;
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;结构体text1的大小为:%d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(t1));
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;结构体text2的大小为:%d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(t2));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此程序输出的结果为：</p>
<p>结构体text1的大小为:24 结构体text2的大小为:24</p>
<p>从结果可以看出，第一个结构体比第二个结构体多了一个参数 int arr[]，但最后的结果确实两个结构体的大小相同。可以说明，在计算结构体时，如果结构体中存在未给定长度的数组，那么在计算时，将会忽略这个数组。</p>
<p>下面代码将演示如何实现柔性数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> text1 {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> num;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> arr[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> text1 <span style="color:#000;font-weight:bold">*</span>t1;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//期望arr是10个整形数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> arrNum <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>    t1 <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> text1<span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> text1)<span style="color:#000;font-weight:bold">+</span>arrNum<span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));<span style="color:#998;font-style:italic">//给arr数组分配空间,申请（原数据结构的大小+arr数组的大小）
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    t1<span style="color:#000;font-weight:bold">-&gt;</span>num <span style="color:#000;font-weight:bold">=</span> arrNum;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//此时，就已经完成为数组arr分配空间,使用num来记录一下分配的个数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>     
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//如果在使用中arr数组个数不足，需要开辟更大的空间
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> addNum <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> text1 <span style="color:#000;font-weight:bold">*</span>pstruct<span style="color:#000;font-weight:bold">=</span><span style="color:#900;font-weight:bold">realloc</span>(t1,<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> text1)<span style="color:#000;font-weight:bold">+</span>(t1<span style="color:#000;font-weight:bold">-&gt;</span>num<span style="color:#000;font-weight:bold">+</span>addNum)<span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (pstruct<span style="color:#000;font-weight:bold">!=</span><span style="color:#0086b3">NULL</span>) {<span style="color:#998;font-style:italic">//为了防止开辟空间失败导致空间丢失
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        t1 <span style="color:#000;font-weight:bold">=</span> pstruct;
</span></span><span style="display:flex;"><span>        t1<span style="color:#000;font-weight:bold">-&gt;</span>num <span style="color:#000;font-weight:bold">+=</span> addNum;
</span></span><span style="display:flex;"><span>        pstruct <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//给数组赋值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;=</span> t1<span style="color:#000;font-weight:bold">-&gt;</span>num <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>;i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        t1<span style="color:#000;font-weight:bold">-&gt;</span>arr[i] <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//打印数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;=</span> t1<span style="color:#000;font-weight:bold">-&gt;</span>num <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>;i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>,t1<span style="color:#000;font-weight:bold">-&gt;</span>arr[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//销毁数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">free</span>(t1);
</span></span><span style="display:flex;"><span>    t1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>读者乍一看，可能感觉这样的作用不大，如果我们把数组换为其他数组类型呢？比如结构体</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> peoInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> age;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> addr[<span style="color:#099">50</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> tele[<span style="color:#099">12</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> ContractPeo {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> peoInfo<span style="color:#000;font-weight:bold">*</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> sz;<span style="color:#998;font-style:italic">//联系人数量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> zone;<span style="color:#998;font-style:italic">//通讯录总空间大小
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}con;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//初始化通讯录
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> initNum <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">20</span>;
</span></span><span style="display:flex;"><span>    con.data <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> data<span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> peoInfo)<span style="color:#000;font-weight:bold">+</span>initNum<span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span><span style="display:flex;"><span>    con.zone <span style="color:#000;font-weight:bold">=</span> initNum;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//添加联系人,假如我们已经添加了20个联系人，达到了空间的上限，就需要开辟新的空间
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    con.sz <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">20</span>;<span style="color:#998;font-style:italic">//联系人达到空间上限
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> addNum <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;<span style="color:#998;font-style:italic">//依次增加十个人的空间上限
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">struct</span> people <span style="color:#000;font-weight:bold">*</span>p<span style="color:#000;font-weight:bold">=</span>(<span style="color:#000;font-weight:bold">struct</span> peoInfo<span style="color:#000;font-weight:bold">*</span>)<span style="color:#900;font-weight:bold">realloc</span>(con.data,(addNum<span style="color:#000;font-weight:bold">+</span>initNum)<span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#000;font-weight:bold">struct</span> peoInfo));
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (p<span style="color:#000;font-weight:bold">!=</span><span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>        con.data<span style="color:#000;font-weight:bold">=</span>p;
</span></span><span style="display:flex;"><span>        p <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    con.zone <span style="color:#000;font-weight:bold">+=</span> addNum;<span style="color:#998;font-style:italic">//这个时候，空间的上限变成了30
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//  TO  DO.......
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//我们将联系人设置为0进行测试
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    con.sz <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;=</span> con.zone<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        con.data<span style="color:#000;font-weight:bold">-&gt;</span>name[i] <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        con.data<span style="color:#000;font-weight:bold">-&gt;</span>tele[i] <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        con.sz<span style="color:#000;font-weight:bold">++</span>;<span style="color:#998;font-style:italic">//增加完一个联系人
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;姓名    电话</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;=</span> con.zone <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d     &#34;</span>, con.data<span style="color:#000;font-weight:bold">-&gt;</span>name[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d &#34;</span>, con.data<span style="color:#000;font-weight:bold">-&gt;</span>tele[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">free</span>(con.data);
</span></span><span style="display:flex;"><span>        con.data<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="双向循环链表">双向循环链表</h3>
<p>双向循环链表（Doubly Circular Linked List）是一种数据结构，它由多个节点（Node）组成，每个节点包含两个指针（Pointer），分别指向它的前一个节点和后一个节点，最后一个节点的后继指向头结点，头结点的前驱指向最后一个节点，形成一个环状结构。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;unistd.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define SHOW_MODE 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define FIND_MODE 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define DELL_MODE 2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">list_link_node</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">list_link_node</span> <span style="color:#000;font-weight:bold">*</span> pre;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">list_link_node</span> <span style="color:#000;font-weight:bold">*</span> next;
</span></span><span style="display:flex;"><span>}listnode,<span style="color:#000;font-weight:bold">*</span>listlink;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listlink <span style="color:#900;font-weight:bold">Creat_list_node</span>();<span style="color:#998;font-style:italic">//创建节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Mode_Select</span>(listlink head );<span style="color:#998;font-style:italic">//模式选择
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Tail_Add_Node</span>(listlink head);<span style="color:#998;font-style:italic">//尾部插入
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>listlink <span style="color:#900;font-weight:bold">Display</span>(listlink head,<span style="color:#458;font-weight:bold">int</span> mode);<span style="color:#998;font-style:italic">//遍历节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Head_Add_Node</span>(listlink head);<span style="color:#998;font-style:italic">//头部插入
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ADD_Anywhere</span>(listlink head);<span style="color:#998;font-style:italic">//任意节点插入(调用了Display遍历至输入数据相等处)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Dele_Anywhere</span>(listlink head);<span style="color:#998;font-style:italic">//删除任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ADD_Anywhere</span>(listlink head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">==</span>head)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;empty!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listlink add_node <span style="color:#000;font-weight:bold">=</span> Display(head,FIND_MODE);<span style="color:#998;font-style:italic">//遍历
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(add_node <span style="color:#000;font-weight:bold">==</span>(listlink) <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;add falied!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listlink new_node<span style="color:#000;font-weight:bold">=</span>Creat_list_node();<span style="color:#998;font-style:italic">//新建节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(new_node<span style="color:#000;font-weight:bold">==</span>(listlink) <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;new falied!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;请输入要添加的数据：</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#d14">&#34;%d&#34;</span>,<span style="color:#000;font-weight:bold">&amp;</span>new_node<span style="color:#000;font-weight:bold">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>add_node<span style="color:#000;font-weight:bold">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>new_node;
</span></span><span style="display:flex;"><span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>add_node;
</span></span><span style="display:flex;"><span>    add_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>new_node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Dele_Anywhere</span>(listlink head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;empty!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    listlink del_node <span style="color:#000;font-weight:bold">=</span> Display(head,DELL_MODE);<span style="color:#998;font-style:italic">//删除模式(遍历)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(del_node <span style="color:#000;font-weight:bold">==</span>(listlink) <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;del falied!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    del_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>del_node<span style="color:#000;font-weight:bold">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    del_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>del_node<span style="color:#000;font-weight:bold">-&gt;</span>pre;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    del_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>    del_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(del_node);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Head_Add_Node</span>(listlink head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    listlink new_node<span style="color:#000;font-weight:bold">=</span>Creat_list_node();<span style="color:#998;font-style:italic">//初始化新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(new_node<span style="color:#000;font-weight:bold">==</span>(listlink)<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;tail node failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;请输入新数据：</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#d14">&#34;%d&#34;</span>,<span style="color:#000;font-weight:bold">&amp;</span>new_node<span style="color:#000;font-weight:bold">-&gt;</span>data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>head<span style="color:#000;font-weight:bold">-&gt;</span>next;             <span style="color:#998;font-style:italic">//新节点next 赋值为 传入节点next
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>new_node;          <span style="color:#998;font-style:italic">//此时新节点next同等 传入节点，该节点pre 赋值为 新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>head;                    <span style="color:#998;font-style:italic">//新节点pre 赋值为 传入节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>new_node;                   <span style="color:#998;font-style:italic">//传入节点next 赋值为 新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listlink <span style="color:#900;font-weight:bold">Creat_list_node</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listlink node<span style="color:#000;font-weight:bold">=</span>(listlink)malloc(<span style="color:#000;font-weight:bold">sizeof</span>(listnode)); <span style="color:#998;font-style:italic">//指向堆，用完不会自动释放
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(node<span style="color:#000;font-weight:bold">==</span>(listlink)<span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;listlink malloc failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> (listlink)<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    memset(node,<span style="color:#099">0</span>,<span style="color:#000;font-weight:bold">sizeof</span>(listnode));
</span></span><span style="display:flex;"><span>    node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>node;
</span></span><span style="display:flex;"><span>    node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Tail_Add_Node</span>(listlink head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    listlink new_node<span style="color:#000;font-weight:bold">=</span>Creat_list_node();<span style="color:#998;font-style:italic">//创建新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span>(new_node<span style="color:#000;font-weight:bold">==</span>(listlink)<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;tail node failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#d14">&#34;请输入新数据：</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#d14">&#34;%d&#34;</span>,<span style="color:#000;font-weight:bold">&amp;</span>new_node<span style="color:#000;font-weight:bold">-&gt;</span>data);<span style="color:#998;font-style:italic">//数据域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>head<span style="color:#000;font-weight:bold">-&gt;</span>pre;            <span style="color:#998;font-style:italic">//新节点pre 赋值为 传入节点pre
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>new_node;       <span style="color:#998;font-style:italic">//此时用 新节点pre 等于传入节点，成员next赋值为新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    new_node<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">=</span>head;                <span style="color:#998;font-style:italic">//传入节点next 赋值为 新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    head<span style="color:#000;font-weight:bold">-&gt;</span>pre<span style="color:#000;font-weight:bold">=</span>new_node;                 <span style="color:#998;font-style:italic">//传入节点pre 赋值为 新节点
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">//&#34;蛇头咬蛇尾&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;   
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listlink <span style="color:#900;font-weight:bold">Display</span>(listlink head,<span style="color:#458;font-weight:bold">int</span> mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;adnormal!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> (listlink)<span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">-&gt;</span>next<span style="color:#000;font-weight:bold">==</span>head)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;empty!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> (listlink)<span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> data<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(mode<span style="color:#000;font-weight:bold">==</span>FIND_MODE<span style="color:#000;font-weight:bold">||</span>mode<span style="color:#000;font-weight:bold">==</span>DELL_MODE)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;请输入要检索的数据!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#d14">&#34;%d&#34;</span>,<span style="color:#000;font-weight:bold">&amp;</span>data);<span style="color:#998;font-style:italic">//要检索的值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">//初始化节点 赋值为 传入节点next;当前节点 不等于 传入节点;当前节点 赋值为 当前节点next
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span>(listlink temp_node<span style="color:#000;font-weight:bold">=</span>head<span style="color:#000;font-weight:bold">-&gt;</span>next;temp_node<span style="color:#000;font-weight:bold">!=</span>head;temp_node<span style="color:#000;font-weight:bold">=</span>temp_node<span style="color:#000;font-weight:bold">-&gt;</span>next)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span>(mode<span style="color:#000;font-weight:bold">==</span>SHOW_MODE)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,temp_node<span style="color:#000;font-weight:bold">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span>((mode<span style="color:#000;font-weight:bold">==</span>FIND_MODE<span style="color:#000;font-weight:bold">||</span>mode<span style="color:#000;font-weight:bold">==</span>DELL_MODE)<span style="color:#000;font-weight:bold">&amp;&amp;</span>temp_node<span style="color:#000;font-weight:bold">-&gt;</span>data<span style="color:#000;font-weight:bold">==</span>data)<span style="color:#998;font-style:italic">//判断当前节点成员数据值与输入的数据值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#d14">&#34;hit the number!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> temp_node;<span style="color:#998;font-style:italic">//返回当前节点地址
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        } 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(mode<span style="color:#000;font-weight:bold">==</span>FIND_MODE<span style="color:#000;font-weight:bold">||</span>mode<span style="color:#000;font-weight:bold">==</span>DELL_MODE)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;找不到数据！</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> (listlink)<span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">Mode_Select</span>(listlink head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span><span style="color:#0086b3">NULL</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> select_num<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        system(<span style="color:#d14">&#34;clear&#34;</span>);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;-------1.尾插链表-----------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;-------2.头插链表-----------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;-------3.指定位置添加数据----</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);  <span style="color:#998;font-style:italic">//bian
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        printf(<span style="color:#d14">&#34;-------4.指定位置删除数据----</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);  <span style="color:#998;font-style:italic">//bian
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        printf(<span style="color:#d14">&#34;-------5.检索数据-----------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);  <span style="color:#998;font-style:italic">//bian
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        printf(<span style="color:#d14">&#34;-------6.移动数据-----------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);  <span style="color:#998;font-style:italic">//bian
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        printf(<span style="color:#d14">&#34;-------7.显示链表------------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);  
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;-------8.退出链表!-----</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#d14">&#34;%d&#34;</span>,<span style="color:#000;font-weight:bold">&amp;</span>select_num);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">switch</span> (select_num)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">1</span><span style="color:#000;font-weight:bold">:</span>Tail_Add_Node(head);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">2</span><span style="color:#000;font-weight:bold">:</span>Head_Add_Node(head);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">3</span><span style="color:#000;font-weight:bold">:</span>ADD_Anywhere(head);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">4</span><span style="color:#000;font-weight:bold">:</span>Dele_Anywhere(head);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">5</span><span style="color:#000;font-weight:bold">:</span>Display(head,FIND_MODE);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">6</span><span style="color:#000;font-weight:bold">:</span>printf(<span style="color:#d14">&#34;-------1.尾插链表------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">7</span><span style="color:#000;font-weight:bold">:</span>Display(head,SHOW_MODE);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">8</span><span style="color:#000;font-weight:bold">:</span>printf(<span style="color:#d14">&#34;-------8.退出链表!------</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;    
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">default</span><span style="color:#000;font-weight:bold">:</span>printf(<span style="color:#d14">&#34;错误的命令!请重新输入：</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    sleep(<span style="color:#099">2</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">const</span> <span style="color:#000;font-weight:bold">*</span>argv[]){
</span></span><span style="display:flex;"><span>    listlink head<span style="color:#000;font-weight:bold">=</span>Creat_list_node();
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(head<span style="color:#000;font-weight:bold">==</span>(listlink)<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#d14">&#34;creat head failed!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Mode_Select(head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="typedef指令">typedef指令</h2>
<h3 id="简介-6">简介</h3>
<p><code>typedef</code>命令用来为某个类型起别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> type name;
</span></span></code></pre></div><p>上面代码中，<code>type</code>代表类型名，<code>name</code>代表别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> BYTE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BYTE c <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;z&#39;</span>;
</span></span></code></pre></div><p>上面示例中，<code>typedef</code>命令为类型<code>unsign char</code>起别名<code>BYTE</code>，然后就可以使用<code>BYTE</code>声明变量。</p>
<p>typedef 可以一次指定多个别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span> antelope, bagel, mushroom;
</span></span></code></pre></div><p>上面示例中，一次性为<code>int</code>类型起了三个别名。</p>
<p>typedef 可以为指针起别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> intptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>intptr x <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a;
</span></span></code></pre></div><p>上面示例中，<code>intptr</code>是<code>int*</code>的别名。不过，使用的时候要小心，这样不容易看出来，变量<code>x</code>是一个指针类型。</p>
<p>typedef 也可以用来为数组类型起别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span> five_ints[<span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>five_ints x <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>};
</span></span></code></pre></div><p>上面示例中，<code>five_ints</code>是一个数组类型，包含5个整数的</p>
<p>typedef 为函数起别名的写法如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">signed</span> <span style="color:#900;font-weight:bold">char</span> (<span style="color:#000;font-weight:bold">*</span>fp)(<span style="color:#458;font-weight:bold">void</span>);
</span></span></code></pre></div><p>上面示例中，类型别名<code>fp</code>是一个指针，代表函数<code>signed char (*)(void)</code>。</p>
<h3 id="主要好处">主要好处</h3>
<p><code>typedef</code>为类型起别名的好处，主要有下面几点。</p>
<p>（1）更好的代码可读性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> STRING;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STRING name;
</span></span></code></pre></div><p>上面示例为字符指针起别名为<code>STRING</code>，以后使用<code>STRING</code>声明变量时，就可以轻易辨别该变量是字符串。</p>
<p>（2）为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> treenode {
</span></span><span style="display:flex;"><span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> treenode<span style="color:#000;font-weight:bold">*</span> Tree;
</span></span></code></pre></div><p>上面示例中，<code>Tree</code>为<code>struct treenode*</code>的别名。</p>
<p>typedef 也可以与 struct 定义数据类型的命令写在一起。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> animal {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> leg_count, speed;
</span></span><span style="display:flex;"><span>} animal;
</span></span></code></pre></div><p>上面示例中，自定义数据类型时，同时使用<code>typedef</code>命令，为<code>struct animal</code>起了一个别名<code>animal</code>。</p>
<p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>name;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> leg_count, speed;
</span></span><span style="display:flex;"><span>} animal;
</span></span></code></pre></div><p>上面示例相当于为一个匿名的数据类型起了别名<code>animal</code>。</p>
<p>（3）typedef 方便以后为变量改类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">float</span> app_float;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>app_float f1, f2, f3;
</span></span></code></pre></div><p>示例中，变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都是<code>float</code>。如果以后需要为它们改类型，只需要修改<code>typedef</code>语句即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">long</span> <span style="color:#458;font-weight:bold">double</span> app_float;
</span></span></code></pre></div><p>上面命令将变量<code>f1</code>、<code>f2</code>、<code>f3</code>的类型都改为<code>long double</code>。</p>
<p>（4）可移植性</p>
<p>某一个值在不同计算机上的类型，可能是不一样的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100000</span>;
</span></span></code></pre></div><p>上面代码在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</p>
<p>C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如<code>int32_t</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int32_t</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">100000</span>;
</span></span></code></pre></div><p>上面示例将变量<code>i</code>声明成<code>int32_t</code>类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</p>
<p>这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">long</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#458;font-weight:bold">ptrdiff_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">long</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#458;font-weight:bold">size_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#458;font-weight:bold">wchar_t</span>;
</span></span></code></pre></div><p>这些整数类型别名都放在头文件<code>stdint.h</code>，不同架构的计算机只需修改这个头文件即可，而无需修改代码。</p>
<p>因此，<code>typedef</code>有助于提高代码的可移植性，使其能适配不同架构的计算机。</p>
<p>（5）简化类型声明</p>
<p>C 语言有些类型声明相当复杂，比如下面这个。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> (<span style="color:#000;font-weight:bold">*</span>(<span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">x</span>(<span style="color:#458;font-weight:bold">void</span>))[<span style="color:#099">5</span>])(<span style="color:#458;font-weight:bold">void</span>);
</span></span></code></pre></div><p>typedef 可以简化复杂的类型声明，使其更容易理解。首先，最外面一层起一个类型别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#900;font-weight:bold">char</span> (<span style="color:#000;font-weight:bold">*</span>Func)(<span style="color:#458;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">Func</span> (<span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">x</span>(<span style="color:#458;font-weight:bold">void</span>))[<span style="color:#099">5</span>];
</span></span></code></pre></div><p>这个看起来还是有点复杂，就为里面一层也定义一个别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#900;font-weight:bold">char</span> (<span style="color:#000;font-weight:bold">*</span>Func)(<span style="color:#458;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> Func Arr[<span style="color:#099">5</span>];
</span></span><span style="display:flex;"><span>Arr<span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">x</span>(<span style="color:#458;font-weight:bold">void</span>);
</span></span></code></pre></div><p>上面代码就比较容易解读了。</p>
<ul>
<li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li>
<li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li>
<li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li>
</ul>
<h2 id="union-结构">Union 结构</h2>
<p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p>
<p>C 语言提供了 Union 结构，用来自定义可以灵活变更的数据结构。它内部包含各种属性，但是所有属性共用一块内存，导致这些属性都是对同一个二进制数据的解读，其中往往只有一个属性的解读是有意义的。并且，后面写入的属性会覆盖前面的属性，这意味着同一块内存，可以先供某一个属性使用，然后再供另一个属性使用。这样做的最大好处是节省内存空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">union</span> quantity {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">short</span> count;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> weight;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> volume;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型<code>quantity</code>。虽然包含三个属性，但是只能写入一个值，三个属性都是对这个值的不同解读。最后赋值的属性，往往就是可以取到有意义的值的那个属性。</p>
<p>使用时，声明一个该类型的变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">union</span> quantity q;
</span></span><span style="display:flex;"><span>q.count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">union</span> quantity q <span style="color:#000;font-weight:bold">=</span> {.count<span style="color:#000;font-weight:bold">=</span><span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法三
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">union</span> quantity q <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">4</span>};
</span></span></code></pre></div><p>上面代码展示了为 Union 结构赋值的三种写法。最后一种写法不指定属性名，就会赋值给第一个属性。</p>
<p>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;count is %i</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, q.count); <span style="color:#998;font-style:italic">// count is 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;weight is %f</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, q.weight); <span style="color:#998;font-style:italic">// 未定义行为
</span></span></span></code></pre></div><p>如果要让<code>q.weight</code>属性可以取到值，就要先为它赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>q.weight <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0.5</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;weight is %f</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, q.weight); <span style="color:#998;font-style:italic">// weight is 0.5
</span></span></span></code></pre></div><p>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就跟着改变，使用它可能就没有意义了。除了这一点，Union 结构的其他用法与 Struct 结构，基本上是一致的。</p>
<p>Union 结构也支持指针运算符<code>-&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">union</span> quantity {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">short</span> count;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> weight;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> volume;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">union</span> quantity q;
</span></span><span style="display:flex;"><span>q.count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">union</span> quantity<span style="color:#000;font-weight:bold">*</span> ptr;
</span></span><span style="display:flex;"><span>ptr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, ptr<span style="color:#000;font-weight:bold">-&gt;</span>count); <span style="color:#998;font-style:italic">// 4
</span></span></span></code></pre></div><p>上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p>
<p>Union 结构指针与它的属性有关，当前正在按照哪个属性解读数据，它的指针就是对应的数据类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">union</span> foo {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> b;
</span></span><span style="display:flex;"><span>} x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> foo_int_p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span><span style="color:#000;font-weight:bold">*</span> foo_float_p <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">float</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x.a <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">12</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, x.a);           <span style="color:#998;font-style:italic">// 12
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>foo_int_p);    <span style="color:#998;font-style:italic">// 12
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>x.b <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.141592</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%f</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, x.b);           <span style="color:#998;font-style:italic">// 3.141592
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%f</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>foo_float_p);  <span style="color:#998;font-style:italic">// 3.141592
</span></span></span></code></pre></div><p>上面示例中，<code>&amp;x</code>是 foo 结构的指针，它的数据类型完全由当前赋值的属性决定。</p>
<p>typedef 命令可以为 Union 数据类型起别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">union</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">short</span> count;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> weight;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">float</span> volume;
</span></span><span style="display:flex;"><span>} quantity;
</span></span></code></pre></div><p>上面示例中，<code>union</code>命令定义了一个包含三个属性的数据类型，<code>typedef</code>命令为它起别名为<code>quantity</code>。</p>
<p>Union 结构的好处，主要是节省空间。它将一段内存空间，重用于不同类型的数据。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。Union 结构占用的内存长度，等于它内部最长属性的长度。</p>
<p>结构体变量所占内存长度是其中最大字段大小的整数倍。</p>
<p>共用体变量所占的内存长度等于最长的成员变量的长度。</p>
<h3 id="共用体作用">共用体作用</h3>
<p>节省内存，有两个很长的数据结构，不会同时使用，比如一个表示老师，一个表示学生，如果要统计教师和学生的情况用结构体的话就有点浪费了！用共用体的话，只占用最长的那个数据结构所占用的空间，就足够了！</p>
<h3 id="共用体应用场景">共用体应用场景</h3>
<p>通信中的数据包会用到共用体:因为不知道对方会发一个什么包过来，用共用体的话就很简单了，定义几种格式的包，收到包之后就可以直接根据包的格式取出数据。</p>
<h2 id="位域">位域</h2>
<p>C 语言的位域（bit-field）是一种特殊的结构体成员，允许按位对成员进行定义，指定其占用的位数。如果程序的结构中包含多个开关的变量，即变量值为<code>TRUE/FALSE</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 该结构需要8字节的内存空间，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 实际上在每个变量中,只存储0或1,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 在这种情况下,C语言提供了一种更好的利用内存空间的方式:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 在结构内使用这样的变量,可以定义变量的宽度来告诉编译器,将只使用这些字节。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> widthValidated;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> heightValidated;
</span></span><span style="display:flex;"><span>} status;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * status变量将占用4个字节的内存空间，但是只有2位被用来存储值。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 如果用了32个变量,每一个变量宽度为1位,那么status结构将使用4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 但如果使用了33个变量,那么它将分配内存的下一段来存储第33个变量此时就开始使用8个字节
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">widthValidated</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">heightValidated</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>} status;
</span></span></code></pre></div><p>下面的实例来理解这个概念：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/* 定义简单的结构 */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> widthValidated;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> heightValidated;
</span></span><span style="display:flex;"><span>} status1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/* 定义位域结构 */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">widthValidated</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">heightValidated</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>} status2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>( ) {
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">printf</span>( <span style="color:#d14">&#34;Memory size occupied by status1 : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(status1)); <span style="color:#998;font-style:italic">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>   <span style="color:#900;font-weight:bold">printf</span>( <span style="color:#d14">&#34;Memory size occupied by status2 : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(status2)); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>位域的特点和使用方法如下：</p>
<ul>
<li>定义位域时，可以指定成员的位域宽度，即成员所占用的位数。</li>
<li>位域的宽度不能超过其数据类型的大小，因为位域必须适应所使用的整数类型。</li>
<li>位域的数据类型可以是 <code>int</code>、<code>unsigned int</code>、<code>signed int</code> 等整数类型，也可以是枚举类型。</li>
<li>位域可以单独使用，也可以与其他成员一起组成结构体。</li>
<li>位域的访问是通过点运算符（<code>.</code>）来实现的，与普通的结构体成员访问方式相同。</li>
</ul>
<h3 id="位域声明">位域声明</h3>
<p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为&quot;位域&quot;或&quot;位段&quot;。</p>
<p><strong>所谓&quot;位域&quot;是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数</strong>。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：</p>
<ul>
<li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li>
<li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li>
</ul>
<h3 id="位域的定义和位域变量的说明">位域的定义和位域变量的说明</h3>
<p>位域定义与结构定义相仿，其形式为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> <span style="color:#a61717;background-color:#e3d2d2">位域结构名</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 位域列表
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>其中位域列表的形式为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>type [member_name] <span style="color:#000;font-weight:bold">:</span> width ;
</span></span></code></pre></div><p>下面是有关位域中变量元素的描述：</p>
<table>
<thead>
<tr>
<th style="text-align:left">元素</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>type</code></td>
<td style="text-align:left">只能为<code>int</code>，<code>unsigned int</code>，<code>signed int</code>三种类型，决定了如何解释位域的值</td>
</tr>
<tr>
<td style="text-align:left"><code>member_name</code></td>
<td style="text-align:left">位域的名称。</td>
</tr>
<tr>
<td style="text-align:left"><code>width</code></td>
<td style="text-align:left">位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td>
</tr>
</tbody>
</table>
<p><u>带有预定义宽度的变量被称为<strong>位域</strong></u>。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> bs {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">a</span>:<span style="color:#099">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">b</span>:<span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">c</span>:<span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span>} data;
</span></span></code></pre></div><p>上面的结构定义指示 C 编译器，<code>age</code>变量将只使用 3 位来存储这个值，如果试图使用超过 3 位，则无法完成。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> bs {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">a</span>:<span style="color:#099">8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">b</span>:<span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">c</span>:<span style="color:#099">6</span>;
</span></span><span style="display:flex;"><span>} data;
</span></span></code></pre></div><p>以上代码定义了一个名为<code>struct bs</code>的结构体，<code>data</code>为<code>bs</code>的结构体变量，共占四个字节：</p>
<p>对于位域来说，它们的宽度不能超过其数据类型的大小，在这种情况下，<code>int</code>类型的大小通常是 4 个字节（32位）。相邻位域字段的类型相同，且其位宽之和小于类型的<code>sizeo f</code>大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止。</p>
<p>让我们再来看一个实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> packed_struct {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f1</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f2</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f3</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f4</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">type</span>:<span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">my_int</span>:<span style="color:#099">9</span>;
</span></span><span style="display:flex;"><span>} pack;
</span></span></code></pre></div><p>以上代码定义了一个名为<code>packed_struct</code>的结构体，其中包含了六个成员变量，<code>pack</code>为<code>packed_struct</code>的结构体变量。<code>packed_struct</code>包含了 6 个成员：四个 1 位的标识符<code>f1-f4</code>、一个 4 位的<code>type</code>和一个 9 位的<code>my_int</code></p>
<p>来看下面的实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> packed_struct {
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f1</span> : <span style="color:#099">1</span>; <span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#998;font-style:italic">// 1位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f2</span> : <span style="color:#099">1</span>; <span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#998;font-style:italic">// 1位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f3</span> : <span style="color:#099">1</span>; <span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#998;font-style:italic">// 1位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f4</span> : <span style="color:#099">1</span>; <span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#998;font-style:italic">// 1位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">type</span> : <span style="color:#099">4</span>; <span style="color:#998;font-style:italic">// 4位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">my_int</span> : <span style="color:#099">9</span>; <span style="color:#998;font-style:italic">// 9位的位域
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#000;font-weight:bold">struct</span> packed_struct pack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.f1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.f2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.f3 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.f4 <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.type <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span>pack.my_int <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">255</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;f1: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.f1); <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;f2: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.f2); <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;f3: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.f3); <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;f4: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.f4); <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;type: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.type); <span style="color:#998;font-style:italic">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;my_int: %u</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, pack.my_int); <span style="color:#998;font-style:italic">// 255
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上实例定义了一个名为<code>packed_struct</code>的结构体，其中包含了多个位域成员。在<code>main()</code>函数中，创建了一个<code>packed_struct</code>类型的结构体变量<code>pack</code>，并分别给每个位域成员赋值。然后使用<code>printf</code>语句打印出每个位域成员的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">age</span> : <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>} Age;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 如果超出范围，则直接丢掉了，存不进去
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span>Age.age <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Sizeof( Age ) : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(Age)); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Age.age : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, Age.age); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 二进制表示为 111 有三位，达到最大值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Age.age <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">7</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Age.age : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, Age.age); <span style="color:#998;font-style:italic">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 二进制表示为 1000 有四位，超出
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>Age.age <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">8</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Age.age : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, Age.age); <span style="color:#998;font-style:italic">// 0
</span></span></span></code></pre></div><p>计算字节数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> example1 {
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">a</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">b</span> : <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">c</span> : <span style="color:#099">7</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#000;font-weight:bold">struct</span> example1 ex1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Size of example1: %lu bytes</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(ex1)); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2"> </span> <span style="color:#a61717;background-color:#e3d2d2"> </span><span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上实例中，<code>example1</code>结构体包含三个位域成员 a，b 和 c，它们分别占用 4 位、5 位和 7 位。通过<code>sizeof</code>运算符计算出<code>example1</code>结构体的字节数</p>
<p><strong>对于位域的定义尚有以下几点说明：</strong></p>
<ul>
<li>
<p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 在位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> bs{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">a</span>:<span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span>  <span style="color:#000;font-weight:bold">:</span><span style="color:#099">4</span>;    <span style="color:#998;font-style:italic">/* 空域 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">b</span>:<span style="color:#099">4</span>;    <span style="color:#998;font-style:italic">/* 从下一单元开始存放 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">c</span>:<span style="color:#099">4</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，设置的位域长度不能超过类型变量的长度。</p>
</li>
<li>
<p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> k{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">a</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span>  <span style="color:#000;font-weight:bold">:</span><span style="color:#099">2</span>;    <span style="color:#998;font-style:italic">/* 该 2 位不能使用 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">b</span>:<span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">c</span>:<span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ul>
<p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p>
<h3 id="位域的使用">位域的使用</h3>
<p>位域的使用和结构成员的使用相同，其一般形式为：(位域允许用各种格式输出)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2">位域变量名</span>.<span style="color:#a61717;background-color:#e3d2d2">位域名</span>
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2">位域变量名</span><span style="color:#000;font-weight:bold">-&gt;</span><span style="color:#a61717;background-color:#e3d2d2">位域名</span>
</span></span></code></pre></div><p>请看下面的实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">struct</span> bs{
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">a</span>:<span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">b</span>:<span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#900;font-weight:bold">c</span>:<span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    } bit,<span style="color:#000;font-weight:bold">*</span>pbit;
</span></span><span style="display:flex;"><span>    bit.a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>;    <span style="color:#998;font-style:italic">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span>
</span></span><span style="display:flex;"><span>    bit.b<span style="color:#000;font-weight:bold">=</span><span style="color:#099">7</span>;    <span style="color:#998;font-style:italic">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span>
</span></span><span style="display:flex;"><span>    bit.c<span style="color:#000;font-weight:bold">=</span><span style="color:#099">15</span>;    <span style="color:#998;font-style:italic">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d,%d,%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,bit.a,bit.b,bit.c);    <span style="color:#998;font-style:italic">/* 以整型量格式输出三个域的内容 */</span>
</span></span><span style="display:flex;"><span>    pbit<span style="color:#000;font-weight:bold">=&amp;</span>bit;    <span style="color:#998;font-style:italic">/* 把位域变量 bit 的地址送给指针变量 pbit */</span>
</span></span><span style="display:flex;"><span>    pbit<span style="color:#000;font-weight:bold">-&gt;</span>a<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>;    <span style="color:#998;font-style:italic">/* 用指针方式给位域 a 重新赋值，赋为 0 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     * 使用了复合的位运算符 &#34;&amp;=&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     * 相当于：pbit-&gt;b=pbit-&gt;b&amp;3，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     * 位域b中原有值为7，与3作按位与运算的结果为3（111&amp;011=011，十进制值为 3）
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    pbit<span style="color:#000;font-weight:bold">-&gt;</span>b<span style="color:#000;font-weight:bold">&amp;=</span><span style="color:#099">3</span>;    
</span></span><span style="display:flex;"><span>    pbit<span style="color:#000;font-weight:bold">-&gt;</span>c<span style="color:#000;font-weight:bold">|=</span><span style="color:#099">1</span>;    <span style="color:#998;font-style:italic">/* 使用了复合位运算符&#34;|=&#34;，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d,%d,%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,pbit<span style="color:#000;font-weight:bold">-&gt;</span>a,pbit<span style="color:#000;font-weight:bold">-&gt;</span>b,pbit<span style="color:#000;font-weight:bold">-&gt;</span>c);    <span style="color:#998;font-style:italic">/* 用指针方式输出了这三个域的值 */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上例程序中定义了位域结构<code>bs</code>，三个位域为<code>a</code>、<code>b</code>、<code>c</code>。说明了<code>bs</code>类型的变量<code>bit</code>和指向<code>bs</code>类型的指针变量<code>pbit</code>。这表示位域也是可以使用指针的。</p>
<h3 id="位域的内存分配">位域的内存分配</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 位域内存测试
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> ONE_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">_bool</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">del_flag</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">status</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>} one_byte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> TWO_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc3</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc4</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>} two_byte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> THREE_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc3</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc4</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc5</span> : <span style="color:#099">4</span>;
</span></span><span style="display:flex;"><span>} three_byte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> FOUR_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">16</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">16</span>;
</span></span><span style="display:flex;"><span>} four_byte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> EIGHT_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>} eight_byte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">const</span> <span style="color:#000;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof one_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(one_byte)); <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof two_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(two_byte)); <span style="color:#998;font-style:italic">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof three_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(three_byte)); <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof four_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(four_byte)); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof eight_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(eight_byte)); <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结构体内存分配原则：</p>
<ul>
<li>原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。</li>
<li>原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。</li>
</ul>
<p><code>struct ONE_BYTE</code>，其 3 个位域都是 char 类型，所以可以按照位的顺序存储（不用分字节），<code>1+1+4=6</code>位，占用 <strong>1</strong> 个字节。</p>
<p><code>struct TWO_BYTE</code>，<code>4+4+4+4=16</code>位 <strong>=2</strong> 个字节。</p>
<p><code>struct THREE_BYTE</code>，<code>4*5=20</code>位，占 <strong>3</strong> 个字节（不足的 4 位补 0）。</p>
<p><code>struct FOUR_BYTE</code>，其 2 个位域都是 int 类型，所以可以按照位的顺序存储（不用分字节），一个 int 类型占 4 个字节，刚好 16+16=32 位 <strong>=4</strong> 个字节。为 int 类型所占字节数的 <strong>1</strong> 倍（整数倍），所以<code>sizeof(four_byte)=4</code></p>
<p><code>struct EIGHT_BYTE</code>：<code>unsigned int</code> 类型需要用 4 个字节的内存空间来存储，<code>unsigned char</code>类型需要 1 个字节的内存空间来存储，但是这里位域使用方面，cc1 和 cc2 都只使用了 1 位，即各占用 1 个 Bit，所以系统按照 cc1 的 <code>unsigned int</code>类型开辟了 4 个字节来存放这个位域变量，所以最终<code>sizeof(eight_byte)</code>的结果应该是4</p>
<p>当然可以尝试将 cc2 的位域占用改成 32，这里由于4个字节的空间已经不够存放两个位域变量了，所以就需要按照为 int 类型所占字节数的 2 倍来为其开辟空间，即这里便需要 8 个字节了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> EIGHT_BYTE {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">32</span>;
</span></span><span style="display:flex;"><span>} eight_byte;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof eight_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(eight_byte)); <span style="color:#998;font-style:italic">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>倘若将 cc2 的位域空间改成 31，则这里存储空间大小仍是 4 个字节。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> EIGHT_BYTE{    
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span> <span style="color:#900;font-weight:bold">ccc1</span> : <span style="color:#099">1</span>;    
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">ccc2</span> : <span style="color:#099">31</span>;
</span></span><span style="display:flex;"><span>} eight_byte;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>){ 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;sizeof eight_byte is : %lu</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">sizeof</span>(eight_byte)); <span style="color:#998;font-style:italic">// 4   
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="枚举">枚举</h2>
<p>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为<code>Enum</code>类型，中文名为枚举。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> colors {RED, GREEN, BLUE};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, RED);    <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, GREEN);  <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, BLUE);   <span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面示例中，假定程序里面需要三种颜色，就可以使用<code>enum</code>命令，把这三种颜色定义成一种枚举类型<code>colors</code>，它只有三种取值可能<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>。这时，这三个名字自动成为整数常量，编译器默认将它们的值设为数字<code>0</code>、<code>1</code>、<code>2</code>。相比之下，<code>RED</code>要比<code>0</code>的可读性好了许多。</p>
<p>注意，Enum 内部的常量名，遵守标识符的命名规范，但是通常都使用大写。</p>
<p>使用时，可以将变量声明为 Enum 类型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> colors color;
</span></span></code></pre></div><p>上面代码将变量<code>color</code>声明为<code>enum colors</code>类型。这个变量的值就是常量<code>RED</code>、<code>GREEN</code>、<code>BLUE</code>之中的一个。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>color <span style="color:#000;font-weight:bold">=</span> BLUE;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%i</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, color); <span style="color:#998;font-style:italic">// 2
</span></span></span></code></pre></div><p>上面代码将变量<code>color</code>的值设为<code>BLUE</code>，这里<code>BLUE</code>就是一个常量，值等于<code>2</code>。</p>
<p>typedef 命令可以为 Enum 类型起别名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">enum</span> {
</span></span><span style="display:flex;"><span>  SHEEP,
</span></span><span style="display:flex;"><span>  WHEAT,
</span></span><span style="display:flex;"><span>  WOOD,
</span></span><span style="display:flex;"><span>  BRICK,
</span></span><span style="display:flex;"><span>  ORE
</span></span><span style="display:flex;"><span>} RESOURCE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RESOURCE r;
</span></span></code></pre></div><p>上面示例中，<code>RESOURCE</code>是 Enum 类型的别名。声明变量时，使用这个别名即可。</p>
<p>还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> {
</span></span><span style="display:flex;"><span>  SHEEP,
</span></span><span style="display:flex;"><span>  WHEAT,
</span></span><span style="display:flex;"><span>  WOOD,
</span></span><span style="display:flex;"><span>  BRICK,
</span></span><span style="display:flex;"><span>  ORE
</span></span><span style="display:flex;"><span>} r <span style="color:#000;font-weight:bold">=</span> BRICK, s <span style="color:#000;font-weight:bold">=</span> WOOD;
</span></span></code></pre></div><p>上面示例中，<code>r</code>的值是<code>3</code>，<code>s</code>的值是<code>2</code>。</p>
<p>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。这时就可以使用下面这种写法，比较简单。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> { ONE, TWO };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d %d&#34;</span>, ONE, TWO);  <span style="color:#998;font-style:italic">// 0 1
</span></span></span></code></pre></div><p>上面示例中，<code>enum</code>是一个关键字，后面跟着一个代码块，常量就在代码内声明。<code>ONE</code>和<code>TWO</code>就是两个 Enum 常量。</p>
<p>常量之间使用逗号分隔。最后一个常量后面的尾逗号，可以省略，也可以保留。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> { ONE, TWO, };
</span></span></code></pre></div><p>由于Enum 会自动编号，因此可以不必为常量赋值。C 语言会自动从0开始递增，为常量赋值。但是，C 语言也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。因此，任何可以使用整数的场合，都可以使用 Enum 常量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> {
</span></span><span style="display:flex;"><span>    ONE <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>,
</span></span><span style="display:flex;"><span>    TWO <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d %d&#34;</span>, ONE, TWO);  <span style="color:#998;font-style:italic">// 1 2
</span></span></span></code></pre></div><p>Enum 常量可以是不连续的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> { X <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>, Y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">18</span>, Z <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2</span> };
</span></span></code></pre></div><p>Enum 常量也可以是同一个值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> { X <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>, Y <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>, Z <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span> };
</span></span></code></pre></div><p>如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">enum</span> {
</span></span><span style="display:flex;"><span>  A,    <span style="color:#998;font-style:italic">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  B,    <span style="color:#998;font-style:italic">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  C <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>,  <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  D,    <span style="color:#998;font-style:italic">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  E,    <span style="color:#998;font-style:italic">// 6
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  F <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>,   <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  G,    <span style="color:#998;font-style:italic">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  H     <span style="color:#998;font-style:italic">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>Enum 的作用域与变量相同。如果是在顶层声明，那么在整个文件内都有效；如果是在代码块内部声明，则只对该代码块有效。如果与使用<code>int</code>声明的常量相比，Enum 的好处是更清晰地表示代码意图。</p>
<h2 id="预处理器">预处理器</h2>
<h3 id="简介-7">简介</h3>
<p>C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。</p>
<p>预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行<code>#</code>开头的预处理指令。</p>
<p>预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。</p>
<p>每个预处理指令都以<code>#</code>开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。<code>#</code>和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。</p>
<p>所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。</p>
<h3 id="define">#define</h3>
<p><code>#define</code>是最常见的预处理指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。</p>
<pre tabindex="0"><code>#define MAX 100
</code></pre><p>上面示例中，<code>#define</code>指定将源码里面的<code>MAX</code>，全部替换成<code>100</code>。<code>MAX</code>就称为一个宏。</p>
<p>宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（<code>_</code>），且首字符不能是数字。</p>
<p>宏是原样替换，指定什么内容，就一模一样替换成什么内容。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define HELLO &#34;Hello, world&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 相当于 printf(&#34;%s&#34;, &#34;Hello, world&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s&#34;</span>, HELLO);
</span></span></code></pre></div><p>上面示例中，宏<code>HELLO</code>会被原样替换成<code>&quot;Hello, world&quot;</code>。</p>
<p><code>#define</code>指令可以出现在源码文件的任何地方，从指令出现的地方到文件末尾都有效。习惯上，会将<code>#define</code>放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。</p>
<p><code>#define</code>指令从<code>#</code>开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define OW &#34;C programming language is invented \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">in 1970s.&#34;
</span></span></span></code></pre></div><p>上面示例中，第一行结尾的反斜杠将<code>#define</code>指令拆成两行。</p>
<p><code>#define</code>允许多重替换，即一个宏可以包含另一个宏。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define TWO 2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define FOUR TWO*TWO
</span></span></span></code></pre></div><p>上面示例中，<code>FOUR</code>会被替换成<code>2*2</code>。</p>
<p>注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define TWO 2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 输出 TWO
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;TWO</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 输出 22
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> TWOs <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">22</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, TWOs);
</span></span></code></pre></div><p>上面示例中，双引号里面的<code>TWO</code>，以及标识符<code>TWOs</code>，都不会被替换。</p>
<p>同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 正确
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#define FOO hello
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define FOO hello
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#define BAR hello
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define BAR world
</span></span></span></code></pre></div><p>上面示例中，宏<code>FOO</code>没有变化，所以可以重复定义，宏<code>BAR</code>发生了变化，就报错了。</p>
<h3 id="带参数的宏">带参数的宏</h3>
<h4 id="基本用法">基本用法</h4>
<p>宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define SQUARE(X) X*X
</span></span></span></code></pre></div><p>上面示例中，宏<code>SQUARE</code>可以接受一个参数<code>X</code>，替换成<code>X*X</code>。</p>
<p>注意，宏的名称与左边圆括号之间，不能有空格。</p>
<p>这个宏的用法如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 替换成 z = 2*2;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>z <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">SQUARE</span>(<span style="color:#099">2</span>);
</span></span></code></pre></div><p>这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define SQUARE(X) X*X
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 输出19
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">SQUARE</span>(<span style="color:#099">3</span> <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">4</span>));
</span></span></code></pre></div><p>上面示例中，<code>SQUARE(3 + 4)</code>如果是函数，输出的应该是49（<code>7*7</code>）；宏是原样替换，所以替换成<code>3 + 4*3 + 4</code>，最后输出19。</p>
<p>可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define SQUARE(X) ((X) * (X))
</span></span></span></code></pre></div><p>上面示例中，<code>SQUARE(X)</code>替换后的形式，有两层圆括号，就可以避免很多错误的发生。</p>
<p>宏的参数也可以是空的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define getchar() getc(stdin)
</span></span></span></code></pre></div><p>上面示例中，宏<code>getchar()</code>的参数就是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。</p>
<p>一般来说，带参数的宏都是一行的。下面是两个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define MAX(x, y) ((x)&gt;(y)?(x):(y))
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define IS_EVEN(n) ((n)%2==0)
</span></span></span></code></pre></div><p>如果宏的长度过长，可以使用反斜杠（<code>\</code>）折行，将宏写成多行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define PRINT_NUMS_TO_PRODUCT(a, b) { \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">  int product = (a) * (b); \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">  for (int i = 0; i &lt; product; i++) { \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">    printf(&#34;%d\n&#34;, i); \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">  } \
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">}
</span></span></span></code></pre></div><p>上面示例中，替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部。</p>
<p>带参数的宏也可以嵌套，一个宏里面包含另一个宏。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)
</span></span></span></code></pre></div><p>上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏<code>QUAD</code>先替换成另外两个宏<code>QUADP</code>和<code>QUADM</code>，后者再各自替换成一个解。</p>
<p>那么，什么时候使用带参数的宏，什么时候使用函数呢？</p>
<p>一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。</p>
<p>宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。</p>
<h4 id="运算符运算符"><code>#</code>运算符，<code>##</code>运算符</h4>
<p>由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上<code>#</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define STR(x) #x
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于 printf(&#34;%s\n&#34;, &#34;3.14159&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">STR</span>(<span style="color:#099">3.14159</span>));
</span></span></code></pre></div><p>上面示例中，<code>STR(3.14159)</code>会被替换成<code>3.14159</code>。如果<code>x</code>前面没有<code>#</code>，这会被解释成一个浮点数，有了<code>#</code>以后，就会被转换成字符串。</p>
<p>下面是另一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define XNAME(n) &#34;x&#34;#n
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 输出 x4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">XNAME</span>(<span style="color:#099">4</span>));
</span></span></code></pre></div><p>上面示例中，<code>#n</code>指定参数输出为字符串，再跟前面的字符串结合，最终输出为<code>&quot;x4&quot;</code>。如果不加<code>#</code>，这里实现起来就很麻烦了。</p>
<p>如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用<code>##</code>运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define MK_ID(n) i##n
</span></span></span></code></pre></div><p>上面示例中，<code>n</code>是宏<code>MK_ID</code>的参数，这个参数需要跟标识符<code>i</code>粘合在一起，这时<code>i</code>和<code>n</code>之间就要使用<code>##</code>运算符。下面是这个宏的用法示例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">MK_ID</span>(<span style="color:#099">1</span>), <span style="color:#900;font-weight:bold">MK_ID</span>(<span style="color:#099">2</span>), <span style="color:#900;font-weight:bold">MK_ID</span>(<span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 替换成
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> i1, i2, i3;
</span></span></code></pre></div><p>上面示例中，替换后的文本<code>i1</code>、<code>i2</code>、<code>i3</code>是三个标识符，参数<code>n</code>是标识符的一部分。从这个例子可以看到，<code>##</code>运算符的一个主要用途是批量生成变量名和标识符。</p>
<h4 id="不定参数的宏">不定参数的宏</h4>
<p>宏的参数还可以是不定数量的（即不确定有多少个参数），<code>...</code>表示剩余的参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
</span></span></span></code></pre></div><p>上面示例中，<code>X(a, b, ...)</code>表示<code>X()</code>至少有两个参数，多余的参数使用<code>...</code>表示。在替换文本中，<code>__VA_ARGS__</code>代表多余的参数（每个参数之间使用逗号分隔）。下面是用法示例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">X</span>(<span style="color:#099">5</span>, <span style="color:#099">4</span>, <span style="color:#099">3.14</span>, <span style="color:#d14">&#34;Hi!&#34;</span>, <span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 替换成
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>(<span style="color:#099">10</span><span style="color:#000;font-weight:bold">*</span>(<span style="color:#099">5</span>) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">20</span><span style="color:#000;font-weight:bold">*</span>(<span style="color:#099">4</span>)), <span style="color:#099">3.14</span>, <span style="color:#d14">&#34;Hi!&#34;</span>, <span style="color:#099">12</span>
</span></span></code></pre></div><p>注意，<code>...</code>只能替代宏的尾部参数，不能写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#define WRONG(X, ..., Y) #X #__VA_ARGS__ #Y
</span></span></span></code></pre></div><p>上面示例中，<code>...</code>替代中间部分的参数，这是不允许的，会报错。</p>
<p><code>__VA_ARGS__</code>前面加上一个<code>#</code>号，可以让输出变成一个字符串。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define X(...) #__VA_ARGS__
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">X</span>(<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>));  <span style="color:#998;font-style:italic">// Prints &#34;1, 2, 3&#34;
</span></span></span></code></pre></div><h3 id="undef">#undef</h3>
<p><code>#undef</code>指令用来取消已经使用<code>#define</code>定义的宏。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define LIMIT 400
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#undef LIMIT
</span></span></span></code></pre></div><p>上面示例的<code>undef</code>指令取消已经定义的宏<code>LIMIT</code>，后面就可以重新用 LIMIT 定义一个宏。</p>
<p>有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用<code>#undef</code>取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而<code>#undef</code>的参数如果是不存在的宏，并不会报错。</p>
<p>GCC 的<code>-U</code>选项可以在命令行取消宏的定义，相当于<code>#undef</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -ULIMIT foo.c
</span></span></code></pre></div><p>上面示例中的<code>-U</code>参数，取消了宏<code>LIMIT</code>，相当于源文件里面的<code>#undef LIMIT</code>。</p>
<h3 id="include">#include</h3>
<p><code>#include</code>指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 形式一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;foo.h&gt; // 加载系统提供的文件</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 形式二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;foo.h&#34; // 加载用户提供的文件</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span></code></pre></div><p>形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。</p>
<p>形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;/usr/local/lib/foo.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span></code></pre></div><p>GCC 编译器的<code>-I</code>参数，也可以用来指定<code>include</code>命令中用户文件的加载路径。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -Iinclude/ -o code code.c
</span></span></code></pre></div><p>上面命令中，<code>-Iinclude/</code>指定从当前目录的<code>include</code>子目录里面，加载用户自己的文件。</p>
<p><code>#include</code>最常见的用途，就是用来加载包含函数原型的头文件（后缀名为<code>.h</code>）。多个<code>#include</code>指令的顺序无关紧要，多次包含同一个头文件也是合法的。</p>
<h3 id="ifendif">#if&hellip;#endif</h3>
<p><code>#if...#endif</code>指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if 0</span><span style="color:#998;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">  const double pi = 3.1415; // 不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，<code>#if</code>后面的<code>0</code>，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。<code>#if 0</code>这种写法常用来当作注释使用，不需要的代码就放在<code>#if 0</code>里面。</p>
<p><code>#if</code>后面的判断条件，通常是一个表达式。如果表达式的值不等于<code>0</code>，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。</p>
<p><code>#if...#endif</code>之间还可以加入<code>#else</code>指令，用于指定判断条件不成立时，需要编译的语句。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define FOO 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if FOO
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;defined</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;not defined</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，宏<code>FOO</code>如果定义过，会被替换成<code>1</code>，从而输出<code>defined</code>，否则输出<code>not defined</code>。</p>
<p>如果有多个判断条件，还可以加入<code>#elif</code>命令。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if HAPPY_FACTOR == 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m not happy!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#elif HAPPY_FACTOR == 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m just regular</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m extra happy!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，通过<code>#elif</code>指定了第二重判断。注意，<code>#elif</code>的位置必须在<code>#else</code>之前。如果多个判断条件皆不满足，则执行<code>#else</code>的部分。</p>
<p>没有定义过的宏，等同于<code>0</code>。因此如果<code>UNDEFINED</code>是一个没有定义过的宏，那么<code>#if UNDEFINED</code>为伪，而<code>#if !UNDEFINED</code>为真。</p>
<p><code>#if</code>的常见应用就是打开（或关闭）调试模式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define DEBUG 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;value of i : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, i);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;value of j : %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, j);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，通过将<code>DEBUG</code>设为<code>1</code>，就打开了调试模式，可以输出调试信息。</p>
<p>GCC 的<code>-D</code>参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -DDEBUG<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span> foo.c
</span></span></code></pre></div><p>上面示例中，<code>-D</code>参数指定宏<code>DEBUG</code>为<code>1</code>，相当于在代码中指定<code>#define DEBUG 1</code>。</p>
<h3 id="ifdefendif">#ifdef&hellip;#endif</h3>
<p><code>#ifdef...#endif</code>指令用于判断某个宏是否定义过。</p>
<p>有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用<code>#define</code>定义一个空的宏。通过这个宏，判断库文件是否被加载了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define EXTRA_HAPPY
</span></span></span></code></pre></div><p>上面示例中，<code>EXTRA_HAPPY</code>就是一个空的宏。</p>
<p>然后，源码文件使用<code>#ifdef...#endif</code>检查这个宏是否定义过。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef EXTRA_HAPPY
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m extra happy!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，<code>#ifdef</code>检查宏<code>EXTRA_HAPPY</code>是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。</p>
<p><code>#ifdef</code>可以与<code>#else</code>指令配合使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef EXTRA_HAPPY
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m extra happy!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m just regular</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，如果宏<code>EXTRA_HAPPY</code>没有定义过，就会执行<code>#else</code>的部分。</p>
<p><code>#ifdef...#else...#endif</code>可以用来实现条件加载。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef MAVIS
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;foo.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#define STABLES 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;bar.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#define STABLES 2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，通过判断宏<code>MAVIS</code>是否定义过，实现加载不同的头文件。</p>
<h3 id="defined-运算符">defined 运算符</h3>
<p>上一节的<code>#ifdef</code>指令，等同于<code>#if defined</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef FOO
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#if defined FOO
</span></span></span></code></pre></div><p>上面示例中，<code>defined</code>是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。</p>
<p>使用这种语法，可以完成多重判断。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if defined FOO
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#elif defined BAR
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  x <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if defined IBMPC
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;ibmpc.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#elif defined MAC
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;mac.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;general.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。</p>
<h3 id="ifndefendif">#ifndef&hellip;#endif</h3>
<p><code>#ifndef...#endif</code>指令跟<code>#ifdef...#endif</code>正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef EXTRA_HAPPY
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m extra happy!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifndef EXTRA_HAPPY
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;I&#39;m just regular</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，针对宏<code>EXTRA_HAPPY</code>是否被定义过，<code>#ifdef</code>和<code>#ifndef</code>分别指定了两种情况各自需要编译的代码。</p>
<p><code>#ifndef</code>常用于防止重复加载。举例来说，为了防止头文件<code>myheader.h</code>被重复加载，可以把它放在<code>#ifndef...#endif</code>里面加载。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifndef MYHEADER_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#define MYHEADER_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;myheader.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，宏<code>MYHEADER_H</code>对应文件名<code>myheader.h</code>的大写。只要<code>#ifndef</code>发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏<code>MYHEADER_H</code>，防止被再次加载。</p>
<p><code>#ifndef</code>等同于<code>#if !defined</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifndef FOO
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#if !defined FOO
</span></span></span></code></pre></div><h3 id="预定义宏">预定义宏</h3>
<p>C 语言提供一些预定义的宏，可以直接使用。</p>
<ul>
<li><code>__DATE__</code>：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。</li>
<li><code>__TIME__</code>：编译时间，格式为“hh:mm:ss”。</li>
<li><code>__FILE__</code>：当前文件名。</li>
<li><code>__LINE__</code>：当前行号。</li>
<li><code>__func__</code>：当前正在执行的函数名。该预定义宏必须在函数作用域使用。</li>
<li><code>__STDC__</code>：如果被设为1，表示当前编译器遵循 C 标准。</li>
<li><code>__STDC_HOSTED__</code>：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。</li>
<li><code>__STDC_VERSION__</code>：编译所使用的 C 语言版本，是一个格式为<code>yyyymmL</code>的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。</li>
</ul>
<p>下面示例打印这些预定义宏的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;This function: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, __func__);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;This file: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, __FILE__);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;This line: %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, __LINE__);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Compiled on: %s %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, __DATE__, __TIME__);
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;C Version: %ld</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, __STDC_VERSION__);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/* 输出如下
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This function: main
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This file: test.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This line: 7
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Compiled on: Mar 29 2021 19:19:37
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">C Version: 201710
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">*/</span>
</span></span></code></pre></div><h3 id="line">#line</h3>
<p><code>#line</code>指令用于覆盖预定义宏<code>__LINE__</code>，将其改为自定义的行号。后面的行将从<code>__LINE__</code>的新值开始计数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 将下一行的行号重置为 300
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#line 300
</span></span></span></code></pre></div><p>上面示例中，紧跟在<code>#line 300</code>后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。</p>
<p><code>#line</code>还可以改掉预定义宏<code>__FILE__</code>，将其改为自定义的文件名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#line 300 &#34;newfilename&#34;
</span></span></span></code></pre></div><p>上面示例中，下一行的行号重置为<code>300</code>，文件名重置为<code>newfilename</code>。</p>
<h3 id="error">#error</h3>
<p><code>#error</code>指令用于让预处理器抛出一个错误，终止编译。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if __STDC_VERSION__ != 201112L
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#error Not C11
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -std<span style="color:#000;font-weight:bold">=</span>c99 newish.c
</span></span><span style="display:flex;"><span>newish.c:14:2: error: <span style="color:#998;font-style:italic">#error Not C11</span>
</span></span></code></pre></div><p>上面示例中，GCC 使用 C99 标准编译，就报错了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if INT_MAX &lt; 100000
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#error int type is too small
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，编译器一旦发现<code>INT</code>类型的最大值小于<code>100,000</code>，就会停止编译。</p>
<p><code>#error</code>指令也可以用在<code>#if...#elif...#else</code>的部分。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#if defined WIN32
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#elif defined MAC_OS
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#elif defined LINUX
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#error NOT support the operating system
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><h3 id="pragma">#pragma</h3>
<p><code>#pragma</code>指令用来修改编译器属性。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 使用 C99 标准
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#pragma c9x on
</span></span></span></code></pre></div><p>上面示例让编译器以 C99 标准进行编译。</p>
<h2 id="io函数">IO函数</h2>
<h3 id="缓存和字节流">缓存和字节流</h3>
<p>严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。</p>
<p>普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。</p>
<p>程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。</p>
<p>程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。</p>
<p>内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。</p>
<p>这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做字节流操作。</p>
<p>由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。</p>
<p>C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。</p>
<h3 id="printf">printf()</h3>
<p><code>printf()</code>是最常用的输出函数，用于屏幕输出，原型定义在头文件<code>stdio.h</code>。</p>
<h3 id="scanf">scanf()</h3>
<h4 id="基本用法-1">基本用法</h4>
<p><code>scanf()</code>函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。用户输入数据、按下回车键后，<code>scanf()</code>就会处理用户的输入，将其存入变量。它的原型定义在头文件<code>stdio.h</code>。</p>
<p><code>scanf()</code>的语法跟<code>printf()</code>类似。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>i);
</span></span></code></pre></div><p>上面示例中，<code>scanf()</code>的第一个参数<code>%d</code>，表示用户输入的应该是一个整数。<code>%d</code>就是一个占位符，<code>%</code>是占位符的标志，<code>d</code>表示整数。第二个参数<code>&amp;i</code>表示，将用户从键盘输入的整数存入变量<code>i</code>。</p>
<p>注意，变量前面必须加上<code>&amp;</code>运算符（指针变量除外），因为<code>scanf()</code>传递的不是值，而是地址，即将变量<code>i</code>的地址指向用户输入的值。如果这里的变量是指针变量（比如字符串变量），那就不用加<code>&amp;</code>运算符。</p>
<p>下面是一次将键盘输入读入多个变量的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d%d%f%f&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>i, <span style="color:#000;font-weight:bold">&amp;</span>j, <span style="color:#000;font-weight:bold">&amp;</span>x, <span style="color:#000;font-weight:bold">&amp;</span>y);
</span></span></code></pre></div><p>上面示例中，格式字符串<code>%d%d%f%f</code>，表示用户输入的前两个是整数，后两个是浮点数，比如<code>1 -20 3.4 -4.0e3</code>。这四个值依次放入<code>i</code>、<code>j</code>、<code>x</code>、<code>y</code>四个变量。</p>
<p><code>scanf()</code>处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响<code>scanf()</code>解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>-20
</span></span><span style="display:flex;"><span>3.4
</span></span><span style="display:flex;"><span>-4.0e3
</span></span></code></pre></div><p>上面示例中，用户分成四行输入，得到的结果与一行输入是完全一样的。每次按下回车键以后，<code>scanf()</code>就会开始解读，如果第一行匹配第一个占位符，那么下次按下回车键时，就会从第二个占位符开始解读。</p>
<p><code>scanf()</code>处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> x;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">float</span> y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 用户输入 &#34;    -13.45e12# 0&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>x);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%f&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>y);
</span></span></code></pre></div><p>上面示例中，<code>scanf()</code>读取用户输入时，<code>%d</code>占位符会忽略起首的空格，从<code>-</code>处开始获取数据，读取到<code>-13</code>停下来，因为后面的<code>.</code>不属于整数的有效字符。这就是说，占位符<code>%d</code>会读到<code>-13</code>。</p>
<p>第二次调用<code>scanf()</code>时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是<code>.</code>，由于对应的占位符是<code>%f</code>，会读取到<code>.45e12</code>，这是采用科学计数法的浮点数格式。后面的<code>#</code>不属于浮点数的有效字符，所以会停在这里。</p>
<p>由于<code>scanf()</code>可以连续处理多个占位符，所以上面的例子也可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d%f&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>x, <span style="color:#000;font-weight:bold">&amp;</span>y);
</span></span></code></pre></div><p><code>scanf()</code>的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回<code>0</code>。如果读取到文件结尾，则返回常量 EOF。</p>
<h4 id="占位符">占位符</h4>
<p><code>scanf()</code>常用的占位符如下，与<code>printf()</code>的占位符基本一致。</p>
<ul>
<li><code>%c</code>：字符。</li>
<li><code>%d</code>：整数。</li>
<li><code>%f</code>：<code>float</code>类型浮点数。</li>
<li><code>%lf</code>：<code>double</code>类型浮点数。</li>
<li><code>%Lf</code>：<code>long double</code>类型浮点数。</li>
<li><code>%s</code>：字符串。</li>
<li><code>%[]</code>：在方括号中指定一组匹配的字符（比如<code>%[0-9]</code>），遇到不在集合之中的字符，匹配将会停止。</li>
</ul>
<p>上面所有占位符之中，除了<code>%c</code>以外，都会自动忽略起首的空白字符。<code>%c</code>不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成<code>scanf(&quot; %c&quot;, &amp;ch)</code>，即<code>%c</code>前加上一个空格，表示跳过零个或多个空白字符。</p>
<p>下面要特别说一下占位符<code>%s</code>，它其实不能简单地等同于字符串。它的规则是，从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止。因为<code>%s</code>不会包含空白字符，所以无法用来读取多个单词，除非多个<code>%s</code>一起使用。这也意味着，<code>scanf()</code>不适合读取可能包含空格的字符串，比如书名或歌曲名。另外，<code>scanf()</code>遇到<code>%s</code>占位符，会在字符串变量末尾存储一个空字符<code>\0</code>。</p>
<p><code>scanf()</code>将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，使用<code>%s</code>占位符时，应该指定读入字符串的最长长度，即写成<code>%[m]s</code>，其中的<code>[m]</code>是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> name[<span style="color:#099">11</span>];
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%10s&#34;</span>, name);
</span></span></code></pre></div><p>上面示例中，<code>name</code>是一个长度为11的字符数组，<code>scanf()</code>的占位符<code>%10s</code>表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。</p>
<h4 id="赋值忽略符">赋值忽略符</h4>
<p>有时，用户的输入可能不符合预定的格式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d-%d-%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>year, <span style="color:#000;font-weight:bold">&amp;</span>month, <span style="color:#000;font-weight:bold">&amp;</span>day);
</span></span></code></pre></div><p>上面示例中，如果用户输入<code>2020-01-01</code>，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如<code>2020/01/01</code>，这种情况下，<code>scanf()</code>解析数据就会失败。</p>
<p>为了避免这种情况，<code>scanf()</code>提供了一个赋值忽略符（assignment suppression character）<code>*</code>。只要把<code>*</code>加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%d%*c%d%*c%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>year, <span style="color:#000;font-weight:bold">&amp;</span>month, <span style="color:#000;font-weight:bold">&amp;</span>day);
</span></span></code></pre></div><p>上面示例中，<code>%*c</code>就是在占位符的百分号后面，加入了赋值忽略符<code>*</code>，表示这个占位符没有对应的变量，解读后不必返回。</p>
<h3 id="sscanf">sscanf()</h3>
<p><code>sscanf()</code>函数与<code>scanf()</code>很类似，不同之处是<code>sscanf()</code>从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件<code>stdio.h</code>里面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">sscanf</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> format, ...);
</span></span></code></pre></div><p><code>sscanf()</code>的第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与<code>scanf()</code>相同。</p>
<p><code>sscanf()</code>主要用来处理其他输入函数读入的字符串，从其中提取数据。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">fgets</span>(str, <span style="color:#000;font-weight:bold">sizeof</span>(str), stdin);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sscanf</span>(str, <span style="color:#d14">&#34;%d%d&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>i, <span style="color:#000;font-weight:bold">&amp;</span>j);
</span></span></code></pre></div><p>上面示例中，<code>fgets()</code>先从标准输入获取了一行数据，存入字符数组<code>str</code>。然后，<code>sscanf()</code>再从字符串<code>str</code>里面提取两个整数，放入变量<code>i</code>和<code>j</code>。</p>
<p><code>sscanf()</code>的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像<code>scanf()</code>的数据来源是流数据，只能读取一次。</p>
<p><code>sscanf()</code>的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。</p>
<h3 id="getcharputchar">getchar()，putchar()</h3>
<p><strong>（1）getchar()</strong></p>
<p><code>getchar()</code>函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用<code>scanf()</code>方法读取一个字符。它的原型定义在头文件<code>stdio.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> ch;
</span></span><span style="display:flex;"><span>ch <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">scanf</span>(<span style="color:#d14">&#34;%c&#34;</span>, <span style="color:#000;font-weight:bold">&amp;</span>ch);
</span></span></code></pre></div><p><code>getchar()</code>不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是<code>-1</code>，所以返回值的类型要设为 int，而不是 char。</p>
<p>由于<code>getchar()</code>返回读取的字符，所以可以用在循环条件之中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> (<span style="color:#900;font-weight:bold">getchar</span>() <span style="color:#000;font-weight:bold">!=</span> <span style="color:#d14">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>  ;
</span></span></code></pre></div><p>上面示例中，只有读到的字符等于换行符（<code>\n</code>），才会退出循环，常用来跳过某行。<code>while</code>循环的循环体没有任何语句，表示对该行不执行任何操作。</p>
<p>下面的例子是计算某一行的字符长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> len <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span>(<span style="color:#900;font-weight:bold">getchar</span>() <span style="color:#000;font-weight:bold">!=</span> <span style="color:#d14">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>  len<span style="color:#000;font-weight:bold">++</span>;
</span></span></code></pre></div><p>上面示例中，<code>getchar()</code>每读取一个字符，长度变量<code>len</code>就会加1，直到读取到换行符为止，这时<code>len</code>就是该行的字符长度。</p>
<p>下面的例子是跳过空格字符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> ((ch <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">getchar</span>()) <span style="color:#000;font-weight:bold">==</span> <span style="color:#d14">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>  ;
</span></span></code></pre></div><p>上面示例中，结束循环后，变量<code>ch</code>等于第一个非空格字符。</p>
<p><strong>（2）putchar()</strong></p>
<p><code>putchar()</code>函数将它的参数字符输出到屏幕，等同于使用<code>printf()</code>输出一个字符。它的原型定义在头文件<code>stdio.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">putchar</span>(ch);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%c&#34;</span>, ch);
</span></span></code></pre></div><p>操作成功时，<code>putchar()</code>返回输出的字符，否则返回常量 EOF。</p>
<p><strong>（3）小结</strong></p>
<p>由于<code>getchar()</code>和<code>putchar()</code>这两个函数的用法，要比<code>scanf()</code>和<code>printf()</code>更简单，而且通常是用宏来实现，所以要比<code>scanf()</code>和<code>printf()</code>更快。如果操作单个字符，建议优先使用这两个函数。</p>
<h3 id="puts">puts()</h3>
<p><code>puts()</code>函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。它的原型定义在头文件<code>stdio.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-v" data-lang="v"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(<span style="color:#d14">&#34;Here are some messages:&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(<span style="color:#d14">&#34;Hello World&#34;</span>);
</span></span></code></pre></div><p>上面示例中，<code>puts()</code>在屏幕上输出两行内容。</p>
<p>写入成功时，<code>puts()</code>返回一个非负整数，否则返回常量 EOF。</p>
<h3 id="gets">gets()</h3>
<p><code>gets()</code>函数以前用于从<code>stdin</code>读取整行输入，现在已经被废除了，仍然放在这里介绍一下。</p>
<p>该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符<code>\0</code>，使其成为一个字符串。</p>
<p>它经常与<code>puts()</code>配合使用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> words[<span style="color:#099">81</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">puts</span>(<span style="color:#d14">&#34;Enter a string, please&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">gets</span>(words);
</span></span></code></pre></div><p>上面示例使用<code>puts()</code>在屏幕上输出提示，然后使用<code>gets()</code>获取用户的输入。</p>
<p>由于<code>gets()</code>获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用<code>fgets()</code>。</p>
<h2 id="错误处理">错误处理</h2>
<p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回<code>1</code>或<code>NULL</code>，同时会设置一个错误代码<code>errno</code>，该错误代码是全局变量，表示在函数调用期间发生了错误，可以在<code>errno.h</code>头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把<code>errno</code>设置为<code>0</code>，这是一种良好的编程习惯。<code>0</code>值表示程序中没有错误。</p>
<p>C 语言提供了<code>perror()</code>和<code>strerror()</code>函数来显示与<code>errno</code>相关的文本消息。</p>
<ul>
<li><code>perror()</code>函数显示您传给它的字符串，后跟一个冒号、一个空格和当前<code>errno</code>值的文本表示形式。</li>
<li><code>strerror()</code>函数，返回一个指针，指针指向当前<code>errno</code>值的文本表示形式。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;errno.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> errno ;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span> () {
</span></span><span style="display:flex;"><span>   FILE <span style="color:#000;font-weight:bold">*</span> pf;
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> errnum;
</span></span><span style="display:flex;"><span>   pf <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">fopen</span> (<span style="color:#d14">&#34;unexist.txt&#34;</span>, <span style="color:#d14">&#34;rb&#34;</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">if</span> (pf <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>      errnum <span style="color:#000;font-weight:bold">=</span> errno;
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">fprintf</span>(stderr, <span style="color:#d14">&#34;错误号: %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, errno);
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">perror</span>(<span style="color:#d14">&#34;通过 perror 输出错误&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">fprintf</span>(stderr, <span style="color:#d14">&#34;打开文件错误: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">strerror</span>( errnum ));
</span></span><span style="display:flex;"><span>   } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">fclose</span> (pf);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值<code>EXIT_SUCCESS</code>，<code>EXIT_SUCCESS</code>是宏，它被定义为<code>0</code>；如果程序中存在一种错误情况，当退出程序时，会带有状态值<code>EXIT_FAILURE</code>，被定义为<code>-1</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> dividend <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">20</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> divisor <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">int</span> quotient;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">if</span>( divisor <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">fprintf</span>(stderr, <span style="color:#d14">&#34;除数为 0 退出运行...</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#900;font-weight:bold">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   quotient <span style="color:#000;font-weight:bold">=</span> dividend <span style="color:#000;font-weight:bold">/</span> divisor;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// quotient 变量的值为 : 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>   <span style="color:#900;font-weight:bold">fprintf</span>(stderr, <span style="color:#d14">&#34;quotient 变量的值为: %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, quotient );
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>   <span style="color:#900;font-weight:bold">exit</span>(EXIT_SUCCESS);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多文件项目">多文件项目</h2>
<p>一个软件项目往往包含多个源码文件，编译时需要将这些文件一起编译，生成一个可执行文件。</p>
<p>假定一个项目有两个源码文件<code>foo.c</code>和<code>bar.c</code>，其中<code>foo.c</code>是主文件，<code>bar.c</code>是库文件。所谓“主文件”，就是包含了<code>main()</code>函数的项目入口文件，里面会引用库文件定义的各种函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File foo.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">add</span>(<span style="color:#099">2</span>, <span style="color:#099">3</span>));  <span style="color:#998;font-style:italic">// 5!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面代码中，主文件<code>foo.c</code>调用了函数<code>add()</code>，这个函数是在库文件<code>bar.c</code>里面定义的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File bar.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> x, <span style="color:#458;font-weight:bold">int</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在，将这两个文件一起编译。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -o foo foo.c bar.c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 更省事的写法</span>
</span></span><span style="display:flex;"><span>$ gcc -o foo *.c
</span></span></code></pre></div><p>上面命令中，gcc 的<code>-o</code>参数指定生成的二进制可执行文件的文件名，本例是<code>foo</code>。</p>
<p>这个命令运行后，编译器会发出警告，原因是在编译<code>foo.c</code>的过程中，编译器发现一个不认识的函数<code>add()</code>，<code>foo.c</code>里面没有这个函数的原型或者定义。因此，最好修改一下<code>foo.c</code>，在文件头部加入<code>add()</code>的原型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File foo.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">add</span>(<span style="color:#099">2</span>, <span style="color:#099">3</span>));  <span style="color:#998;font-style:italic">// 5!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>现在再编译就没有警告了。</p>
<p>你可能马上就会想到，如果有多个文件都使用这个函数<code>add()</code>，那么每个文件都需要加入函数原型。一旦需要修改函数<code>add()</code>（比如改变参数的数量），就会非常麻烦，需要每个文件逐一改动。所以，通常的做法是新建一个专门的头文件<code>bar.h</code>，放置所有在<code>bar.c</code>里面定义的函数的原型。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File bar.h
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span></code></pre></div><p>然后使用<code>include</code>命令，在用到这个函数的源码文件里面加载这个头文件<code>bar.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File foo.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;bar.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">add</span>(<span style="color:#099">2</span>, <span style="color:#099">3</span>));  <span style="color:#998;font-style:italic">// 5!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>上面代码中，<code>#include &quot;bar.h&quot;</code>表示加入头文件<code>bar.h</code>。这个文件没有放在尖括号里面，表示它是用户提供的；它没有写路径，就表示与当前源码文件在同一个目录。</p>
<p>然后，最好在<code>bar.c</code>里面也加载这个头文件，这样可以让编译器验证，函数原型与函数定义是否一致。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File bar.c
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;bar.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> a, <span style="color:#458;font-weight:bold">int</span> b) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> a <span style="color:#000;font-weight:bold">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在重新编译，就可以顺利得到二进制可执行文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -o foo foo.c bar.c
</span></span></code></pre></div><h3 id="重复加载">重复加载</h3>
<p>头文件里面还可以加载其他头文件，因此有可能产生重复加载。比如，<code>a.h</code>和<code>b.h</code>都加载了<code>c.h</code>，然后<code>foo.c</code>同时加载了<code>a.h</code>和<code>b.h</code>，这意味着<code>foo.c</code>会编译两次<code>c.h</code>。</p>
<p>最好避免这种重复加载，虽然多次定义同一个函数原型并不会报错，但是有些语句重复使用会报错，比如多次重复定义同一个 Struct 数据结构。解决重复加载的常见方法是，在头文件里面设置一个专门的宏，加载时一旦发现这个宏存在，就不再继续加载当前文件了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// File bar.h
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#ifndef BAR_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#999;font-weight:bold;font-style:italic">#define BAR_H
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>  <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>上面示例中，头文件<code>bar.h</code>使用<code>#ifndef</code>和<code>#endif</code>设置了一个条件判断。每当加载这个头文件时，就会执行这个判断，查看有没有设置过宏<code>BAR_H</code>。如果设置过了，表明这个头文件已经加载过了，就不再重复加载了，反之就先设置一下这个宏，然后加载函数原型。</p>
<h3 id="extern-说明符">extern 说明符</h3>
<p>当前文件还可以使用其他文件定义的变量，这时要使用<code>extern</code>说明符，在当前文件中声明，这个变量是其他文件定义的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> myVar;
</span></span></code></pre></div><p>上面示例中，<code>extern</code>说明符告诉编译器，变量<code>myvar</code>是其他脚本文件声明的，不需要在这里为它分配内存空间。</p>
<p>由于不需要分配内存空间，所以<code>extern</code>声明数组时，不需要给出数组长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> a[];
</span></span></code></pre></div><p>这种共享变量的声明，可以直接写在源码文件里面，也可以放在头文件中，通过<code>#include</code>指令加载。</p>
<h3 id="static-说明符">static 说明符</h3>
<p>正常情况下，当前文件内部的全局变量，可以被其他文件使用。有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。</p>
<p>这时可以在声明变量的时候，使用<code>static</code>关键字，使得该变量变成当前文件的私有变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> foo <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;
</span></span></code></pre></div><p>上面示例中，变量<code>foo</code>只能在当前文件里面使用，其他文件不能引用。</p>
<h3 id="编译策略">编译策略</h3>
<p>多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间。</p>
<p>为了节省时间，通常的做法是将编译拆分成两个步骤。第一步，使用 GCC 的<code>-c</code>参数，将每个源码文件单独编译为对象文件（object file）。第二步，将所有对象文件链接在一起，合并生成一个二进制可执行文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ gcc -c foo.c <span style="color:#998;font-style:italic"># 生成 foo.o</span>
</span></span><span style="display:flex;"><span>$ gcc -c bar.c <span style="color:#998;font-style:italic"># 生成 bar.o</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># 更省事的写法</span>
</span></span><span style="display:flex;"><span>$ gcc -c *.c
</span></span></code></pre></div><p>上面命令为源码文件<code>foo.c</code>和<code>bar.c</code>，分别生成对象文件<code>foo.o</code>和<code>bar.o</code>。</p>
<p>对象文件不是可执行文件，只是编译过程中的一个阶段性产物，文件名与源码文件相同，但是后缀名变成了<code>.o</code>。</p>
<p>得到所有的对象文件以后，再次使用<code>gcc</code>命令，将它们通过链接，合并生成一个可执行文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2">$</span> gcc <span style="color:#000;font-weight:bold">-</span>o foo foo.o bar.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"># 更省事的写法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#a61717;background-color:#e3d2d2">$</span> gcc <span style="color:#000;font-weight:bold">-</span>o foo <span style="color:#000;font-weight:bold">*</span>.o
</span></span></code></pre></div><p>以后，修改了哪一个源文件，就将这个文件重新编译成对象文件，其他文件不用重新编译，可以继续使用原来的对象文件，最后再将所有对象文件重新链接一次就可以了。由于链接的耗时大大短于编译，这样做就节省了大量时间。</p>
<h3 id="make-命令">make 命令</h3>
<p>大型项目的编译，如果全部手动完成，是非常麻烦的，容易出错。一般会使用专门的自动化编译工具，比如 make。</p>
<p>make 是一个命令行工具，使用时会自动在当前目录下搜索配置文件 makefile（也可以写成 Makefile）。该文件定义了所有的编译规则，每个编译规则对应一个编译产物。为了得到这个编译产物，它需要知道两件事。</p>
<ul>
<li>依赖项（生成该编译产物，需要用到哪些文件）</li>
<li>生成命令（生成该编译产物的命令）</li>
</ul>
<p>比如，对象文件<code>foo.o</code>是一个编译产物，它的依赖项是<code>foo.c</code>，生成命令是<code>gcc -c foo.c</code>。对应的编译规则如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">foo.o</span><span style="color:#000;font-weight:bold">:</span> foo.c
</span></span><span style="display:flex;"><span>  gcc -c foo.c
</span></span></code></pre></div><p>上面示例中，编译规则由两行组成。第一行首先是编译产物，冒号后面是它的依赖项，第二行则是生成命令。</p>
<p>注意，第二行的缩进必须使用 Tab 键，如果使用空格键会报错。</p>
<p>完整的配置文件 makefile 由多个编译规则组成，可能是下面的样子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">foo</span><span style="color:#000;font-weight:bold">:</span> foo.o bar.o
</span></span><span style="display:flex;"><span>  gcc -o foo foo.o bar.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">foo.o</span><span style="color:#000;font-weight:bold">:</span> bar.h foo.c
</span></span><span style="display:flex;"><span>  gcc -c foo.c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">bar.o</span><span style="color:#000;font-weight:bold">:</span> bar.h bar.c
</span></span><span style="display:flex;"><span>  gcc -c bar.c
</span></span></code></pre></div><p>上面是 makefile 的一个示例文件。它包含三个编译规则，对应三个编译产物（<code>foo.o</code>、<code>bar.o</code>和<code>foo</code>），每个编译规则之间使用空行分隔。</p>
<p>有了 makefile，编译时，只要在 make 命令后面指定编译目标（编译产物的名字），就会自动调用对应的编译规则。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make foo.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># or</span>
</span></span><span style="display:flex;"><span>make bar.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># or</span>
</span></span><span style="display:flex;"><span>make foo
</span></span></code></pre></div><p>上面示例中，make 命令会根据不同的命令，生成不同的编译产物。</p>
<p>如果省略了编译目标，<code>make</code>命令会执行第一条编译规则，构建相应的产物。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make
</span></span></code></pre></div><p>上面示例中，<code>make</code>后面没有编译目标，所以会执行 makefile 的第一条编译规则，本例是<code>make foo</code>。由于用户期望执行<code>make</code>后得到最终的可执行文件，所以建议总是把最终可执行文件的编译规则，放在 makefile 文件的第一条。makefile 本身对编译规则没有顺序要求。</p>
<p>make 命令的强大之处在于，它不是每次执行命令，都会进行编译，而是会检查是否有必要重新编译。具体方法是，通过检查每个源码文件的时间戳，确定在上次编译之后，哪些文件发生过变动。然后，重新编译那些受到影响的编译产物（即编译产物直接或间接依赖于那些发生变动的源码文件），不受影响的编译产物，就不会重新编译。</p>
<p>举例来说，上次编译之后，修改了<code>foo.c</code>，没有修改<code>bar.c</code>和<code>bar.h</code>。于是，重新运行<code>make foo</code>命令时，Make 就会发现<code>bar.c</code>和<code>bar.h</code>没有变动过，因此不用重新编译<code>bar.o</code>，只需要重新编译<code>foo.o</code>。有了新的<code>foo.o</code>以后，再跟<code>bar.o</code>一起，重新编译成新的可执行文件<code>foo</code>。</p>
<p>Make 这样设计的最大好处，就是自动处理编译过程，只重新编译变动过的文件，因此大大节省了时间。</p>
<h2 id="变量说明符">变量说明符</h2>
<h3 id="const">const</h3>
<p><code>const</code>说明符表示变量是只读的，不得被修改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">double</span> PI <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.14159</span>;
</span></span><span style="display:flex;"><span>PI <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例里面的<code>const</code>，表示变量<code>PI</code>的值不应改变。如果改变的话，编译器会报错。</p>
<p>对于数组，<code>const</code>表示数组成员不能修改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> arr[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>};
</span></span><span style="display:flex;"><span>arr[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>const</code>使得数组<code>arr</code>的成员无法修改。</p>
<p>对于指针变量，<code>const</code>有两种写法，含义是不一样的。如果<code>const</code>在<code>*</code>前面，表示指针指向的值不可修改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// const 表示指向的值 *x 不能修改
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">const</span> <span style="color:#000;font-weight:bold">*</span> x
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 或者
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span> x
</span></span></code></pre></div><p>下面示例中，对<code>x</code>指向的值进行修改导致报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#000;font-weight:bold">*</span>x)<span style="color:#000;font-weight:bold">++</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>如果<code>const</code>在<code>*</code>后面，表示指针包含的地址不可修改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// const 表示地址 x 不能修改
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">const</span> x
</span></span></code></pre></div><p>下面示例中，对<code>x</code>进行修改导致报错。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> p <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">const</span> x <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x<span style="color:#000;font-weight:bold">++</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>这两者可以结合起来。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">const</span> x;
</span></span></code></pre></div><p>上面示例中，指针变量<code>x</code>指向一个字符串。两个<code>const</code>意味着，<code>x</code>包含的内存地址以及<code>x</code>指向的字符串，都不能修改。</p>
<p><code>const</code>的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加<code>const</code>说明符。这样的话，使用这个函数的人看到原型里面的<code>const</code>，就知道调用函数前后，参数数组保持不变。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">find</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> arr, <span style="color:#458;font-weight:bold">int</span> n);
</span></span></code></pre></div><p>上面示例中，函数<code>find</code>的参数数组<code>arr</code>有<code>const</code>说明符，就说明该数组在函数内部将保持不变。</p>
<p>有一种情况需要注意，如果一个指针变量指向<code>const</code>变量，那么该指针变量也不应该被修改。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> j <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>i;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">*</span>j <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">2</span>; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，<code>j</code>是一个指针变量，指向变量<code>i</code>，即<code>j</code>和<code>i</code>指向同一个地址。<code>j</code>本身没有<code>const</code>说明符，但是<code>i</code>有。这种情况下，<code>j</code>指向的值也不能被修改。</p>
<h3 id="static">static</h3>
<p><code>static</code>说明符对于全局变量和局部变量有不同的含义。</p>
<p>（1）用于局部变量（位于块作用域内部）。</p>
<p><code>static</code>用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度。</p>
<p>（2）用于全局变量（位于块作用域外部）。</p>
<p><code>static</code>用于函数外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。</p>
<p><code>static</code>修饰的变量，初始化时，值不能等于变量，必须是常量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> n <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> m <span style="color:#000;font-weight:bold">=</span> n; <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>上面示例中，变量<code>m</code>有<code>static</code>修饰，它的值如果等于变量<code>n</code>，就会报错，必须等于常量。</p>
<p>只在当前文件里面使用的函数，可以声明为<code>static</code>，表明该函数只在当前文件使用，其他文件可以定义同名函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">g</span>(<span style="color:#458;font-weight:bold">int</span> i);
</span></span></code></pre></div><h3 id="auto">auto</h3>
<p><code>auto</code>说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。</p>
<p>由于只要不是<code>extern</code>的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">auto</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a;
</span></span></code></pre></div><h3 id="extern">extern</h3>
<p><code>extern</code>说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。通常用来表示，该变量是多个文件共享的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span></code></pre></div><p>上面代码中，<code>a</code>是<code>extern</code>变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。</p>
<p>但是，变量声明时，同时进行初始化，<code>extern</code>就会无效。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// extern 无效
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span></code></pre></div><p>上面代码中，<code>extern</code>对变量初始化的声明是无效的。这是为了防止多个<code>extern</code>对同一个变量进行多次初始化。</p>
<p>函数内部使用<code>extern</code>声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。</p>
<p>函数本身默认是<code>extern</code>，即该函数可以被外部文件共享，通常省略<code>extern</code>不写。如果只希望函数在当前文件可用，那就需要在函数前面加上<code>static</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">int</span> i);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 等同于
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">f</span>(<span style="color:#458;font-weight:bold">int</span> i);
</span></span></code></pre></div><h3 id="register">register</h3>
<p><code>register</code>说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">register</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span></code></pre></div><p>上面示例中，<code>register</code>提示编译器，变量<code>a</code>会经常用到，要为它提供最快的读取速度。</p>
<p><code>register</code>只对声明在代码块内部的变量有效。</p>
<p>设为<code>register</code>的变量，不能获取它的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">register</span> <span style="color:#458;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>a; <span style="color:#998;font-style:italic">// 编译器报错
</span></span></span></code></pre></div><p>上面示例中，<code>&amp;a</code>会报错，因为变量<code>a</code>可能放在寄存器里面，无法获取内存地址。</p>
<p>如果数组设为<code>register</code>，也不能获取整个数组或任一个数组成员的地址。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">register</span> <span style="color:#458;font-weight:bold">int</span> a[] <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">11</span>, <span style="color:#099">22</span>, <span style="color:#099">33</span>, <span style="color:#099">44</span>, <span style="color:#099">55</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> p <span style="color:#000;font-weight:bold">=</span> a;  <span style="color:#998;font-style:italic">// 报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>(a <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">2</span>); <span style="color:#998;font-style:italic">// 报错
</span></span></span></code></pre></div><p>历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步，会尽可能优化代码，按照自己的规则决定怎么利用好寄存器，取得最佳的执行速度，所以可能会忽视代码里面的<code>register</code>说明符，不保证一定会把这些变量放到寄存器。</p>
<h3 id="volatile">volatile</h3>
<p><code>volatile</code>说明符表示所声明的变量，可能会预想不到地发生变化（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">volatile</span> <span style="color:#458;font-weight:bold">int</span> foo;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">volatile</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> bar;
</span></span></code></pre></div><p><code>volatile</code>的目的是阻止编译器对变量行为进行优化，请看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> foo <span style="color:#000;font-weight:bold">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 其他语句，假设没有改变 x 的值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> bar <span style="color:#000;font-weight:bold">=</span> x;
</span></span></code></pre></div><p>上面代码中，由于变量<code>foo</code>和<code>bar</code>都等于<code>x</code>，而且<code>x</code>的值也没有发生变化，所以编译器可能会把<code>x</code>放入缓存，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对<code>foo</code>和<code>bar</code>进行赋值。如果<code>x</code>被设定为<code>volatile</code>，编译器就不会把它放入缓存，每次都从原始位置去取<code>x</code>的值，因为在两次读取之间，其他程序可能会改变<code>x</code>。</p>
<h3 id="restrict">restrict</h3>
<p><code>restrict</code>说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> pt <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>) <span style="color:#900;font-weight:bold">malloc</span>(<span style="color:#099">10</span> <span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">sizeof</span>(<span style="color:#458;font-weight:bold">int</span>));
</span></span></code></pre></div><p>上面示例中，<code>restrict</code>表示变量<code>pt</code>是访问 malloc 所分配内存的唯一方式。</p>
<p>下面例子的变量<code>foo</code>，就不能使用<code>restrict</code>修饰符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> foo[<span style="color:#099">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> bar <span style="color:#000;font-weight:bold">=</span> foo;
</span></span></code></pre></div><p>上面示例中，变量<code>foo</code>指向的内存，可以用<code>foo</code>访问，也可以用<code>bar</code>访问，因此就不能将<code>foo</code>设为 restrict。</p>
<p>如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。</p>
<p><code>restrict</code>用于函数参数时，表示参数的内存地址之间没有重叠。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">swap</span>(<span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> a, <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">restrict</span> b) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">int</span> t;
</span></span><span style="display:flex;"><span>  t <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>a;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>a <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>b;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">*</span>b <span style="color:#000;font-weight:bold">=</span> t;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，函数参数声明里的<code>restrict</code>表示，参数<code>a</code>和参数<code>b</code>的内存地址没有重叠。</p>
<h2 id="多字节字符">多字节字符</h2>
<h3 id="unicode-简介">Unicode 简介</h3>
<p>C 语言诞生时，只考虑了英语字符，使用7位的 ASCII 码表示所有字符。ASCII 码的范围是0到127，也就是最多只能表示100多个字符，用一个字节就可以表示，所以<code>char</code>类型只占用一个字节。</p>
<p>但是，如果处理非英语字符，一个字节就不够了，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示。</p>
<p>最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 Unicode 编码，将所有字符放入一个字符集。</p>
<p>Unicode 为每个字符提供一个号码，称为码点（code point），其中0到127的部分，跟 ASCII 码是重合的。通常使用“U+十六进制码点”表示一个字符，比如<code>U+0041</code>表示字母<code>A</code>。</p>
<p>Unicode 编码目前一共包含了100多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍。</p>
<p>为了适应不同的使用需求，Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点。</p>
<ul>
<li>UTF-8：使用1个到4个字节，表示一个码点。不同的字符占用的字节数不一样。</li>
<li>UTF-16：对于U+0000 到 U+FFFF 的字符（称为基本平面），使用2个字节表示一个码点。其他字符使用4个字节。</li>
<li>UTF-32：统一使用4个字节，表示一个码点。</li>
</ul>
<p>其中，UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样。</p>
<p>C 语言提供了两个宏，表示当前系统支持的编码字节长度。这两个宏都定义在头文件<code>limits.h</code>。</p>
<ul>
<li><code>MB_LEN_MAX</code>：任意支持地区的最大字节长度，定义在<code>limits.h</code>。</li>
<li><code>MB_CUR_MAX</code>：当前语言的最大字节长度，总是小于或等于<code>MB_LEN_MAX</code>，定义在<code>stdlib.h</code>。</li>
</ul>
<h3 id="字符的表示方法">字符的表示方法</h3>
<p>字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符。</p>
<p>C 语言提供了不同的写法，用来表示字符的整数号码。</p>
<ul>
<li><code>\123</code>：以八进制值表示一个字符，斜杠后面需要三个数字。</li>
<li><code>\x4D</code>：以十六进制表示一个字符，<code>\x</code>后面是十六进制整数。</li>
<li><code>\u2620</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\u</code>后面需要4个字符。</li>
<li><code>\U0001243F</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\U</code>后面需要8个字符。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;ABC</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\101\102\103\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\x41\x42\x43\n</span><span style="color:#d14">&#34;</span>);
</span></span></code></pre></div><p>上面三行都会输出“ABC”。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\u2022</span><span style="color:#d14"> Bullet 1</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\U00002022</span><span style="color:#d14"> Bullet 1</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span></code></pre></div><p>上面两行都会输出“• Bullet 1”。</p>
<h3 id="多字节字符的表示">多字节字符的表示</h3>
<p>C 语言预设只有基本字符，才能使用字面量表示，其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法。</p>
<p>所谓基本字符，指的是所有可打印的 ASCII 字符，但是有三个字符除外：<code>@</code>、<code>$</code>、`。</p>
<p>因此，遇到非英语字符，应该将其写成 Unicode 码点形式。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;</span><span style="color:#d14">\u6625\u5929</span><span style="color:#d14">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s); <span style="color:#998;font-style:italic">// 春天
</span></span></span></code></pre></div><p>上面代码会输出中文“春天”。</p>
<p>如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);
</span></span></code></pre></div><p>注意，<code>\u + 码点</code>和<code>\U + 码点</code>的写法，不能用来表示 ASCII 码字符（码点小于<code>0xA0</code>的字符），只有三个字符除外：<code>0x24</code>（<code>$</code>），<code>0x40</code>（<code>@</code>）和<code>0x60</code>（```）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;</span><span style="color:#d14">\u0024\u0040\u0060</span><span style="color:#d14">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);  <span style="color:#998;font-style:italic">// @$`
</span></span></span></code></pre></div><p>上面代码会输出三个 Unicode 字符“@$`”，但是其它 ASCII 字符都不能用这种表示法表示。</p>
<p>为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地化环境。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span></code></pre></div><p>上面代码中，使用<code>setlocale()</code>切换执行环境到系统的本地化语言。<code>setlocale()</code>的原型定义在头文件<code>locale.h</code>，详见标准库部分的《locale.h》章节。</p>
<p>像下面这样，指定编码语言也可以。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;zh_CN.UTF-8&#34;</span>);
</span></span></code></pre></div><p>上面代码将程序执行环境，切换到中文环境的 UTF-8 编码。</p>
<p>C 语言允许使用<code>u8</code>前缀，对多字节字符串指定编码方式为 UTF-8。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> u8<span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);
</span></span></code></pre></div><p>一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">strlen</span>(s)); <span style="color:#998;font-style:italic">// 6
</span></span></span></code></pre></div><p>上面示例中，字符串<code>s</code>只包含两个字符，但是<code>strlen()</code>返回的结果却是6，表示这两个字符一共占据了6个字节。</p>
<p>C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效，比如<code>strtok()</code>、<code>strchr()</code>、<code>strspn()</code>、<code>toupper()</code>、<code>tolower()</code>、<code>isalpha()</code>等不会得到正确结果。</p>
<h3 id="宽字符">宽字符</h3>
<p>上一小节的多字节字符串，每个字符的字节宽度是可变的。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符（wide character）。</p>
<p>所谓“宽字符”，就是每个字符占用的字节数是固定的，要么是2个字节，要么是4个字节。这样的话，就很容易快速处理。</p>
<p>宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为16位（2个字节）或32位（4个字节），足以容纳当前系统的所有字符。它定义在头文件<code>wchar.h</code>里面。</p>
<p>宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">L</span><span style="color:#d14">&#39;牛&#39;</span><span style="color:#a61717;background-color:#e3d2d2">；</span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%lc</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">L</span><span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%ls</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);
</span></span></code></pre></div><p>上面示例中，前缀“L”在单引号前面，表示宽字符，对应<code>printf()</code>的占位符为<code>%lc</code>；在双引号前面，表示宽字符串，对应<code>printf()</code>的占位符为<code>%ls</code>。</p>
<p>宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节。</p>
<p>处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件<code>wchar.h</code>。</p>
<h3 id="多字节字符处理函数">多字节字符处理函数</h3>
<h4 id="mblen">mblen()</h4>
<p><code>mblen()</code>函数返回一个多字节字符占用的字节数。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">mblen</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbstr, <span style="color:#458;font-weight:bold">size_t</span> n);
</span></span></code></pre></div><p>它接受两个参数，第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用<code>MB_CUR_MAX</code>。</p>
<p>它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回<code>0</code>；如果当前字符不是有效的多字节字符，则返回<code>-1</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbs1 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">mblen</span>(mbs1, MB_CUR_MAX)); <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbs2 <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">mblen</span>(mbs2, MB_CUR_MAX)); <span style="color:#998;font-style:italic">// 1
</span></span></span></code></pre></div><p>上面示例中，字符串“春天”的第一个字符“春”，占用3个字节；字符串“abc”的第一个字符“a”，占用1个字节。</p>
<h4 id="wctomb">wctomb()</h4>
<p><code>wctomb()</code>函数（wide character to multibyte）用于将宽字符转为多字节字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">wctomb</span>(<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> s, <span style="color:#458;font-weight:bold">wchar_t</span> wc);
</span></span></code></pre></div><p><code>wctomb()</code>接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回<code>-1</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span> wc <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">L</span><span style="color:#d14">&#39;牛&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> mbStr[<span style="color:#099">10</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">wctomb</span>(mbStr, wc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, mbStr);  <span style="color:#998;font-style:italic">// 牛
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, nBytes);  <span style="color:#998;font-style:italic">// 3
</span></span></span></code></pre></div><p>上面示例中，<code>wctomb()</code>将宽字符“牛”转为多字节字符，<code>wctomb()</code>的返回值表示转换后的多字节字符占用3个字节。</p>
<h4 id="mbtowc">mbtowc()</h4>
<p><code>mbtowc()</code>用于将多字节字符转为宽字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">mbtowc</span>(
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> wchar,
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbchar,
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">size_t</span> count
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>它接受3个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数。</p>
<p>它的返回值是多字节字符的字节数，如果转换失败，则返回<code>-1</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbchar <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;牛&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span> wc;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> pwc <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">&amp;</span>wc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">mbtowc</span>(pwc, mbchar, <span style="color:#099">3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, nBytes); <span style="color:#998;font-style:italic">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%lc</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>pwc);  <span style="color:#998;font-style:italic">// 牛
</span></span></span></code></pre></div><p>上面示例中，<code>mbtowc()</code>将多字节字符“牛”转为宽字符<code>wc</code>，返回值是<code>mbchar</code>占用的字节数（占用3个字节）。</p>
<h4 id="wcstombs">wcstombs()</h4>
<p><code>wcstombs()</code>用来将宽字符串转换为多字节字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">size_t</span> <span style="color:#900;font-weight:bold">wcstombs</span>(
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbstr,
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> wcstr,
</span></span><span style="display:flex;"><span>   <span style="color:#458;font-weight:bold">size_t</span> count
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>它接受三个参数，第一个参数<code>mbstr</code>是目标的多字节字符串指针，第二个参数<code>wcstr</code>是待转换的宽字符串指针，第三个参数<code>count</code>是用来存储多字节字符串的最大字节数。</p>
<p>如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回<code>-1</code>。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> mbs[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> wcs <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">L</span><span style="color:#d14">&#34;春天&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">wcstombs</span>(mbs, wcs, <span style="color:#099">20</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, mbs); <span style="color:#998;font-style:italic">// 春天
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, nBytes); <span style="color:#998;font-style:italic">// 6
</span></span></span></code></pre></div><p>上面示例中，<code>wcstombs()</code>将宽字符串<code>wcs</code>转为多字节字符串<code>mbs</code>，返回值<code>6</code>表示写入<code>mbs</code>的字符串占用6个字节，不包括尾部的字符串终止符。</p>
<p>如果<code>wcstombs()</code>的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数。</p>
<h4 id="mbstowcs">mbstowcs()</h4>
<p><code>mbstowcs()</code>用来将多字节字符串转换为宽字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">size_t</span> <span style="color:#900;font-weight:bold">mbstowcs</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">wchar_t</span><span style="color:#000;font-weight:bold">*</span> wcstr,
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbstr,
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">size_t</span> count
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>它接受三个参数，第一个参数<code>wcstr</code>是目标宽字符串，第二个参数<code>mbstr</code>是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数。</p>
<p>转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回<code>-1</code>。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的。</p>
<p>下面是一个例子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">setlocale</span>(LC_ALL, <span style="color:#d14">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> mbs <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;天气不错&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">wchar_t</span> wcs[<span style="color:#099">20</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>nBytes <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">mbstowcs</span>(wcs, mbs, <span style="color:#099">20</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%ls</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, wcs); <span style="color:#998;font-style:italic">// 天气不错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, nBytes); <span style="color:#998;font-style:italic">// 4
</span></span></span></code></pre></div><p>上面示例中，多字节字符串<code>mbs</code>被<code>mbstowcs()</code>转为宽字符串，成功转换了4个字符，所以该函数的返回值为4。</p>
<p>如果<code>mbstowcs()</code>的第一个参数为<code>NULL</code>，则返回目标宽字符串会包含的字符数量。</p>
<h2 id="命令行环境">命令行环境</h2>
<h3 id="命令行参数">命令行参数</h3>
<p>C 语言程序可以从命令行接收参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./foo hello world
</span></span></code></pre></div><p>上面示例中，程序<code>foo</code>接收了两个命令行参数<code>hello</code>和<code>world</code>。</p>
<p>程序内部怎么拿到命令行参数呢？C 语言会把命令行输入的内容，放在一个数组里面。<code>main()</code>函数的参数可以接收到这个数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> argc; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;arg %d: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, i, argv[i]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>main()</code>函数有两个参数<code>argc</code>（argument count）和<code>argv</code>（argument variable）。这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词。</p>
<p>第一个参数<code>argc</code>是命令行参数的数量，由于程序名也被计算在内，所以严格地说<code>argc</code>是参数数量 + 1。</p>
<p>第二个参数<code>argv</code>是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针。</p>
<p>以<code>./foo hello world</code>为例，<code>argc</code>是3，表示命令行输入有三个组成部分：<code>./foo</code>、<code>hello</code>、<code>world</code>。数组<code>argv</code>用来获取这些输入，<code>argv[0]</code>是程序名<code>./foo</code>，<code>argv[1]</code>是<code>hello</code>，<code>argv[2]</code>是<code>world</code>。一般来说，<code>argv[1]</code>到<code>argv[argc - 1]</code>依次是命令行的所有参数。<code>argv[argc]</code>则是一个空指针 NULL。</p>
<p>由于字符串指针可以看成是字符数组，所以下面两种写法是等价的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法一
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> argv[])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写法二
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">**</span> argv)
</span></span></code></pre></div><p>另一方面，每个命令行参数既可以写成数组形式<code>argv[i]</code>，也可以写成指针形式<code>*(argv + i)</code>。</p>
<p>利用<code>argc</code>，可以限定函数只能有多少个参数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">**</span> argv) {
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (argc <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">3</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;usage: mult x y</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>     <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">atoi</span>(argv[<span style="color:#099">1</span>]) <span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">atoi</span>(argv[<span style="color:#099">2</span>]));
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>argc</code>不等于<code>3</code>就会报错，这样就限定了程序必须有两个参数，才能运行。</p>
<p>另外，<code>argv</code>数组的最后一个成员是 NULL 指针（<code>argv[argc] == NULL</code>）。所以，参数的遍历也可以写成下面这样。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">**</span> p <span style="color:#000;font-weight:bold">=</span> argv; <span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#0086b3">NULL</span>; p<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;arg: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#000;font-weight:bold">*</span>p);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，指针<code>p</code>依次移动，指向<code>argv</code>的每个成员，一旦移到空指针 NULL，就表示遍历结束。由于<code>argv</code>的地址是固定的，不能执行自增运算（<code>argv++</code>），所以必须通过一个中间变量<code>p</code>，完成遍历操作。</p>
<h3 id="退出状态">退出状态</h3>
<p>C 语言规定，如果<code>main()</code>函数没有<code>return</code>语句，那么结束运行的时候，默认会添加一句<code>return 0</code>，即返回整数<code>0</code>。这就是为什么<code>main()</code>语句通常约定返回一个整数值，并且返回整数<code>0</code>表示程序运行成功。如果返回非零值，就表示程序运行出了问题。</p>
<p>Bash 的环境变量<code>$?</code>可以用来读取上一个命令的返回值，从而知道是否运行成功。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./foo hello world
</span></span><span style="display:flex;"><span><span style="color:#0086b3">echo</span> <span style="color:#008080">$?</span>
</span></span><span style="display:flex;"><span><span style="color:#099">0</span>
</span></span></code></pre></div><p>上面示例中，<code>echo $?</code>用来打印环境变量<code>$?</code>的值，该值为<code>0</code>，就表示上一条命令运行成功，否则就是运行失败。</p>
<p>注意，只有<code>main()</code>会默认添加<code>return 0</code>，其他函数都没有这个机制。</p>
<h3 id="环境变量">环境变量</h3>
<p>C 语言提供了<code>getenv()</code>函数（原型在<code>stdlib.h</code>）用来读取命令行环境变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> val <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">getenv</span>(<span style="color:#d14">&#34;HOME&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">if</span> (val <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Cannot find the HOME environment variable</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Value: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, val);
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面示例中，<code>getenv(&quot;HOME&quot;)</code>用来获取命令行的环境变量<code>$HOME</code>，如果这个变量为空（<code>NULL</code>），则程序报错返回。</p>
<h2 id="多线程">多线程</h2>
<p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>
<h3 id="创建多线程">创建多线程</h3>
<p>可以用它来创建一个POSIX 线程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#458;font-weight:bold">pthread_t</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">thread</span>, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">pthread_attr_t</span> <span style="color:#000;font-weight:bold">*</span>attr, 
</span></span><span style="display:flex;"><span>                   (<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span>)(<span style="color:#000;font-weight:bold">*</span>start_routine)(<span style="color:#458;font-weight:bold">void</span><span style="color:#000;font-weight:bold">*</span>), <span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg);
</span></span></code></pre></div><p><code>pthread_create()</code>创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<p><code>thread</code>：指向线程标识符指针。</p>
<p><code>attr</code> ：一个不透明的属性对象，可以被用来设置线程属性。可以指定线程属性对象，也可以使用默认值 NULL</p>
<p><code>start_routine</code>： 线程运行函数的起始地址，一旦线程被创建就会执行。</p>
<p><code>arg</code>：运行函数的参数。通过引用作为指针强制转换为void类型进行传递。若没有传递参数，则使用 NULL</p>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">myfunc</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>args) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;hello world!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">const</span> <span style="color:#000;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> pt; <span style="color:#998;font-style:italic">// 定义线程ID
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>pt, <span style="color:#0086b3">NULL</span>, myfunc, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_join</span>(pt, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 等待线程结束
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>创建一个多线程程序主要分为三步：</p>
<ol>
<li>声明一个线程变量<code>th</code>，类型为<code>pthread_t</code>；</li>
<li>使用<code>pthread_create</code>函数进行创建：
<ul>
<li>第一个参数是线程变量的地址；</li>
<li>第三个参数是线程执行的函数(返回值为<code>void*</code>)。</li>
</ul>
</li>
<li>pthread_join函数等待；</li>
</ol>
<p>编译的时候要注意，涉及到多线程的时候，得在<strong>gcc参数里加上 <code>-lpthread</code></strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">myfunc</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>args) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>name <span style="color:#000;font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>) args;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">200</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;%s: %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, name, i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">const</span> <span style="color:#000;font-weight:bold">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> pt1; <span style="color:#998;font-style:italic">// 定义线程ID
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">pthread_t</span> pt2; <span style="color:#998;font-style:italic">// 定义线程ID
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>pt1, <span style="color:#0086b3">NULL</span>, myfunc, <span style="color:#d14">&#34;th1&#34;</span>); <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>pt2, <span style="color:#0086b3">NULL</span>, myfunc, <span style="color:#d14">&#34;th2&#34;</span>); <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(pt1, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 等待线程结束
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_join</span>(pt2, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 等待线程结束
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="终止线程">终止线程</h3>
<p>用它来终止一个 POSIX 线程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span>  pthread_exit<span style="color:#a61717;background-color:#e3d2d2">（</span><span style="color:#458;font-weight:bold">void</span>  <span style="color:#000;font-weight:bold">*</span>retval<span style="color:#a61717;background-color:#e3d2d2">）</span>;
</span></span></code></pre></div><p><code>pthread_exit()</code>用于显式地退出一个线程。通常情况下，<code>pthread_exit()</code>函数是在线程完成工作后无需继续存在时被调用。</p>
<p>如果<code>main()</code>是在它所创建的线程之前结束，并通过<code>pthread_exit()</code>退出，那么其他线程将继续执行。否则，它们将在<code>main()</code>结束时自动被终止。</p>
<h3 id="连接和分离线程">连接和分离线程</h3>
<p><code>pthread_join</code> 和 <code>pthread_detach</code> 是用于管理线程的两个重要函数，它们用于控制线程的生命周期和资源管理</p>
<ol>
<li>
<p><code>pthread_join</code> 函数：</p>
<ul>
<li><code>pthread_join</code> 用于等待一个线程的完成。当一个线程调用 <code>pthread_join</code> 来等待另一个线程时，调用线程将被阻塞，直到目标线程完成执行。</li>
<li>通常，通过调用 <code>pthread_join</code>，可以获取目标线程的返回值（如果目标线程有返回值）。</li>
<li>一旦目标线程完成，其资源（内存等）将被释放，以防止资源泄漏。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_t</span> <span style="color:#000;font-weight:bold">thread</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 创建线程并等待它完成
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">thread</span>, <span style="color:#0086b3">NULL</span>, my_thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 第一个参数表示要等待的进程的id；
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 第二参数表示要等待的进程的返回状态，是个二级指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_join</span>(<span style="color:#000;font-weight:bold">thread</span>, <span style="color:#0086b3">NULL</span>);
</span></span></code></pre></div></li>
<li>
<p><code>pthread_detach</code> 函数：</p>
<ul>
<li><code>pthread_detach</code> 用于将线程设置为分离状态。分离状态的线程完成后，其资源会立即被释放，无需等待其他线程调用 <code>pthread_join</code>。</li>
<li>通常用于不需要等待线程完成的情况，或者当你不关心线程的返回值时。</li>
<li>分离线程通常用于执行一些后台任务，不需要与主线程同步。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_t</span> <span style="color:#000;font-weight:bold">thread</span>;
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 创建线程并将其设置为分离状态
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">thread</span>, <span style="color:#0086b3">NULL</span>, my_thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 参数：指定线程的ID，指定的ID的线程变成分离状态；
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#900;font-weight:bold">pthread_detach</span>(<span style="color:#000;font-weight:bold">thread</span>);
</span></span></code></pre></div></li>
</ol>
<p>需要注意的是，一旦线程被设置为分离状态，就无法再次将其转为非分离状态。因此，在使用 <code>pthread_detach</code> 之前，请确保不需要等待该线程的完成或获取其返回值。</p>
<p>总之，<code>pthread_join</code> 用于等待线程完成并获取其返回值，而 <code>pthread_detach</code> 用于将线程设置为分离状态，以在线程完成后自动释放其资源。选择哪个函数取决于你的应用程序需求。</p>
<h4 id="注意">注意</h4>
<p><code>pthread</code>库不是Linux系统默认的库，连接时需要使用库<code>libpthread.a</code>，在使用<code>pthread_create</code>创建线程时，在编译中要加<code>-lpthread</code>参数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gcc createThread.c -lpthread -o
</span></span></code></pre></div><p>创建一个数组，其中有5000个元素，想用两个线程来共同计算这5000个元素的加法和。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> first;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> last;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> result;
</span></span><span style="display:flex;"><span>} MY_ARGS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> arr[<span style="color:#099">5000</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">myFunc1</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>args) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>    MY_ARGS <span style="color:#000;font-weight:bold">*</span>my_args <span style="color:#000;font-weight:bold">=</span> (MY_ARGS <span style="color:#000;font-weight:bold">*</span>) args;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> my_args<span style="color:#000;font-weight:bold">-&gt;</span>first; i <span style="color:#000;font-weight:bold">&lt;</span> my_args<span style="color:#000;font-weight:bold">-&gt;</span>last; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        s <span style="color:#000;font-weight:bold">+=</span> arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    my_args<span style="color:#000;font-weight:bold">-&gt;</span>result <span style="color:#000;font-weight:bold">=</span> s;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">5000</span>; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        arr[i] <span style="color:#000;font-weight:bold">=</span> i <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th1;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MY_ARGS args1 <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>, <span style="color:#099">2500</span>, <span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>    MY_ARGS args2 <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">2500</span>, <span style="color:#099">5000</span>, <span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th1, <span style="color:#0086b3">NULL</span>, myFunc1, <span style="color:#000;font-weight:bold">&amp;</span>args1);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th2, <span style="color:#0086b3">NULL</span>, myFunc1, <span style="color:#000;font-weight:bold">&amp;</span>args2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;s1=%d, s2=%d, s1+s2=%d&#34;</span>, args1.result, args2.result, args1.result <span style="color:#000;font-weight:bold">+</span> args2.result);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="示例程序">示例程序</h3>
<h4 id="无参数传递的线程并发编程实例">无参数传递的线程并发编程实例</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 基于线程的并发编程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * pthread库不是Linux系统默认的库，连接时需要使用库libpthread.a,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 在使用pthread_create创建线程时，在编译中要加-lpthread参数:
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * gcc createThread.c -lpthread -o createThread.o
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * ./createThread.o
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 加上上面两句以后编译成功，并输出结果
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * */</span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define NUM_Threads 5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 线程的运行函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">PrintHello</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello,World of Thread in C!</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 定义线程的id变量，多个变量使用数组
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">pthread_t</span> tids[NUM_Threads];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> NUM_Threads; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 参数依次是： 创建的线程id，线程参数，调用的函数，传入的函数参数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>       ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>tids[i], <span style="color:#0086b3">NULL</span>, PrintHello, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>       <span style="color:#000;font-weight:bold">if</span> (ret <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;pthread_create error: error_code = </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 等各个线程推出后，进程才结束
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_exit</span>(<span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="简单参数传递的线程并发编程实例">简单参数传递的线程并发编程实例</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 基于线程的并发编程,向线程传递参数1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define NUM_Threads 5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 线程的运行函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">PrintHelloId</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>threadid) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 对传入的参数进行强制类型转换，由无类型指针变为整形指针，然后再读取
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> tid <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>((<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)threadid);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Hello,World， Thread %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,tid);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> pthreads[NUM_Threads];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i, rc;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 用数组存储i的数值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> indexes[NUM_Threads];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Threads; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;main() : 创建线程 %d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,i);
</span></span><span style="display:flex;"><span>        indexes[i] <span style="color:#000;font-weight:bold">=</span> i; <span style="color:#998;font-style:italic">// 保存i的数值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 在indexes传入参数的时候必须转换为无类型指针
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        rc <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>pthreads[i], <span style="color:#0086b3">NULL</span>, PrintHelloId, (<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>indexes[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> rc) {
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Error: 无法创建线程！</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">exit</span>(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_exit</span>(<span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 在CLion（Ubuntu）中输出结果是
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Hello,World， Thread 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Hello,World， Thread 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Hello,World， Thread 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Hello,World， Thread 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">Hello,World， Thread 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * */</span>
</span></span></code></pre></div><h4 id="结构体参数传递的线程并发编程实例">结构体参数传递的线程并发编程实例</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 基于线程的并发编程,向线程传递参数2(传递结构体)
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Test_3_createThread
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define NUM_Threads 5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">typedef</span> <span style="color:#000;font-weight:bold">struct</span> thread_data{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> threadid;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">char</span> message;
</span></span><span style="display:flex;"><span>}THDATA,<span style="color:#000;font-weight:bold">*</span>PTHDATA;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span> <span style="color:#900;font-weight:bold">PrintHello</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span> pthreadid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PTHDATA tid <span style="color:#000;font-weight:bold">=</span> (PTHDATA)pthreadid;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;This is Pthread : %d ;info : %c </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,tid<span style="color:#000;font-weight:bold">-&gt;</span>threadid, tid<span style="color:#000;font-weight:bold">-&gt;</span>message);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> Pthread[NUM_Threads];
</span></span><span style="display:flex;"><span>    THDATA index[NUM_Threads];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i, ret;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> NUM_Threads; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;main() : 创建线程 %d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,i);
</span></span><span style="display:flex;"><span>        index[i].threadid <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        index[i].message <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;A&#39;</span><span style="color:#000;font-weight:bold">+</span>i<span style="color:#000;font-weight:bold">%</span><span style="color:#099">10</span>;
</span></span><span style="display:flex;"><span>        ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>Pthread[i], <span style="color:#0086b3">NULL</span>, PrintHello, (<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>index[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> ret)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Error: 创建线程失败！</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">exit</span>(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_exit</span>(<span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * 在CLion（Ubuntu）中输出结果是
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This is Pthread : 0 ;info : A
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 2
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 3
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This is Pthread : 2 ;info : C
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">main() : 创建线程 4
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This is Pthread : 3 ;info : D
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This is Pthread : 4 ;info : E
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">This is Pthread : 1 ;info : B
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * */</span>
</span></span></code></pre></div><h4 id="线程的连接编程实例">线程的连接编程实例</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 基于线程的并发编程,连接或分离线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Test_4_createThread
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 2019年10月27日14:45:11 尚未完全搞明白
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define NUM_Pthread 5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">PrintHello</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span> pthreadid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> tid <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>((<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)pthreadid);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Sleeping in thread %d ,...exiting </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,tid);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i, ret;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> Pthread[NUM_Pthread];
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_attr_t</span> attr; <span style="color:#998;font-style:italic">// 定义线程属性
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span> status;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> index[NUM_Pthread];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 初始化并设置线程为可连接
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_attr_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>attr);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_attr_setdetachstate</span>(<span style="color:#000;font-weight:bold">&amp;</span>attr, PTHREAD_CREATE_JOINABLE);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Pthread; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;main() : 创建线程 %d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,i);
</span></span><span style="display:flex;"><span>        index[i] <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>Pthread[i], <span style="color:#0086b3">NULL</span>, PrintHello, (<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>index[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 删除属性，并等待其他线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_attr_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>attr);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Pthread; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_join</span>(Pthread[i], status);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> ret)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Error: unable to join,%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,ret);
</span></span><span style="display:flex;"><span>            <span style="color:#900;font-weight:bold">exit</span>(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;main(): complete thread id : %d&#34;</span>,i);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34; exiting with status : %p</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,status);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;main() : program exiting.</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_exit</span>(<span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="并发程序引起的共享内存问题">并发程序引起的共享内存问题</h3>
<blockquote>
<p>问题：有两个进程，两个进程共享全局变量s。两个进程都执行一个计数功能的函数，th1运行时<code>s++</code>要执行10000次，th2运行时<code>s++</code>也要执行10000次，似乎计算得到的最后s应该是20000。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">myFunc</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>args) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10000</span>; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        s<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th1;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th1, <span style="color:#0086b3">NULL</span>, myFunc, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th2, <span style="color:#0086b3">NULL</span>, myFunc, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;s = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当执行<code>s++</code>，底层发生的事件其实是：<code>内存中读取s</code> → <code>将s+1</code> → <code>将s写入到内存</code>。这不是一个原子化操作，当两个线程交错运行的时候，很容易发生结果的丢失。因此最后的结果肯定是要小于20000的。这种情况有种专有名词，叫<code>race condition</code>。</p>
<h4 id="解决方案">解决方案</h4>
<p>加锁：保证共享内存区(临界区)的原子化操作，可以在进入非原子代码之前加锁(<code>pthread_mutex_lock</code>)，意味着其他线程看到这段内存被其他人占有的时候，就不去抢占，等这段内存被解锁(<code>pthread_mutex_unlock</code>)之后，它才有读写这段临界区的权利</p>
<p>加锁的方式执行速度并不快，能解决内存读写冲突的问题，但是却牺牲了效率</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 锁声明
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">pthread_mutex_t</span> lock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">myFunc</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>args) {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10000</span>; <span style="color:#000;font-weight:bold">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>lock); <span style="color:#998;font-style:italic">// 加锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        s<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>lock); <span style="color:#998;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th1;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> th2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 初始化锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_mutex_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>lock, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th1, <span style="color:#0086b3">NULL</span>, myFunc, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>th2, <span style="color:#0086b3">NULL</span>, myFunc, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(th2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;s = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>pthread_mutex_init</code> 函数是用于初始化互斥锁（mutex）的 POSIX 线程库函数。互斥锁是一种用于线程同步的机制，它可以防止多个线程同时访问共享资源，从而避免竞态条件（race conditions）和数据不一致问题。</p>
<p>以下是 <code>pthread_mutex_init</code> 函数的基本信息：</p>
<p><strong>函数签名</strong>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">pthread_mutex_init</span>(<span style="color:#458;font-weight:bold">pthread_mutex_t</span> <span style="color:#000;font-weight:bold">*</span>mutex, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">pthread_mutexattr_t</span> <span style="color:#000;font-weight:bold">*</span>attr);
</span></span></code></pre></div><p><strong>参数</strong>：</p>
<ul>
<li><code>mutex</code>：指向要初始化的互斥锁的指针，通常是 <code>pthread_mutex_t</code> 类型的变量。</li>
<li><code>attr</code>：一个可选的指向互斥锁属性的指针。可以传入 <code>NULL</code> 来使用默认属性，或者使用 <code>pthread_mutexattr_init</code> 函数来自定义属性。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果成功，函数返回0。</li>
<li>如果出现错误，返回一个非零错误码，你可以使用 <code>strerror</code> 函数将其转换为相应的错误消息。</li>
</ul>
<p><strong>示例用法</strong>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_mutex_t</span> my_mutex;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 初始化互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">pthread_mutex_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>my_mutex, <span style="color:#0086b3">NULL</span>) <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">perror</span>(<span style="color:#d14">&#34;互斥锁初始化失败&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 使用互斥锁进行线程同步操作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 销毁互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_mutex_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>my_mutex);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的示例中，首先定义了一个<code>pthread_mutex_t</code>类型的变量<code>my_mutex</code>，然后使用<code>pthread_mutex_init</code>函数对其进行初始化。初始化成功，可以使用<code>my_mutex</code>来进行线程同步操作；使用<code>pthread_mutex_destroy</code>函数来销毁互斥锁，释放相关的资源。</p>
<p>注意事项：</p>
<ul>
<li>互斥锁在使用前必须被初始化。</li>
<li>在不再需要互斥锁时，应使用 <code>pthread_mutex_destroy</code> 来释放相关资源。</li>
<li>在使用互斥锁时，要小心避免死锁等问题，确保正确地获取和释放锁，以避免程序阻塞或产生竞态条件。</li>
</ul>
<p>在C语言中，有多种类型的锁用于线程同步和资源管理。以下是常见的锁类型：</p>
<ol>
<li><strong>互斥锁（Mutex）</strong>：
<ul>
<li>互斥锁是最常见的锁类型，用于确保在任何给定时间只有一个线程能够访问共享资源。当一个线程获得互斥锁时，其他线程将被阻塞，直到该线程释放锁。</li>
<li>C语言中的互斥锁通常使用 <code>pthread_mutex_t</code> 类型来表示，并可以使用 <code>pthread_mutex_init</code>、<code>pthread_mutex_lock</code>、<code>pthread_mutex_unlock</code> 和 <code>pthread_mutex_destroy</code> 等函数进行操作。</li>
</ul>
</li>
<li><strong>读写锁（Read-Write Lock）</strong>：
<ul>
<li>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这对于读多写少的情况非常有用，可以提高并发性。</li>
<li>C语言中的读写锁通常使用 <code>pthread_rwlock_t</code> 类型来表示，并可以使用 <code>pthread_rwlock_init</code>、<code>pthread_rwlock_rdlock</code>、<code>pthread_rwlock_wrlock</code>、<code>pthread_rwlock_unlock</code> 和 <code>pthread_rwlock_destroy</code> 等函数进行操作。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）</strong>：
<ul>
<li>条件变量是一种用于线程之间通信和同步的机制。它允许一个线程等待某个条件为真，而其他线程可以在满足条件时通知等待线程。</li>
<li>C语言中的条件变量通常使用 <code>pthread_cond_t</code> 类型来表示，并可以使用 <code>pthread_cond_init</code>、<code>pthread_cond_wait</code>、<code>pthread_cond_signal</code> 和 <code>pthread_cond_broadcast</code> 等函数进行操作。</li>
</ul>
</li>
<li><strong>自旋锁（Spin Lock）</strong>：
<ul>
<li>自旋锁是一种非阻塞锁，线程尝试获取锁时不会被阻塞，而是会不断地尝试获取锁，直到成功。自旋锁适用于对锁的争用时间非常短的情况。</li>
<li>C语言中可以使用 <code>pthread_spinlock_t</code> 类型来表示自旋锁，并可以使用 <code>pthread_spin_init</code>、<code>pthread_spin_lock</code>、<code>pthread_spin_unlock</code> 和 <code>pthread_spin_destroy</code> 等函数进行操作。</li>
</ul>
</li>
<li><strong>信号量（Semaphore）</strong>：
<ul>
<li>信号量是一种用于控制并发访问资源数量的机制。它可以用于实现限制并发线程数、线程间同步等。</li>
<li>C语言中的信号量通常使用 <code>sem_t</code> 类型来表示，并可以使用 <code>sem_init</code>、<code>sem_wait</code>、<code>sem_post</code> 和 <code>sem_destroy</code> 等函数进行操作。</li>
</ul>
</li>
</ol>
<p>这些锁类型各有特点，选择合适的锁取决于你的应用程序的需求和性能考虑。不同的锁适用于不同的并发情境，因此在编写多线程程序时，选择正确的锁类型非常重要。</p>
<h4 id="互斥锁">互斥锁</h4>
<p>互斥锁（Mutex，全名 Mutual Exclusion）是一种线程同步机制，用于确保在任何给定时间只有一个线程能够访问共享资源，从而防止多线程之间发生竞态条件（race conditions）和数据不一致问题。在C语言中，你可以使用 POSIX 线程库（pthread）来实现互斥锁。</p>
<p>以下是互斥锁的基本操作和示例用法：</p>
<p><strong>初始化互斥锁</strong>： 你可以使用 <code>pthread_mutex_init</code> 函数来初始化互斥锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_mutex_t</span> mutex;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_mutex_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 初始化互斥锁
</span></span></span></code></pre></div><p><strong>加锁</strong>： 当一个线程需要访问共享资源时，它需要先获得互斥锁。使用 <code>pthread_mutex_lock</code> 函数来加锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_mutex_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 加锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 访问共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_mutex_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 解锁
</span></span></span></code></pre></div><p><strong>尝试加锁</strong>： 有时候，你可能想要尝试加锁，如果锁已被其他线程占用，则不等待，而是立即返回一个错误码。这可以使用 <code>pthread_mutex_trylock</code> 函数来实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">pthread_mutex_trylock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 成功获取锁，可以访问共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_mutex_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 锁已被其他线程占用
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 可以执行备用操作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p><strong>销毁互斥锁</strong>： 在不再需要互斥锁时，使用 <code>pthread_mutex_destroy</code> 函数来释放相关资源：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_mutex_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 销毁互斥锁
</span></span></span></code></pre></div><p>下面是一个示例程序，演示了如何使用互斥锁来确保多个线程访问共享资源的互斥性：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_mutex_t</span> mutex;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> shared_data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">thread_function</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10000</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 加锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        shared_data<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex); <span style="color:#998;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> thread1, thread2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_mutex_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread1, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread2, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_mutex_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;共享数据的值：%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, shared_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的示例中，我们创建了两个线程，它们同时访问一个共享的 <code>shared_data</code> 变量。使用互斥锁确保了每次只有一个线程能够修改 <code>shared_data</code>，从而避免了竞态条件问题。</p>
<h4 id="读写锁">读写锁</h4>
<p>读写锁（Read-Write Lock）是一种线程同步机制，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁的设计可以提高并发性，特别适用于读多写少的情况，因为多个线程可以同时读取，而写操作需要互斥执行，以防止写操作之间的竞争条件。</p>
<p>在C语言中，你可以使用 POSIX 线程库（pthread）来实现读写锁。以下是读写锁的基本操作和示例用法：</p>
<p><strong>初始化读写锁</strong>： 你可以使用 <code>pthread_rwlock_init</code> 函数来初始化读写锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_rwlock_t</span> rwlock;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock, <span style="color:#0086b3">NULL</span>); <span style="color:#998;font-style:italic">// 初始化读写锁
</span></span></span></code></pre></div><p><strong>读取共享资源</strong>： 多个线程可以同时使用读锁来读取共享资源，而不会相互阻塞。使用 <code>pthread_rwlock_rdlock</code> 函数来获取读锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_rdlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock); <span style="color:#998;font-style:italic">// 获取读锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 读取共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock); <span style="color:#998;font-style:italic">// 释放读锁
</span></span></span></code></pre></div><p><strong>写入共享资源</strong>： 只有一个线程可以拥有写锁，以确保写操作的互斥性。使用 <code>pthread_rwlock_wrlock</code> 函数来获取写锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_wrlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock); <span style="color:#998;font-style:italic">// 获取写锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 写入共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock); <span style="color:#998;font-style:italic">// 释放写锁
</span></span></span></code></pre></div><p><strong>销毁读写锁</strong>： 在不再需要读写锁时，使用 <code>pthread_rwlock_destroy</code> 函数来释放相关资源：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_rwlock_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock); <span style="color:#998;font-style:italic">// 销毁读写锁
</span></span></span></code></pre></div><p>下面是一个完整的示例程序，演示了如何使用读写锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_rwlock_t</span> rwlock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">reader</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_rwlock_rdlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;读取共享资源</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_rwlock_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock);
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 模拟读取操作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">usleep</span>(<span style="color:#099">100000</span>); <span style="color:#998;font-style:italic">// 睡眠100毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">writer</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#099">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_rwlock_wrlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;写入共享资源</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_rwlock_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock);
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 模拟写入操作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">usleep</span>(<span style="color:#099">200000</span>); <span style="color:#998;font-style:italic">// 睡眠200毫秒
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> reader_thread, writer_thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_rwlock_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>reader_thread, <span style="color:#0086b3">NULL</span>, reader, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>writer_thread, <span style="color:#0086b3">NULL</span>, writer, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(reader_thread, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(writer_thread, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_rwlock_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>rwlock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的示例中，我们创建了一个读者线程和一个写者线程，它们可以并发地读取和写入共享资源。读者使用 <code>pthread_rwlock_rdlock</code> 获取读锁，而写者使用 <code>pthread_rwlock_wrlock</code> 获取写锁。这确保了多个读者可以同时访问共享资源，而只有一个写者能够写入。</p>
<h4 id="自旋锁">自旋锁</h4>
<p>自旋锁（Spin Lock）是一种线程同步机制，与互斥锁类似，用于确保在任何给定时间只有一个线程能够访问共享资源。不同之处在于，自旋锁不会将线程阻塞在等待锁的地方，而是会一直忙等（自旋）直到锁可用。</p>
<p>自旋锁适用于对共享资源的访问时间非常短的情况，因为在自旋等待期间，线程会一直占用CPU资源。如果共享资源的锁定时间长，自旋等待可能会浪费大量CPU时间，因此在选择使用自旋锁时，需要根据具体情况谨慎考虑。</p>
<p>在C语言中，你可以使用 POSIX 线程库（pthread）来实现自旋锁。以下是自旋锁的基本操作和示例用法：</p>
<p><strong>初始化自旋锁</strong>： 你可以使用 <code>pthread_spin_init</code> 函数来初始化自旋锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_spinlock_t</span> spinlock;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_spin_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock, PTHREAD_PROCESS_PRIVATE); <span style="color:#998;font-style:italic">// 初始化自旋锁
</span></span></span></code></pre></div><p>在初始化时，可以传递 <code>PTHREAD_PROCESS_PRIVATE</code> 或 <code>PTHREAD_PROCESS_SHARED</code> 作为第二个参数，以指定自旋锁的范围。</p>
<p><strong>加锁</strong>： 当一个线程需要访问共享资源时，它需要先尝试获取自旋锁。使用 <code>pthread_spin_lock</code> 函数来加锁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_spin_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 尝试加锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 访问共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_spin_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 解锁
</span></span></span></code></pre></div><p><strong>尝试加锁</strong>： 与互斥锁类似，你可以使用 <code>pthread_spin_trylock</code> 函数来尝试加锁，如果锁已经被其他线程占用，它会立即返回一个错误码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (<span style="color:#900;font-weight:bold">pthread_spin_trylock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 成功获取锁，可以访问共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">pthread_spin_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 锁已被其他线程占用
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 可以执行备用操作
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p><strong>销毁自旋锁</strong>： 在不再需要自旋锁时，使用 <code>pthread_spin_destroy</code> 函数来释放相关资源：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">pthread_spin_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 销毁自旋锁
</span></span></span></code></pre></div><p>下面是一个示例程序，演示了如何使用自旋锁来确保多个线程访问共享资源的互斥性：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">pthread_spinlock_t</span> spinlock;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> shared_data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">thread_function</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10000</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_spin_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 尝试加锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        shared_data<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_spin_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock); <span style="color:#998;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> thread1, thread2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_spin_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock, PTHREAD_PROCESS_PRIVATE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread1, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread2, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_spin_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>spinlock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;共享数据的值：%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, shared_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的示例中，我们创建了两个线程，它们同时访问一个共享的 <code>shared_data</code> 变量。使用自旋锁确保了每次只有一个线程能够修改 <code>shared_data</code>，从而避免了竞态条件问题。请注意，自旋锁会忙等，因此在锁的范围内执行的操作应尽可能快速。</p>
<h3 id="信号量机制">信号量机制</h3>
<p>信号量（Semaphore）是一种用于多线程编程的同步和通信机制，它允许线程之间协调共享资源的访问。信号量通常用于控制对共享资源的并发访问数量，或者在多个线程之间实现线程的同步。</p>
<p>在C语言中，你可以使用 POSIX 线程库（pthread）来实现信号量。以下是信号量的基本操作和示例用法：</p>
<p><strong>初始化信号量</strong>： 你可以使用 <code>sem_init</code> 函数来初始化信号量：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;semaphore.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">sem_t</span> semaphore;
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sem_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore, <span style="color:#099">0</span>, initial_value); <span style="color:#998;font-style:italic">// 初始化信号量
</span></span></span></code></pre></div><p>第三个参数 <code>initial_value</code> 是信号量的初始值，它指定了初始的资源数量。</p>
<p><strong>等待资源</strong>： 线程可以使用 <code>sem_wait</code> 函数来等待信号量中的资源。如果信号量的资源数量大于零，<code>sem_wait</code> 函数将减少资源数量并立即返回。如果资源数量为零，线程将被阻塞，直到有其他线程释放资源。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sem_wait</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore); <span style="color:#998;font-style:italic">// 等待资源
</span></span></span></code></pre></div><p><strong>释放资源</strong>： 线程可以使用 <code>sem_post</code> 函数来释放信号量中的资源，增加资源数量。这通常由某个线程完成，以通知其他等待资源的线程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sem_post</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore); <span style="color:#998;font-style:italic">// 释放资源
</span></span></span></code></pre></div><p><strong>销毁信号量</strong>： 在不再需要信号量时，使用 <code>sem_destroy</code> 函数来释放相关资源：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#900;font-weight:bold">sem_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore); <span style="color:#998;font-style:italic">// 销毁信号量
</span></span></span></code></pre></div><p>下面是一个示例程序，演示了如何使用信号量来控制多个线程对共享资源的访问：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;semaphore.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">sem_t</span> semaphore;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> shared_data <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">thread_function</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">10000</span>; i<span style="color:#000;font-weight:bold">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">sem_wait</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore); <span style="color:#998;font-style:italic">// 等待资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        shared_data<span style="color:#000;font-weight:bold">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">sem_post</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore); <span style="color:#998;font-style:italic">// 释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> thread1, thread2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">sem_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore, <span style="color:#099">0</span>, <span style="color:#099">1</span>); <span style="color:#998;font-style:italic">// 初始化信号量，初始资源数量为1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread1, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>thread2, <span style="color:#0086b3">NULL</span>, thread_function, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread1, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_join</span>(thread2, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">sem_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>semaphore);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;共享数据的值：%d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, shared_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在上面的示例中，我们创建了两个线程，它们同时访问一个共享的 <code>shared_data</code> 变量。使用信号量确保了每次只有一个线程能够修改 <code>shared_data</code>，从而避免了竞态条件问题。初始资源数量为1，因此最多只允许一个线程同时访问共享资源。</p>
<h4 id="实例-3">实例</h4>
<h5 id="信号量同步进行写入">信号量同步进行写入</h5>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 用信号量进行同步
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;unistd.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;semaphore.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define Len 100       </span><span style="color:#998;font-style:italic">// 设置输入内容长度
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">sem_t</span> bin_sem;
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">char</span> work_area[Len]; <span style="color:#998;font-style:italic">// 存放输入内容
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">Thread_func</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 等待信号量有大于0的值然后退出
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">sem_wait</span>(<span style="color:#000;font-weight:bold">&amp;</span>bin_sem);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> <span style="color:#900;font-weight:bold">strncmp</span>(<span style="color:#d14">&#34;end&#34;</span>, work_area, <span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Input %ld characters</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, <span style="color:#900;font-weight:bold">strlen</span>(work_area)<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> res;    <span style="color:#998;font-style:italic">// 存放命令的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">pthread_t</span> Pthread; <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>thread_result; <span style="color:#998;font-style:italic">// 存放线程处理结果
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 初始化信号量，并设置初始值为0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    res <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">sem_init</span>(<span style="color:#000;font-weight:bold">&amp;</span>bin_sem, <span style="color:#099">0</span>, <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> res)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">perror</span>(<span style="color:#d14">&#34;Semaphore initialization failes&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 创建新线程 0
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    res <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>Pthread, <span style="color:#0086b3">NULL</span>, Thread_func, <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> res)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">perror</span>(<span style="color:#d14">&#34;Thread creation failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Enter &#39;end&#39; to finish</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 当工作区内不是以end开头的字符串，则继续输入
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> <span style="color:#900;font-weight:bold">strncmp</span>(<span style="color:#d14">&#34;end&#34;</span>, work_area, <span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 以标准输入获取输入到工作区内
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">fgets</span>(work_area, Len, stdin);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">sem_post</span>(<span style="color:#000;font-weight:bold">&amp;</span>bin_sem);  <span style="color:#998;font-style:italic">// 信号量+1
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;</span><span style="color:#d14">\n</span><span style="color:#d14"> Waiting for thread to finish...</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 等待线程结束
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    res <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_join</span>(Pthread, <span style="color:#000;font-weight:bold">&amp;</span>thread_result);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> res)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">perror</span>(<span style="color:#d14">&#34;Thread join failed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Thread joined</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">sem_destroy</span>(<span style="color:#000;font-weight:bold">&amp;</span>bin_sem);  <span style="color:#998;font-style:italic">// 销毁信号量
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">exit</span>(EXIT_SUCCESS);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="互斥信号量实现对临界资源操作">互斥信号量实现对临界资源操作</h5>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 用互斥信号量进行同步
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#define Len 3 </span><span style="color:#998;font-style:italic">// 自增计算次数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold;font-style:italic">#define NUM_Pthread 5 </span><span style="color:#998;font-style:italic">// 设置线程的长度
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>; <span style="color:#998;font-style:italic">// 在数据段共享资源，多个进程抢占临界资源
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 对于临界资源，应该添加互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">pthread_mutex_t</span> mutex <span style="color:#000;font-weight:bold">=</span> PTHREAD_MUTEX_INITIALIZER;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">Thread_func</span>(<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>threadid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> tid <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>((<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>)threadid);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> i, val;
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Pthread ID : %d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,tid);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Pthread; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>        val <span style="color:#000;font-weight:bold">=</span> count;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;val = %d </span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,val<span style="color:#000;font-weight:bold">++</span>);
</span></span><span style="display:flex;"><span>        count <span style="color:#000;font-weight:bold">=</span> val;
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">pthread_mutex_unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> res;    <span style="color:#998;font-style:italic">// 存放命令的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">pthread_t</span> Pthread[NUM_Pthread]; <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> index[NUM_Pthread];
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Pthread; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        index[i] <span style="color:#000;font-weight:bold">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 创建线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>       res <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">pthread_create</span>(<span style="color:#000;font-weight:bold">&amp;</span>Pthread[i], <span style="color:#0086b3">NULL</span>, Thread_func, (<span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>index[i]);
</span></span><span style="display:flex;"><span>       <span style="color:#000;font-weight:bold">if</span> (<span style="color:#099">0</span> <span style="color:#000;font-weight:bold">!=</span> res)
</span></span><span style="display:flex;"><span>       {
</span></span><span style="display:flex;"><span>           <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Error: 创建线程失败！</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>);
</span></span><span style="display:flex;"><span>           <span style="color:#900;font-weight:bold">exit</span>(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> (i<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">&lt;</span>NUM_Pthread; i<span style="color:#000;font-weight:bold">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#998;font-style:italic">// 汇合线程
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">pthread_join</span>(Pthread[i], <span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;count = %d</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,count);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">pthread_exit</span>(<span style="color:#0086b3">NULL</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 在运行此程序无互斥锁时，我们不仅得到错误的答案，而且每次得到的答案都不相同
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 分析
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 当多个对等线程在一个处理器上并发运行时，机器指令以某种顺序完成，每个并发执行定义了线程中指令的某种顺序
</span></span></span></code></pre></div><h2 id="网络编程">网络编程</h2>
<h3 id="socket编程">Socket编程</h3>
<p>Socket 是一种抽象的概念，它是一种网络通信机制的统称。在 Unix 操作系统中，Socket 被视为一种文件描述符，与普通文件操作的函数（如<code>open()</code>、<code>read()</code>和<code>write()</code>等）相似。Socket 通常用于基于 TCP/IP 协议栈的网络编程，它能够使得网络中的不同主机之间能够互相通信。</p>
<h4 id="建立socket连接">建立Socket连接</h4>
<p>在 Socket 编程中，需要建立连接来进行通信。建立连接的过程可以分为服务器端和客户端两个步骤。</p>
<h5 id="服务器端">服务器端</h5>
<p>服务器端的主要任务是监听网络端口，等待客户端的连接请求。当一个客户端请求连接时，服务器端将为其分配一个新的 Socket 描述符，然后利用这个 Socket 与客户端进行通信。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;unistd.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;arpa/inet.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;sys/socket.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 创建Socket描述符
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> serv_sock <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 将Socket与IP地址和端口号绑定
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">struct</span> sockaddr_in serv_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">memset</span>(<span style="color:#000;font-weight:bold">&amp;</span>serv_addr, <span style="color:#099">0</span>, <span style="color:#000;font-weight:bold">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>    serv_addr.sin_family <span style="color:#000;font-weight:bold">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_addr.sin_addr.s_addr <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">htonl</span>(INADDR_ANY);
</span></span><span style="display:flex;"><span>    serv_addr.sin_port <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">htons</span>(<span style="color:#099">12345</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">bind</span>(serv_sock, (<span style="color:#000;font-weight:bold">struct</span> sockaddr<span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>serv_addr, <span style="color:#000;font-weight:bold">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 进入监听状态
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">listen</span>(serv_sock, <span style="color:#099">5</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 接受客户端的连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">struct</span> sockaddr_in clnt_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">socklen_t</span> clnt_addr_size <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">sizeof</span>(clnt_addr);
</span></span><span style="display:flex;"><span>    <span style="color:#458;font-weight:bold">int</span> clnt_sock <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">accept</span>(serv_sock, (<span style="color:#000;font-weight:bold">struct</span> sockaddr<span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>clnt_addr, <span style="color:#000;font-weight:bold">&amp;</span>clnt_addr_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 向客户端发送数据
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">char</span> str[] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Hello World!&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">write</span>(clnt_sock, str, <span style="color:#000;font-weight:bold">sizeof</span>(str));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 关闭Socket
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">close</span>(clnt_sock);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">close</span>(serv_sock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先使用<code>socket()</code>函数创建了一个 Socket 描述符，指定了协议族为<code>AF_INET</code>、传输协议为<code>SOCK_STREAM</code>（即 TCP/IP 协议）和协议号为<code>IPPROTO_TCP</code>。</p>
<p>接着，使用<code>bind()</code>函数将<code>Socket</code>与<code>IP</code>地址和端口号绑定。其中，<code>INADDR_ANY</code>表示任何 IP 地址都可以与之通信，而<code>htons()</code>函数用于将主机字节序转换为网络字节序。</p>
<p>然后，使用<code>listen()</code>函数将 Socket 设置为监听状态，参数 5 表示可以同时连接的客户端数量上限为 5。</p>
<p>最后，使用<code>accept()</code>函数等待客户端的连接请求，并为其分配一个新的 Socket 描述符。当客户端连接成功后，我们向其发送了一条“Hello World!”的消息，并关闭了 Socket。</p>
<h5 id="客户端">客户端</h5>
<p>客户端的主要任务是向服务器端发起连接请求，并进行通信。客户端需要知道服务器端的 IP 地址和端口号才能与其建立连接。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;unistd.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;arpa/inet.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;sys/socket.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 创建Socket描述符
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">int</span> sock <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 向服务器端发起连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">struct</span> sockaddr_in serv_addr;
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">memset</span>(<span style="color:#000;font-weight:bold">&amp;</span>serv_addr, <span style="color:#099">0</span>, <span style="color:#000;font-weight:bold">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>    serv_addr.sin_family <span style="color:#000;font-weight:bold">=</span> AF_INET;
</span></span><span style="display:flex;"><span>    serv_addr.sin_addr.s_addr <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">inet_addr</span>(<span style="color:#d14">&#34;127.0.0.1&#34;</span>);
</span></span><span style="display:flex;"><span>    serv_addr.sin_port <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">htons</span>(<span style="color:#099">12345</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">connect</span>(sock, (<span style="color:#000;font-weight:bold">struct</span> sockaddr<span style="color:#000;font-weight:bold">*</span>)<span style="color:#000;font-weight:bold">&amp;</span>serv_addr, <span style="color:#000;font-weight:bold">sizeof</span>(serv_addr));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 接收服务器端的数据
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">char</span> buf[<span style="color:#099">1024</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">read</span>(sock, buf, <span style="color:#000;font-weight:bold">sizeof</span>(buf) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">printf</span>(<span style="color:#d14">&#34;Message from server: %s</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>, buf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 关闭Socket
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">close</span>(sock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先使用<code>socket()</code>函数创建了一个Socket描述符，同样指定了协议族为<code>AF_INET</code>、传输协议为<code>SOCK_STREAM</code>和协议号为<code>IPPROTO_TCP</code>。</p>
<p>接着，使用<code>connect()</code>函数向服务器端发起连接请求，并指定服务器端的IP地址和端口号。其中，<code>inet_addr()</code>函数用于将字符串类型的 IP 地址转换为网络字节序的二进制值。</p>
<p>然后，使用<code>read()</code>函数接收服务器端发送的数据，并打印输出。最后，关闭 Socket。</p>
<p>Socket 编程中常用的一些函数：</p>
<ul>
<li><code>socket()</code>：创建 Socket 描述符；</li>
<li><code>bind()</code>：将 Socket 与 IP 地址和端口号绑定；</li>
<li><code>listen()</code>：将 Socket 设置为监听状态；</li>
<li><code>accept()</code>：等待客户端的连接请求，并为其分配一个新的 Socket 描述符；</li>
<li><code>connect()</code>：向服务器端发起连接请求；</li>
<li><code>read()</code>：接收数据；</li>
<li><code>write()</code>：发送数据；</li>
<li><code>close()</code>：关闭 Socket。</li>
</ul>
<h2 id="标准库">标准库</h2>
<h3 id="asserth">assert.h</h3>
<h3 id="ctypeh">ctype.h</h3>
<h3 id="errnoh">errno.h</h3>
<h3 id="floath">float.h</h3>
<h3 id="inttypesh">inttypes.h</h3>
<h3 id="iso646h">iso646.h</h3>
<h3 id="limitsh">limits.h</h3>
<h3 id="localeh">locale.h</h3>
<h3 id="mathh">math.h</h3>
<h3 id="signalh">signal.h</h3>
<h3 id="stdinth">stdint.h</h3>
<h3 id="stdlibh">stdlib.h</h3>
<h3 id="stdioh">stdio.h</h3>
<h3 id="stringh">string.h</h3>
<h3 id="timeh">time.h</h3>
<h3 id="wcharh">wchar.h</h3>
<h3 id="wctypeh">wctype.h</h3>

    </div>

    

    

    <div class="container-prevnext">
    <div><a href="https://fire-phenix.github.io/posts/cc&#43;&#43;/c&#43;&#43;%E5%AD%A6%E4%B9%A0/">← C&#43;&#43;学习</a></div>
    <div><a href="https://fire-phenix.github.io/posts/golang/golang%E5%AD%A6%E4%B9%A0/">GoLang学习  →</a></div>
</div>
    
    <div class="container-comment">
	<script src="https://utteranc.es/client.js"
        repo="loveminimal/comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</div>

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="" target="_blank">
        
        <span class="some">enter your icp or a interesting slogan...<span>
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
